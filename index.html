<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Anki Card Creator</title>
  <style>
    :root {
      color-scheme: light dark;
      font-family: "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      line-height: 1.5;
      font-size: 16px;
    }

    body {
      margin: 0;
      padding: 0;
      background: radial-gradient(circle at top left, #f7f8ff, #eaeefd 40%, #e0e0f5);
      min-height: 100vh;
      color: #1e2a44;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      padding: 2rem;
      box-sizing: border-box;
    }

    .app {
      background: rgba(255, 255, 255, 0.92);
      box-shadow: 0 20px 60px rgba(58, 75, 115, 0.25);
      border-radius: 20px;
      max-width: 1100px;
      width: 100%;
      display: grid;
      grid-template-columns: 340px 1fr;
      overflow: hidden;
    }

    .sidebar {
      padding: 2rem;
      background: linear-gradient(180deg, #3f64c7, #4650ac);
      color: white;
    }

    .sidebar h1 {
      margin-top: 0;
      margin-bottom: 1.5rem;
      font-size: 1.9rem;
      letter-spacing: 0.02em;
    }

    .sidebar section + section {
      margin-top: 2.5rem;
    }

    label {
      font-weight: 600;
      display: block;
      margin-bottom: 0.5rem;
    }

    input[type="text"],
    input[type="password"],
    textarea,
    select {
      width: 100%;
      border: 1px solid rgba(30, 42, 68, 0.2);
      border-radius: 10px;
      padding: 0.7rem 0.85rem;
      font-size: 1rem;
      font-family: inherit;
      box-sizing: border-box;
      background: rgba(255, 255, 255, 0.95);
      color: #1e2a44;
    }

    textarea {
      min-height: 120px;
      resize: vertical;
    }

    button {
      background: #3f64c7;
      border: none;
      border-radius: 999px;
      padding: 0.65rem 1.35rem;
      font-size: 0.95rem;
      font-weight: 600;
      color: white;
      cursor: pointer;
      transition: transform 0.15s ease, box-shadow 0.15s ease;
      box-shadow: 0 10px 30px rgba(63, 100, 199, 0.3);
    }

    button:hover {
      transform: translateY(-1px);
      box-shadow: 0 12px 32px rgba(63, 100, 199, 0.4);
    }

    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      box-shadow: none;
      transform: none;
    }

    .main {
      padding: 2rem 2.5rem;
      background: rgba(249, 250, 255, 0.9);
      display: flex;
      flex-direction: column;
      gap: 2rem;
    }

    .panel {
      background: white;
      border-radius: 16px;
      padding: 1.5rem;
      box-shadow: 0 10px 30px rgba(43, 58, 92, 0.1);
    }

    .panel h2 {
      margin-top: 0;
      font-size: 1.35rem;
      color: #2f4075;
    }

    .dictionary-controls {
      display: grid;
      grid-template-columns: minmax(0, 1fr) auto auto;
      gap: 0.75rem;
      align-items: center;
    }

    .dictionary-scope {
      background: rgba(63, 100, 199, 0.12);
      color: #2a3d82;
      border-radius: 999px;
      padding: 0.45rem 1rem;
      font-weight: 600;
      white-space: nowrap;
    }

    .dictionary-results {
      display: grid;
      gap: 1rem;
      margin-top: 1rem;
    }

    .definition-card {
      border: 1px solid rgba(63, 100, 199, 0.18);
      border-radius: 14px;
      padding: 1rem;
      background: rgba(242, 245, 255, 0.6);
      display: grid;
      gap: 0.8rem;
    }

    .definition-card header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.75rem;
    }

    .badge {
      background: rgba(63, 100, 199, 0.15);
      color: #2a3d82;
      border-radius: 999px;
      padding: 0.3rem 0.75rem;
      font-size: 0.8rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.02em;
    }

    .badge.secondary {
      background: rgba(42, 61, 130, 0.1);
      color: #3f64c7;
    }

    .definition-text {
      font-size: 1rem;
    }

    .example-text {
      font-style: italic;
      color: #42507b;
    }

    .status {
      font-size: 0.95rem;
      min-height: 1.5rem;
    }

    .status.success {
      color: #1a8f5b;
    }

    .status.error {
      color: #cc2b3d;
    }

    .split {
      display: grid;
      gap: 1rem;
    }

    @media (max-width: 980px) {
      body {
        padding: 1rem;
      }

      .app {
        grid-template-columns: 1fr;
      }

      .sidebar {
        border-bottom-left-radius: 0;
        border-bottom-right-radius: 0;
      }

      .main {
        padding: 1.5rem;
      }
    }
  </style>
</head>
<body>
  <div class="app">
    <aside class="sidebar">
      <h1>Anki Card Creator</h1>
      <section>
        <label for="anki-username">AnkiWeb Username</label>
        <input type="text" id="anki-username" placeholder="name@example.com" autocomplete="username" />
        <label for="anki-password" style="margin-top: 1rem;">AnkiWeb Password</label>
        <input type="password" id="anki-password" placeholder="••••••••" autocomplete="current-password" />
      </section>

      <section>
        <label for="deck-select">Deck</label>
        <div class="split">
          <select id="deck-select">
            <option value="" disabled selected>Load decks via AnkiConnect</option>
          </select>
          <button id="load-decks">Load Decks</button>
        </div>
      </section>

      <section>
        <label for="model-name">Note Type</label>
        <input type="text" id="model-name" value="Basic" list="model-suggestions" />
        <datalist id="model-suggestions"></datalist>
        <label for="tags" style="margin-top: 1rem;">Tags (comma separated)</label>
        <input type="text" id="tags" placeholder="vocab, dictionary" />
      </section>
    </aside>

    <main class="main">
      <section class="panel" id="dictionary-panel">
        <h2>Dictionary Lookup</h2>
        <div class="dictionary-controls">
          <input type="text" id="lookup-term" placeholder="Search term" />
          <div class="dictionary-scope" aria-live="polite">All dictionaries</div>
          <button id="search-dictionary">Search</button>
        </div>
        <div class="dictionary-results" id="dictionary-results"></div>
      </section>

      <section class="panel" id="note-panel">
        <h2>Customize Card</h2>
        <div class="split" style="grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));">
          <div>
            <label for="front-field">Front</label>
            <textarea id="front-field" placeholder="Front of the card"></textarea>
          </div>
          <div>
            <label for="back-field">Back</label>
            <textarea id="back-field" placeholder="Back of the card"></textarea>
          </div>
        </div>
        <div class="split" style="margin-top: 1.5rem;">
          <label for="example-field">Example Sentence (optional)</label>
          <textarea id="example-field" placeholder="Add your own or pick one from the dictionary results"></textarea>
        </div>
        <div style="margin-top: 1.5rem; display: flex; gap: 1rem; align-items: center;">
          <button id="add-card">Add Card to Deck</button>
          <span class="status" id="status"></span>
        </div>
      </section>

      <section class="panel" id="preview-panel">
        <h2>Preview</h2>
        <p><strong>Deck:</strong> <span id="preview-deck">—</span></p>
        <p><strong>Note Type:</strong> <span id="preview-model">Basic</span></p>
        <p><strong>Tags:</strong> <span id="preview-tags">—</span></p>
        <article style="margin-top: 1rem; padding: 1rem; border-radius: 12px; background: rgba(63, 100, 199, 0.08);">
          <h3 style="margin-top: 0;">Front</h3>
          <p id="preview-front" style="white-space: pre-wrap;"></p>
          <h3>Back</h3>
          <p id="preview-back" style="white-space: pre-wrap;"></p>
          <h3>Example</h3>
          <p id="preview-example" style="white-space: pre-wrap;"></p>
        </article>
      </section>
    </main>
  </div>

  <script>
    const deckSelect = document.getElementById("deck-select");
    const loadDecksBtn = document.getElementById("load-decks");
    const lookupTermInput = document.getElementById("lookup-term");
    const searchButton = document.getElementById("search-dictionary");
    const dictionaryResults = document.getElementById("dictionary-results");
    const frontField = document.getElementById("front-field");
    const backField = document.getElementById("back-field");
    const exampleField = document.getElementById("example-field");
    const addCardBtn = document.getElementById("add-card");
    const statusEl = document.getElementById("status");
    const usernameInput = document.getElementById("anki-username");
    const passwordInput = document.getElementById("anki-password");
    const modelNameInput = document.getElementById("model-name");
    const modelSuggestions = document.getElementById("model-suggestions");
    const tagsInput = document.getElementById("tags");

    const previewDeck = document.getElementById("preview-deck");
    const previewModel = document.getElementById("preview-model");
    const previewTags = document.getElementById("preview-tags");
    const previewFront = document.getElementById("preview-front");
    const previewBack = document.getElementById("preview-back");
    const previewExample = document.getElementById("preview-example");

    const SESSION_KEYS = {
      credentials: "anki.session.credentials",
      deck: "anki.session.deck",
    };

    const DEFAULT_MODEL_NAME = "Basic";
    const NOTE_SAMPLE_BATCH_SIZE = 200;
    const NOTE_SAMPLE_BATCH_LIMIT = 5;

    let userModifiedNoteType = false;
    let pendingNoteTypeDeck = "";

    function safeParseJSON(value, fallback = null) {
      if (!value) {
        return fallback;
      }
      try {
        return JSON.parse(value);
      } catch (error) {
        console.warn("Failed to parse session JSON", error);
        return fallback;
      }
    }

    function getSessionItem(key) {
      try {
        return sessionStorage.getItem(key);
      } catch (error) {
        console.warn("Session storage unavailable", error);
        return null;
      }
    }

    function setSessionItem(key, value) {
      try {
        if (value === null || value === undefined) {
          sessionStorage.removeItem(key);
        } else {
          sessionStorage.setItem(key, value);
        }
      } catch (error) {
        console.warn("Failed to persist session value", error);
      }
    }

    function persistCredentials() {
      const username = usernameInput.value.trim();
      const password = passwordInput.value;
      if (!username && !password) {
        setSessionItem(SESSION_KEYS.credentials, null);
        return;
      }

      setSessionItem(
        SESSION_KEYS.credentials,
        JSON.stringify({ username, password })
      );
    }

    function persistDeckSelection() {
      const deck = deckSelect.value;
      if (deck) {
        setSessionItem(SESSION_KEYS.deck, deck);
      } else {
        setSessionItem(SESSION_KEYS.deck, null);
      }
    }

    function setStatus(message, type = "") {
      statusEl.textContent = message;
      statusEl.className = "status" + (type ? " " + type : "");
    }

    const savedCredentials = safeParseJSON(getSessionItem(SESSION_KEYS.credentials), {});
    if (savedCredentials?.username) {
      usernameInput.value = savedCredentials.username;
    }
    if (savedCredentials?.password) {
      passwordInput.value = savedCredentials.password;
    }

    function updatePreview() {
      const deckName = deckSelect.value ? deckSelect.value : "—";
      previewDeck.textContent = deckName;
      previewModel.textContent = modelNameInput.value.trim() || DEFAULT_MODEL_NAME;
      const tags = tagsInput.value.trim();
      previewTags.textContent = tags || "—";
      previewFront.textContent = frontField.value;
      previewBack.textContent = backField.value;
      previewExample.textContent = exampleField.value;
    }

    [frontField, backField, exampleField, tagsInput].forEach((element) => {
      element.addEventListener("input", updatePreview);
      element.addEventListener("change", updatePreview);
    });

    function handleModelNameInput() {
      userModifiedNoteType = true;
      updatePreview();
    }

    modelNameInput.addEventListener("input", handleModelNameInput);
    modelNameInput.addEventListener("change", handleModelNameInput);

    function updateModelSuggestions(noteTypes) {
      if (!modelSuggestions) {
        return;
      }

      modelSuggestions.innerHTML = "";
      noteTypes.forEach((noteType) => {
        if (!noteType) {
          return;
        }
        const option = document.createElement("option");
        option.value = noteType;
        modelSuggestions.appendChild(option);
      });
    }

    deckSelect.addEventListener("change", () => {
      persistDeckSelection();
      userModifiedNoteType = false;
      updatePreview();
      const deckName = deckSelect.value;
      if (deckName) {
        loadNoteTypesForDeck(deckName);
      } else {
        updateModelSuggestions([]);
      }
    });

    usernameInput.addEventListener("input", persistCredentials);
    passwordInput.addEventListener("input", persistCredentials);
    async function callAnkiConnect(action, params = {}) {
      let response;
      try {
        response = await fetch("http://127.0.0.1:8765", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ action, version: 6, params }),
        });
      } catch (networkError) {
        console.error(networkError);
        throw new Error(
          "Unable to reach AnkiConnect. Please ensure Anki is running and the AnkiConnect add-on is installed."
        );
      }

      if (!response.ok) {
        throw new Error(`AnkiConnect request failed: ${response.status}`);
      }

      const data = await response.json();
      if (data.error) {
        throw new Error(data.error);
      }

      return data.result;
    }

    function textContainsTerm(text, term) {
      return text && term && text.toLowerCase().includes(term.toLowerCase());
    }

    function cleanExample(example) {
      if (!example) {
        return "";
      }
      return example
        .replace(/\s+/g, " ")
        .replace(/[\[\]]/g, "")
        .trim();
    }

    function normalizeDefinitions(definitions = []) {
      return definitions
        .map((item) => {
          if (!item) {
            return null;
          }
          const definition = (item.definition || item.meaning || "").toString().trim();
          if (!definition) {
            return null;
          }
          let example = "";
          if (typeof item.example === "string") {
            example = cleanExample(item.example);
          } else if (Array.isArray(item.examples) && item.examples.length) {
            example = cleanExample(item.examples[0]);
          }
          return { definition, example };
        })
        .filter(Boolean);
    }

    function normalizeFreeDictionaryEntries(data, term) {
      if (!Array.isArray(data)) {
        return [];
      }

      return data
        .map((entry) => {
          const phonetic =
            entry.phonetic ||
            (Array.isArray(entry.phonetics)
              ? entry.phonetics.find((p) => p && p.text)?.text || ""
              : "");

          const meanings = Array.isArray(entry.meanings)
            ? entry.meanings
                .map((meaning) => {
                  const definitions = normalizeDefinitions(meaning.definitions);
                  if (!definitions.length) {
                    return null;
                  }
                  return {
                    partOfSpeech: meaning.partOfSpeech || "Definition",
                    definitions,
                  };
                })
                .filter(Boolean)
            : [];

          if (!meanings.length) {
            return null;
          }

          return {
            word: entry.word || term,
            phonetic: phonetic || "",
            source: "Free Dictionary",
            meanings,
          };
        })
        .filter(Boolean);
    }

    async function fetchFreeDictionaryEntries(term) {
      const response = await fetch(
        `https://api.dictionaryapi.dev/api/v2/entries/en/${encodeURIComponent(term)}`
      );

      if (response.status === 404) {
        return [];
      }

      if (!response.ok) {
        throw new Error("Dictionary lookup failed");
      }

      const data = await response.json();
      return normalizeFreeDictionaryEntries(data, term);
    }

    function normalizeWiktionaryEntries(data, term) {
      if (!data || typeof data !== "object") {
        return [];
      }

      const englishEntries = Array.isArray(data.en) ? data.en : [];
      return englishEntries
        .map((entry) => {
          const definitions = normalizeDefinitions(entry.definitions || entry.senses);
          if (!definitions.length) {
            return null;
          }

          return {
            word: entry.word || term,
            phonetic: "",
            source: "Wiktionary",
            meanings: [
              {
                partOfSpeech: entry.partOfSpeech || entry.part_of_speech || "Definition",
                definitions,
              },
            ],
          };
        })
        .filter(Boolean);
    }

    async function fetchWiktionaryEntries(term) {
      const response = await fetch(
        `https://en.wiktionary.org/api/rest_v1/page/definition/${encodeURIComponent(term)}`,
        {
          headers: {
            "Api-User-Agent": "anki-card-creator/1.0 (https://ankiweb.net)",
          },
        }
      );

      if (response.status === 404) {
        return [];
      }

      if (!response.ok) {
        throw new Error("Wiktionary lookup failed");
      }

      const data = await response.json();
      return normalizeWiktionaryEntries(data, term);
    }

    function normalizeUrbanEntries(data, term) {
      const list = Array.isArray(data?.list) ? data.list.slice(0, 10) : [];
      return list
        .map((item, index) => {
          const definitions = normalizeDefinitions([
            {
              definition: item.definition,
              example: item.example,
            },
          ]);

          if (!definitions.length) {
            return null;
          }

          return {
            word: item.word || term,
            phonetic: "",
            source: "Urban Dictionary",
            meanings: [
              {
                partOfSpeech: item.word_type || item.tag || `Entry ${index + 1}`,
                definitions,
              },
            ],
          };
        })
        .filter(Boolean);
    }

    async function fetchUrbanEntries(term) {
      const response = await fetch(
        `https://api.urbandictionary.com/v0/define?term=${encodeURIComponent(term)}`
      );

      if (!response.ok) {
        throw new Error("Urban Dictionary lookup failed");
      }

      const data = await response.json();
      return normalizeUrbanEntries(data, term);
    }

    const dictionaryProviders = {
      freeDictionary: {
        id: "freeDictionary",
        label: "Free Dictionary",
        fetchEntries: fetchFreeDictionaryEntries,
        supportsEmbeddedSearch: true,
      },
      wiktionary: {
        id: "wiktionary",
        label: "Wiktionary",
        fetchEntries: fetchWiktionaryEntries,
        supportsEmbeddedSearch: true,
      },
      urban: {
        id: "urban",
        label: "Urban Dictionary",
        fetchEntries: fetchUrbanEntries,
        supportsEmbeddedSearch: false,
      },
    };

    async function searchWithinEntries(term, providerId) {
      const provider = dictionaryProviders[providerId];
      if (!provider || !provider.supportsEmbeddedSearch) {
        return [];
      }

      const tokens = term
        .split(/\s+/)
        .map((token) => token.trim())
        .filter(Boolean);
      const seenTokens = new Set();
      const aggregated = [];

      for (const token of tokens) {
        const normalizedToken = token.toLowerCase();
        if (seenTokens.has(normalizedToken)) {
          continue;
        }
        seenTokens.add(normalizedToken);

        try {
          const entries = await provider.fetchEntries(token);
          entries.forEach((entry) => {
            const filteredMeanings = entry.meanings
              .map((meaning) => {
                const filteredDefinitions = meaning.definitions.filter(
                  (definition) =>
                    textContainsTerm(definition.definition, term) ||
                    textContainsTerm(definition.example, term)
                );
                if (!filteredDefinitions.length) {
                  return null;
                }

                return {
                  partOfSpeech: meaning.partOfSpeech,
                  definitions: filteredDefinitions,
                };
              })
              .filter(Boolean);

            if (filteredMeanings.length) {
              aggregated.push({
                ...entry,
                meanings: filteredMeanings,
                note: `Matches found inside entry for "${token}"`,
              });
            }
          });
        } catch (error) {
          console.warn(`Embedded search failed for token "${token}"`, error);
        }
      }

      return aggregated;
    }

    function escapeRegExp(value) {
      if (value === null || value === undefined) {
        return "";
      }

      return String(value).replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }

    function escapeDeckNameForQuery(deckName) {
      if (!deckName) {
        return "";
      }

      return deckName.replace(/\\/g, "\\\\").replace(/"/g, '\\"');
    }

    function createMaskFromMatch(match) {
      if (!match) {
        return match;
      }

      const characters = Array.from(match);
      const masked = [];
      let preservedCount = 0;
      const maskableCharacters = characters.filter((char) => !/\s/.test(char));
      const keep = maskableCharacters.length >= 6 ? 2 : 1;

      characters.forEach((char) => {
        if (/\s/.test(char)) {
          masked.push(char);
        } else if (preservedCount < keep) {
          masked.push(char);
          preservedCount += 1;
        } else {
          masked.push("•");
        }
      });

      return masked.join("");
    }

    function maskTargetInText(text, target) {
      if (!text || !target) {
        return text;
      }

      const escaped = escapeRegExp(target.trim());
      if (!escaped) {
        return text;
      }

      const pattern = new RegExp(escaped, "gi");
      return text.replace(pattern, (match) => createMaskFromMatch(match));
    }

    async function loadNoteTypesForDeck(deckName) {
      if (!deckName) {
        pendingNoteTypeDeck = "";
        updateModelSuggestions([]);
        return;
      }

      pendingNoteTypeDeck = deckName;

      try {
        const sanitizedDeckName = escapeDeckNameForQuery(deckName);
        const noteIds = await callAnkiConnect("findNotes", {
          query: `deck:"${sanitizedDeckName}"`,
        });

        if (pendingNoteTypeDeck !== deckName) {
          return;
        }

        const noteTypeSet = new Set();

        if (Array.isArray(noteIds) && noteIds.length) {
          const batchLimit = Math.max(1, NOTE_SAMPLE_BATCH_LIMIT);
          for (
            let index = 0;
            index < noteIds.length && index / NOTE_SAMPLE_BATCH_SIZE < batchLimit;
            index += NOTE_SAMPLE_BATCH_SIZE
          ) {
            const batch = noteIds.slice(index, index + NOTE_SAMPLE_BATCH_SIZE);
            if (!batch.length) {
              continue;
            }

            const notesInfo = await callAnkiConnect("notesInfo", { notes: batch });

            if (pendingNoteTypeDeck !== deckName) {
              return;
            }

            if (Array.isArray(notesInfo)) {
              notesInfo.forEach((note) => {
                if (note && note.modelName) {
                  noteTypeSet.add(note.modelName);
                }
              });
            }

            if (batch.length < NOTE_SAMPLE_BATCH_SIZE) {
              break;
            }
          }
        }

        if (pendingNoteTypeDeck !== deckName) {
          return;
        }

        let noteTypes = Array.from(noteTypeSet).sort((a, b) => a.localeCompare(b));
        let statusMessage = "";

        if (!noteTypes.length) {
          const allModelNames = await callAnkiConnect("modelNames");

          if (pendingNoteTypeDeck !== deckName) {
            return;
          }

          if (Array.isArray(allModelNames)) {
            allModelNames.forEach((name) => {
              if (name) {
                noteTypeSet.add(name);
              }
            });
          }

          noteTypes = Array.from(noteTypeSet).sort((a, b) => a.localeCompare(b));

          if (!noteTypes.length) {
            throw new Error("No note types available.");
          }

          statusMessage = `No existing notes found in "${deckName}". Showing all note types.`;
        } else {
          statusMessage = `Loaded ${noteTypes.length} note type${
            noteTypes.length === 1 ? "" : "s"
          } from "${deckName}".`;
        }

        if (pendingNoteTypeDeck !== deckName) {
          return;
        }

        updateModelSuggestions(noteTypes);

        const currentModelName = modelNameInput.value.trim();
        if (!userModifiedNoteType || !noteTypes.includes(currentModelName)) {
          const preferredModelName = noteTypes.includes(DEFAULT_MODEL_NAME)
            ? DEFAULT_MODEL_NAME
            : noteTypes[0] || currentModelName;

          if (preferredModelName && preferredModelName !== currentModelName) {
            modelNameInput.value = preferredModelName;
            updatePreview();
          }

          userModifiedNoteType = false;
        }

        setStatus(statusMessage, "success");
      } catch (error) {
        if (pendingNoteTypeDeck !== deckName) {
          return;
        }

        console.error(error);
        updateModelSuggestions([]);
        setStatus(error.message || "Failed to load note types", "error");
      }
    }

    async function loadDecks() {
      setStatus("Loading decks…");
      loadDecksBtn.disabled = true;
      try {
        const deckNames = await callAnkiConnect("deckNames");
        deckSelect.innerHTML = "";
        if (!deckNames.length) {
          const option = document.createElement("option");
          option.textContent = "No decks found";
          option.disabled = true;
          option.selected = true;
          deckSelect.appendChild(option);
        } else {
          const placeholder = document.createElement("option");
          placeholder.textContent = "Choose a deck";
          placeholder.disabled = true;
          placeholder.selected = true;
          placeholder.value = "";
          deckSelect.appendChild(placeholder);
          for (const deck of deckNames) {
            const option = document.createElement("option");
            option.value = deck;
            option.textContent = deck;
            deckSelect.appendChild(option);
          }
          const savedDeck = getSessionItem(SESSION_KEYS.deck);
          if (savedDeck && deckNames.includes(savedDeck)) {
            deckSelect.value = savedDeck;
            persistDeckSelection();
            await loadNoteTypesForDeck(savedDeck);
            updatePreview();
            return;
          }
        }
        updateModelSuggestions([]);
        setStatus("Decks loaded", "success");
        updatePreview();
      } catch (error) {
        console.error(error);
        setStatus(error.message || "Failed to load decks", "error");
      } finally {
        loadDecksBtn.disabled = false;
      }
    }

    function buildDefinitionCard(entry, meaning, definitionIndex) {
      const card = document.createElement("div");
      card.className = "definition-card";

      if (entry.word) {
        const headword = document.createElement("h3");
        headword.style.margin = "0 0 0.35rem 0";
        headword.style.fontSize = "1.05rem";
        headword.textContent = entry.word;
        card.appendChild(headword);
      }

      const header = document.createElement("header");
      const badgeGroup = document.createElement("div");
      badgeGroup.style.display = "flex";
      badgeGroup.style.flexWrap = "wrap";
      badgeGroup.style.gap = "0.4rem";
      badgeGroup.style.alignItems = "center";
      if (entry.source) {
        const sourceBadge = document.createElement("span");
        sourceBadge.className = "badge secondary";
        sourceBadge.textContent = entry.source;
        badgeGroup.appendChild(sourceBadge);
      }
      const partOfSpeech = document.createElement("span");
      partOfSpeech.className = "badge";
      partOfSpeech.textContent = meaning.partOfSpeech || "Definition";
      badgeGroup.appendChild(partOfSpeech);
      const button = document.createElement("button");
      button.textContent = "Use this meaning";
      button.addEventListener("click", () => {
        const definitionText = meaning.definitions[definitionIndex]?.definition || "";
        const exampleText = meaning.definitions[definitionIndex]?.example || "";
        const lookupTerm = lookupTermInput.value.trim();
        frontField.value = lookupTerm;
        const maskedDefinition = maskTargetInText(definitionText, lookupTerm);
        backField.value = maskedDefinition;
        if (exampleText) {
          exampleField.value = maskTargetInText(exampleText, lookupTerm);
        }
        updatePreview();
        const sourceLabel = entry.source ? ` (${entry.source})` : "";
        setStatus(`Definition inserted into the card editor${sourceLabel}`, "success");
      });
      header.appendChild(badgeGroup);
      header.appendChild(button);
      card.appendChild(header);

      if (entry.note) {
        const note = document.createElement("p");
        note.style.margin = "0";
        note.style.fontSize = "0.85rem";
        note.style.color = "#4a5781";
        note.textContent = entry.note;
        card.appendChild(note);
      }

      const definitionText = document.createElement("p");
      definitionText.className = "definition-text";
      definitionText.textContent = meaning.definitions[definitionIndex]?.definition || "";
      card.appendChild(definitionText);

      const example = meaning.definitions[definitionIndex]?.example;
      if (example) {
        const examplePara = document.createElement("p");
        examplePara.className = "example-text";
        examplePara.textContent = example;
        const exampleButton = document.createElement("button");
        exampleButton.textContent = "Use this example";
        exampleButton.addEventListener("click", () => {
          const lookupTerm = lookupTermInput.value.trim();
          exampleField.value = maskTargetInText(example, lookupTerm);
          updatePreview();
          setStatus("Example added to the card", "success");
        });

        const exampleWrapper = document.createElement("div");
        exampleWrapper.style.display = "grid";
        exampleWrapper.style.gap = "0.6rem";
        exampleWrapper.appendChild(examplePara);
        exampleWrapper.appendChild(exampleButton);
        card.appendChild(exampleWrapper);
      }

      if (entry.phonetic) {
        const phonetic = document.createElement("p");
        phonetic.style.margin = "0";
        phonetic.innerHTML = `<strong>Phonetic:</strong> ${entry.phonetic}`;
        card.appendChild(phonetic);
      }

      return card;
    }

    function renderDictionaryResults(entries) {
      dictionaryResults.innerHTML = "";
      if (!entries || !entries.length) {
        dictionaryResults.textContent = "No results found.";
        return;
      }

      entries.forEach((entry) => {
        entry.meanings.forEach((meaning) => {
          meaning.definitions.forEach((_def, index) => {
            dictionaryResults.appendChild(buildDefinitionCard(entry, meaning, index));
          });
        });
      });
    }

    async function searchDictionary() {
      const term = lookupTermInput.value.trim();
      if (!term) {
        setStatus("Type a term to search", "error");
        return;
      }

      setStatus(`Searching all dictionaries for "${term}"…`);
      searchButton.disabled = true;
      dictionaryResults.textContent = "Searching…";

      const uniqueEntryKeys = new Set();
      const collectedEntries = [];
      const contributingProviders = new Set();
      let embeddedMatchCount = 0;

      const addEntries = (entries, providerLabel = "") => {
        if (!Array.isArray(entries)) {
          return;
        }

        entries.forEach((entry) => {
          if (!entry || !Array.isArray(entry.meanings) || !entry.meanings.length) {
            return;
          }

          const key = JSON.stringify({
            source: entry.source || "",
            word: entry.word || "",
            meanings: entry.meanings.map((meaning) => ({
              partOfSpeech: meaning.partOfSpeech || "",
              definitions: (meaning.definitions || []).map((definition) => ({
                definition: definition.definition || "",
                example: definition.example || "",
              })),
            })),
          });

          if (!uniqueEntryKeys.has(key)) {
            uniqueEntryKeys.add(key);
            collectedEntries.push(entry);
            const contributorLabel = entry.source || providerLabel;
            if (contributorLabel) {
              contributingProviders.add(contributorLabel);
            }
          }
        });
      };

      try {
        const providerIds = Object.keys(dictionaryProviders);
        const providerResponses = await Promise.all(
          providerIds.map(async (providerId) => {
            const provider = dictionaryProviders[providerId];
            if (!provider) {
              return { providerId, entries: [], embeddedCount: 0 };
            }

            const providerEntries = [];
            let providerEmbeddedCount = 0;
            const providerLabel = provider.label || providerId;

            try {
              const directEntries = await provider.fetchEntries(term);
              if (Array.isArray(directEntries)) {
                providerEntries.push(...directEntries);
              }
            } catch (error) {
              console.warn(`Lookup failed for ${providerLabel}`, error);
            }

            try {
              const embeddedEntries = await searchWithinEntries(term, providerId);
              providerEmbeddedCount += embeddedEntries.length;
              if (Array.isArray(embeddedEntries)) {
                providerEntries.push(...embeddedEntries);
              }
            } catch (embeddedError) {
              console.warn(`Embedded search failed for ${providerLabel}`, embeddedError);
            }

            return { providerId, entries: providerEntries, embeddedCount: providerEmbeddedCount };
          })
        );

        providerResponses.forEach(({ providerId, entries, embeddedCount }) => {
          embeddedMatchCount += embeddedCount;
          const providerLabel = dictionaryProviders[providerId]?.label || providerId;
          addEntries(entries, providerLabel);
        });

        if (!collectedEntries.length) {
          renderDictionaryResults([]);
          setStatus("No entries available.", "error");
          return;
        }

        renderDictionaryResults(collectedEntries);
        const providerCount = contributingProviders.size;
        const totalProviders = providerIds.length;
        const providerList = Array.from(contributingProviders);
        let providerSummary;
        if (providerCount === totalProviders && providerCount > 0) {
          providerSummary = "all dictionaries";
        } else if (providerCount === 1) {
          providerSummary = providerList[0];
        } else if (providerCount > 1) {
          providerSummary = `${providerCount} dictionaries (${providerList.join(", ")})`;
        } else {
          providerSummary = "the available dictionaries";
        }

        const embeddedNote = embeddedMatchCount
          ? ` including ${embeddedMatchCount} embedded match${embeddedMatchCount === 1 ? "" : "es"}`
          : "";
        setStatus(`Dictionary results loaded from ${providerSummary}${embeddedNote}.`, "success");
      } catch (error) {
        console.error(error);
        dictionaryResults.textContent = "No entries available.";
        setStatus(error.message || "Failed to fetch dictionary results", "error");
      } finally {
        searchButton.disabled = false;
      }
    }

    async function addCard() {
      const deckName = deckSelect.value;
      const modelName = modelNameInput.value.trim() || DEFAULT_MODEL_NAME;
      const front = frontField.value.trim();
      const back = backField.value.trim();

      if (!deckName) {
        setStatus("Please choose a deck", "error");
        return;
      }

      if (!front || !back) {
        setStatus("Front and back cannot be empty", "error");
        return;
      }

      setStatus("Adding card to deck…");
      addCardBtn.disabled = true;

      const example = exampleField.value.trim();
      const tags = tagsInput.value
        .split(",")
        .map((tag) => tag.trim())
        .filter(Boolean);

      const fields = {
        Front: front,
        Back: example ? `${back}\n\n<em>${example}</em>` : back,
      };

      try {
        await callAnkiConnect("addNote", {
          note: {
            deckName,
            modelName,
            fields,
            tags,
          },
        });

        try {
          await callAnkiConnect("sync");
          setStatus(
            "Card added and sync requested using Anki's saved session.",
            "success"
          );
        } catch (syncError) {
          console.warn("Sync failed", syncError);
          setStatus(
            `Card added but sync failed via saved session: ${syncError.message}`,
            "error"
          );
        }
      } catch (error) {
        console.error(error);
        setStatus(error.message || "Failed to add card", "error");
      } finally {
        addCardBtn.disabled = false;
      }
    }

    const initialDeckSelection = getSessionItem(SESSION_KEYS.deck);
    if (initialDeckSelection) {
      loadDecks();
    }

    loadDecksBtn.addEventListener("click", loadDecks);
    searchButton.addEventListener("click", searchDictionary);
    lookupTermInput.addEventListener("keydown", (event) => {
      if (event.key === "Enter") {
        event.preventDefault();
        searchDictionary();
      }
    });
    addCardBtn.addEventListener("click", addCard);

    updatePreview();
  </script>
</body>
</html>

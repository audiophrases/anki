<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Anki Card Creator</title>
  <style>
    :root {
      color-scheme: light dark;
      font-family: "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      line-height: 1.5;
      font-size: 16px;
    }

    body {
      margin: 0;
      padding: 0;
      background: radial-gradient(circle at top left, #f7f8ff, #eaeefd 40%, #e0e0f5);
      min-height: 100vh;
      color: #1e2a44;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      padding: 2rem;
      box-sizing: border-box;
    }

    .app {
      background: rgba(255, 255, 255, 0.92);
      box-shadow: 0 20px 60px rgba(58, 75, 115, 0.25);
      border-radius: 20px;
      max-width: 1100px;
      width: 100%;
      display: grid;
      grid-template-columns: 340px 1fr;
      overflow: hidden;
    }

    .sidebar {
      padding: 2rem;
      background: linear-gradient(180deg, #3f64c7, #4650ac);
      color: white;
    }

    .sidebar h1 {
      margin-top: 0;
      margin-bottom: 1.5rem;
      font-size: 1.9rem;
      letter-spacing: 0.02em;
    }

    .sidebar section + section {
      margin-top: 2.5rem;
    }

    label {
      font-weight: 600;
      display: block;
      margin-bottom: 0.5rem;
    }

    input[type="text"],
    input[type="password"],
    textarea,
    select {
      width: 100%;
      border: 1px solid rgba(30, 42, 68, 0.2);
      border-radius: 10px;
      padding: 0.7rem 0.85rem;
      font-size: 1rem;
      font-family: inherit;
      box-sizing: border-box;
      background: rgba(255, 255, 255, 0.95);
      color: #1e2a44;
    }

    textarea {
      min-height: 120px;
      resize: vertical;
    }

    button {
      background: #3f64c7;
      border: none;
      border-radius: 999px;
      padding: 0.65rem 1.35rem;
      font-size: 0.95rem;
      font-weight: 600;
      color: white;
      cursor: pointer;
      transition: transform 0.15s ease, box-shadow 0.15s ease;
      box-shadow: 0 10px 30px rgba(63, 100, 199, 0.3);
    }

    button:hover {
      transform: translateY(-1px);
      box-shadow: 0 12px 32px rgba(63, 100, 199, 0.4);
    }

    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      box-shadow: none;
      transform: none;
    }

    .main {
      padding: 2rem 2.5rem;
      background: rgba(249, 250, 255, 0.9);
      display: flex;
      flex-direction: column;
      gap: 2rem;
    }

    .panel {
      background: white;
      border-radius: 16px;
      padding: 1.5rem;
      box-shadow: 0 10px 30px rgba(43, 58, 92, 0.1);
    }

    .setup-notice {
      border: 1px solid rgba(63, 100, 199, 0.18);
      background: linear-gradient(
        135deg,
        rgba(63, 100, 199, 0.14),
        rgba(70, 80, 172, 0.04)
      );
      display: grid;
      gap: 0.75rem;
    }

    .setup-notice.is-hidden {
      display: none;
    }

    .setup-steps {
      margin: 0;
      padding-left: 1.2rem;
      color: #2f4075;
    }

    .setup-steps li + li {
      margin-top: 0.4rem;
    }

    .setup-snippet {
      background: rgba(63, 100, 199, 0.12);
      border-radius: 12px;
      padding: 0.9rem 1rem;
      font-family: "Fira Code", "SFMono-Regular", Menlo, Monaco, Consolas,
        "Liberation Mono", "Courier New", monospace;
      font-size: 0.9rem;
      color: #1f2b4a;
      overflow-x: auto;
    }

    .setup-snippet pre {
      margin: 0;
      white-space: pre;
    }

    .setup-footnote {
      margin: 0;
      font-size: 0.85rem;
      color: #3f4d7a;
    }

    .panel h2 {
      margin-top: 0;
      font-size: 1.35rem;
      color: #2f4075;
    }

    .dictionary-controls {
      display: grid;
      grid-template-columns: minmax(0, 1fr) auto auto;
      gap: 0.75rem;
      align-items: center;
    }

    .dictionary-scope {
      background: rgba(63, 100, 199, 0.12);
      color: #2a3d82;
      border-radius: 999px;
      padding: 0.45rem 1rem;
      font-weight: 600;
      white-space: nowrap;
    }

    .dictionary-results {
      display: grid;
      gap: 1rem;
      margin-top: 1rem;
    }

    .definition-card {
      border: 1px solid rgba(63, 100, 199, 0.18);
      border-radius: 14px;
      padding: 1rem;
      background: rgba(242, 245, 255, 0.6);
      display: grid;
      gap: 0.8rem;
    }

    .definition-card header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.75rem;
    }

    .badge {
      background: rgba(63, 100, 199, 0.15);
      color: #2a3d82;
      border-radius: 999px;
      padding: 0.3rem 0.75rem;
      font-size: 0.8rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.02em;
    }

    .badge.secondary {
      background: rgba(42, 61, 130, 0.1);
      color: #3f64c7;
    }

    .definition-text {
      font-size: 1rem;
    }

    .example-text {
      font-style: italic;
      color: #42507b;
    }

    .status {
      font-size: 0.95rem;
      min-height: 1.5rem;
    }

    .status.success {
      color: #1a8f5b;
    }

    .status.error {
      color: #cc2b3d;
    }

    .split {
      display: grid;
      gap: 1rem;
    }

    @media (max-width: 980px) {
      body {
        padding: 1rem;
      }

      .app {
        grid-template-columns: 1fr;
      }

      .sidebar {
        border-bottom-left-radius: 0;
        border-bottom-right-radius: 0;
      }

      .main {
        padding: 1.5rem;
      }
    }
  </style>
</head>
<body>
  <div class="app">
    <aside class="sidebar">
      <h1>Anki Card Creator</h1>
      <section>
        <label for="anki-username">AnkiWeb Username</label>
        <input type="text" id="anki-username" placeholder="name@example.com" autocomplete="username" />
        <label for="anki-password" style="margin-top: 1rem;">AnkiWeb Password</label>
        <input type="password" id="anki-password" placeholder="••••••••" autocomplete="current-password" />
      </section>

      <section>
        <label for="deck-select">Deck</label>
        <div class="split">
          <select id="deck-select">
            <option value="" disabled selected>Load decks via AnkiConnect</option>
          </select>
          <button id="load-decks">Load Decks</button>
        </div>
      </section>

      <section>
        <label for="model-name">Note Type</label>
        <input type="text" id="model-name" value="Basic" list="model-suggestions" />
        <datalist id="model-suggestions"></datalist>
        <label for="tags" style="margin-top: 1rem;">Tags (comma separated)</label>
        <input type="text" id="tags" placeholder="vocab, dictionary" />
      </section>
    </aside>

    <main class="main">
      <section
        class="panel setup-notice"
        id="setup-notice"
        aria-live="polite"
      >
        <h2>Set up AnkiConnect for GitHub Pages</h2>
        <p style="margin: 0;">
          Allow this page to talk to AnkiConnect so decks and cards can be
          managed from the browser.
        </p>
        <ol class="setup-steps">
          <li>
            In Anki, open <strong>Tools → Add-ons → AnkiConnect → Config</strong>.
          </li>
          <li>
            Add your GitHub Pages URL to the <code>webCorsOriginList</code>
            setting.
          </li>
          <li>Save the configuration and restart Anki if prompted.</li>
        </ol>
        <div class="setup-snippet" role="region" aria-label="Sample AnkiConnect configuration">
          <pre><code>{
  "webCorsOriginList": [
    "https://&lt;your-username&gt;.github.io",
    "https://&lt;your-username&gt;.github.io/anki/"
  ]
}</code></pre>
        </div>
        <p class="setup-footnote">
          This notice hides automatically after AnkiConnect responds
          successfully.
        </p>
        <p class="setup-footnote">
          Ensure your AnkiConnect configuration allows the
          <code>findNotes</code>, <code>notesInfo</code>, and
          <code>updateNoteFields</code> actions so this tool can surface and
          refresh existing cards within your decks.
        </p>
      </section>

      <section class="panel" id="dictionary-panel">
        <h2>Dictionary Lookup</h2>
        <div class="dictionary-controls">
          <input type="text" id="lookup-term" placeholder="Search term" />
          <div class="dictionary-scope" aria-live="polite">All dictionaries</div>
          <button id="search-dictionary">Search</button>
        </div>
        <div class="dictionary-results" id="dictionary-results"></div>
      </section>

      <section class="panel" id="note-panel">
        <h2>Customize Card</h2>
        <div class="split" style="grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));">
          <div>
            <label for="front-field">Front</label>
            <textarea id="front-field" placeholder="Front of the card"></textarea>
          </div>
          <div>
            <label for="back-field">Back</label>
            <textarea id="back-field" placeholder="Back of the card"></textarea>
          </div>
        </div>
        <div class="split" style="margin-top: 1.5rem;">
          <label for="example-field">Example Sentence (optional)</label>
          <textarea id="example-field" placeholder="Add your own or pick one from the dictionary results"></textarea>
        </div>
        <div style="margin-top: 1.5rem; display: flex; gap: 1rem; align-items: center;">
          <button id="add-card">Add Card to Deck</button>
          <span class="status" id="status"></span>
        </div>
      </section>

      <section class="panel" id="preview-panel">
        <h2>Preview</h2>
        <p><strong>Deck:</strong> <span id="preview-deck">—</span></p>
        <p><strong>Note Type:</strong> <span id="preview-model">Basic</span></p>
        <p><strong>Tags:</strong> <span id="preview-tags">—</span></p>
        <article style="margin-top: 1rem; padding: 1rem; border-radius: 12px; background: rgba(63, 100, 199, 0.08);">
          <h3 style="margin-top: 0;">Front</h3>
          <p id="preview-front" style="white-space: pre-wrap;"></p>
          <h3>Back</h3>
          <p id="preview-back" style="white-space: pre-wrap;"></p>
          <h3>Example</h3>
          <p id="preview-example" style="white-space: pre-wrap;"></p>
        </article>
      </section>
    </main>
  </div>

  <script>
    const deckSelect = document.getElementById("deck-select");
    const loadDecksBtn = document.getElementById("load-decks");
    const lookupTermInput = document.getElementById("lookup-term");
    const searchButton = document.getElementById("search-dictionary");
    const dictionaryResults = document.getElementById("dictionary-results");
    const frontField = document.getElementById("front-field");
    const backField = document.getElementById("back-field");
    const exampleField = document.getElementById("example-field");
    const addCardBtn = document.getElementById("add-card");
    const statusEl = document.getElementById("status");
    const usernameInput = document.getElementById("anki-username");
    const passwordInput = document.getElementById("anki-password");
    const modelNameInput = document.getElementById("model-name");
    const modelSuggestions = document.getElementById("model-suggestions");
    const tagsInput = document.getElementById("tags");
    const setupNotice = document.getElementById("setup-notice");

    const previewDeck = document.getElementById("preview-deck");
    const previewModel = document.getElementById("preview-model");
    const previewTags = document.getElementById("preview-tags");
    const previewFront = document.getElementById("preview-front");
    const previewBack = document.getElementById("preview-back");
    const previewExample = document.getElementById("preview-example");

    const SESSION_KEYS = {
      credentials: "anki.session.credentials",
      deck: "anki.session.deck",
      setupNoticeDismissed: "anki.session.setupDismissed",
    };

    const DEFAULT_MODEL_NAME = "Basic";
    const NOTE_SAMPLE_BATCH_SIZE = 200;
    const NOTE_SAMPLE_BATCH_LIMIT = 5;
    const NOTE_SEARCH_LIMIT = 25;

    const htmlParser = document.createElement("div");

    let userModifiedNoteType = false;
    let pendingNoteTypeDeck = "";

    function safeParseJSON(value, fallback = null) {
      if (!value) {
        return fallback;
      }
      try {
        return JSON.parse(value);
      } catch (error) {
        console.warn("Failed to parse session JSON", error);
        return fallback;
      }
    }

    function getSessionItem(key) {
      try {
        return sessionStorage.getItem(key);
      } catch (error) {
        console.warn("Session storage unavailable", error);
        return null;
      }
    }

    function setSessionItem(key, value) {
      try {
        if (value === null || value === undefined) {
          sessionStorage.removeItem(key);
        } else {
          sessionStorage.setItem(key, value);
        }
      } catch (error) {
        console.warn("Failed to persist session value", error);
      }
    }

    function persistCredentials() {
      const username = usernameInput.value.trim();
      const password = passwordInput.value;
      if (!username && !password) {
        setSessionItem(SESSION_KEYS.credentials, null);
        return;
      }

      setSessionItem(
        SESSION_KEYS.credentials,
        JSON.stringify({ username, password })
      );
    }

    function persistDeckSelection() {
      const deck = deckSelect.value;
      if (deck) {
        setSessionItem(SESSION_KEYS.deck, deck);
      } else {
        setSessionItem(SESSION_KEYS.deck, null);
      }
    }

    function setStatus(message, type = "") {
      statusEl.textContent = message;
      statusEl.className = "status" + (type ? " " + type : "");
    }

    function hideSetupNotice() {
      if (setupNotice) {
        setupNotice.classList.add("is-hidden");
      }
    }

    function showSetupNotice() {
      if (setupNotice) {
        setupNotice.classList.remove("is-hidden");
      }
    }

    let hasSuccessfulAnkiConnect =
      getSessionItem(SESSION_KEYS.setupNoticeDismissed) === "true";

    if (hasSuccessfulAnkiConnect) {
      hideSetupNotice();
    } else {
      showSetupNotice();
    }

    function markAnkiConnectSuccess() {
      if (hasSuccessfulAnkiConnect) {
        return;
      }
      hasSuccessfulAnkiConnect = true;
      hideSetupNotice();
      setSessionItem(SESSION_KEYS.setupNoticeDismissed, "true");
    }

    const savedCredentials = safeParseJSON(getSessionItem(SESSION_KEYS.credentials), {});
    if (savedCredentials?.username) {
      usernameInput.value = savedCredentials.username;
    }
    if (savedCredentials?.password) {
      passwordInput.value = savedCredentials.password;
    }

    function updatePreview() {
      const deckName = deckSelect.value ? deckSelect.value : "—";
      previewDeck.textContent = deckName;
      previewModel.textContent = modelNameInput.value.trim() || DEFAULT_MODEL_NAME;
      const tags = tagsInput.value.trim();
      previewTags.textContent = tags || "—";
      previewFront.textContent = frontField.value;
      previewBack.textContent = backField.value;
      previewExample.textContent = exampleField.value;
    }

    [frontField, backField, exampleField, tagsInput].forEach((element) => {
      element.addEventListener("input", updatePreview);
      element.addEventListener("change", updatePreview);
    });

    function handleModelNameInput() {
      userModifiedNoteType = true;
      updatePreview();
    }

    modelNameInput.addEventListener("input", handleModelNameInput);
    modelNameInput.addEventListener("change", handleModelNameInput);

    function updateModelSuggestions(noteTypes) {
      if (!modelSuggestions) {
        return;
      }

      modelSuggestions.innerHTML = "";
      noteTypes.forEach((noteType) => {
        if (!noteType) {
          return;
        }
        const option = document.createElement("option");
        option.value = noteType;
        modelSuggestions.appendChild(option);
      });
    }

    deckSelect.addEventListener("change", () => {
      persistDeckSelection();
      userModifiedNoteType = false;
      updatePreview();
      const deckName = deckSelect.value;
      if (deckName) {
        loadNoteTypesForDeck(deckName);
      } else {
        updateModelSuggestions([]);
      }
    });

    usernameInput.addEventListener("input", persistCredentials);
    passwordInput.addEventListener("input", persistCredentials);
    async function callAnkiConnect(action, params = {}) {
      let response;
      try {
        response = await fetch("http://127.0.0.1:8765", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ action, version: 6, params }),
        });
      } catch (networkError) {
        console.error(networkError);
        throw new Error(
          "Unable to reach AnkiConnect. Please ensure Anki is running and the AnkiConnect add-on is installed."
        );
      }

      if (!response.ok) {
        throw new Error(`AnkiConnect request failed: ${response.status}`);
      }

      const data = await response.json();
      if (data.error) {
        throw new Error(data.error);
      }

      markAnkiConnectSuccess();

      return data.result;
    }

    function textContainsTerm(text, term) {
      return text && term && text.toLowerCase().includes(term.toLowerCase());
    }

    function cleanExample(example) {
      if (!example) {
        return "";
      }
      return example
        .replace(/\s+/g, " ")
        .replace(/[\[\]]/g, "")
        .trim();
    }

    function normalizeDefinitions(definitions = []) {
      return definitions
        .map((item) => {
          if (!item) {
            return null;
          }
          const definition = (item.definition || item.meaning || "").toString().trim();
          if (!definition) {
            return null;
          }
          let example = "";
          if (typeof item.example === "string") {
            example = cleanExample(item.example);
          } else if (Array.isArray(item.examples) && item.examples.length) {
            example = cleanExample(item.examples[0]);
          }
          return { definition, example };
        })
        .filter(Boolean);
    }

    function normalizeFreeDictionaryEntries(data, term) {
      if (!Array.isArray(data)) {
        return [];
      }

      return data
        .map((entry) => {
          const phonetic =
            entry.phonetic ||
            (Array.isArray(entry.phonetics)
              ? entry.phonetics.find((p) => p && p.text)?.text || ""
              : "");

          const meanings = Array.isArray(entry.meanings)
            ? entry.meanings
                .map((meaning) => {
                  const definitions = normalizeDefinitions(meaning.definitions);
                  if (!definitions.length) {
                    return null;
                  }
                  return {
                    partOfSpeech: meaning.partOfSpeech || "Definition",
                    definitions,
                  };
                })
                .filter(Boolean)
            : [];

          if (!meanings.length) {
            return null;
          }

          return {
            word: entry.word || term,
            phonetic: phonetic || "",
            source: "Free Dictionary",
            meanings,
          };
        })
        .filter(Boolean);
    }

    async function fetchFreeDictionaryEntries(term) {
      const response = await fetch(
        `https://api.dictionaryapi.dev/api/v2/entries/en/${encodeURIComponent(term)}`
      );

      if (response.status === 404) {
        return [];
      }

      if (!response.ok) {
        throw new Error("Dictionary lookup failed");
      }

      const data = await response.json();
      return normalizeFreeDictionaryEntries(data, term);
    }

    function normalizeWiktionaryEntries(data, term) {
      if (!data || typeof data !== "object") {
        return [];
      }

      const englishEntries = Array.isArray(data.en) ? data.en : [];
      return englishEntries
        .map((entry) => {
          const definitions = normalizeDefinitions(entry.definitions || entry.senses);
          if (!definitions.length) {
            return null;
          }

          return {
            word: entry.word || term,
            phonetic: "",
            source: "Wiktionary",
            meanings: [
              {
                partOfSpeech: entry.partOfSpeech || entry.part_of_speech || "Definition",
                definitions,
              },
            ],
          };
        })
        .filter(Boolean);
    }

    async function fetchWiktionaryEntries(term) {
      const response = await fetch(
        `https://en.wiktionary.org/api/rest_v1/page/definition/${encodeURIComponent(term)}`,
        {
          headers: {
            "Api-User-Agent": "anki-card-creator/1.0 (https://ankiweb.net)",
          },
        }
      );

      if (response.status === 404) {
        return [];
      }

      if (!response.ok) {
        throw new Error("Wiktionary lookup failed");
      }

      const data = await response.json();
      return normalizeWiktionaryEntries(data, term);
    }

    function normalizeUrbanEntries(data, term) {
      const list = Array.isArray(data?.list) ? data.list.slice(0, 10) : [];
      return list
        .map((item, index) => {
          const definitions = normalizeDefinitions([
            {
              definition: item.definition,
              example: item.example,
            },
          ]);

          if (!definitions.length) {
            return null;
          }

          return {
            word: item.word || term,
            phonetic: "",
            source: "Urban Dictionary",
            meanings: [
              {
                partOfSpeech: item.word_type || item.tag || `Entry ${index + 1}`,
                definitions,
              },
            ],
          };
        })
        .filter(Boolean);
    }

    async function fetchUrbanEntries(term) {
      const response = await fetch(
        `https://api.urbandictionary.com/v0/define?term=${encodeURIComponent(term)}`
      );

      if (!response.ok) {
        throw new Error("Urban Dictionary lookup failed");
      }

      const data = await response.json();
      return normalizeUrbanEntries(data, term);
    }

    const dictionaryProviders = {
      freeDictionary: {
        id: "freeDictionary",
        label: "Free Dictionary",
        fetchEntries: fetchFreeDictionaryEntries,
        supportsEmbeddedSearch: true,
      },
      wiktionary: {
        id: "wiktionary",
        label: "Wiktionary",
        fetchEntries: fetchWiktionaryEntries,
        supportsEmbeddedSearch: true,
      },
      urban: {
        id: "urban",
        label: "Urban Dictionary",
        fetchEntries: fetchUrbanEntries,
        supportsEmbeddedSearch: false,
      },
    };

    async function searchWithinEntries(term, providerId) {
      const provider = dictionaryProviders[providerId];
      if (!provider || !provider.supportsEmbeddedSearch) {
        return [];
      }

      const tokens = term
        .split(/\s+/)
        .map((token) => token.trim())
        .filter(Boolean);
      const seenTokens = new Set();
      const aggregated = [];

      for (const token of tokens) {
        const normalizedToken = token.toLowerCase();
        if (seenTokens.has(normalizedToken)) {
          continue;
        }
        seenTokens.add(normalizedToken);

        try {
          const entries = await provider.fetchEntries(token);
          entries.forEach((entry) => {
            const filteredMeanings = entry.meanings
              .map((meaning) => {
                const filteredDefinitions = meaning.definitions.filter(
                  (definition) =>
                    textContainsTerm(definition.definition, term) ||
                    textContainsTerm(definition.example, term)
                );
                if (!filteredDefinitions.length) {
                  return null;
                }

                return {
                  partOfSpeech: meaning.partOfSpeech,
                  definitions: filteredDefinitions,
                };
              })
              .filter(Boolean);

            if (filteredMeanings.length) {
              aggregated.push({
                ...entry,
                meanings: filteredMeanings,
                note: `Matches found inside entry for "${token}"`,
              });
            }
          });
        } catch (error) {
          console.warn(`Embedded search failed for token "${token}"`, error);
        }
      }

      return aggregated;
    }

    function escapeRegExp(value) {
      if (value === null || value === undefined) {
        return "";
      }

      return String(value).replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }

    function escapeDeckNameForQuery(deckName) {
      if (!deckName) {
        return "";
      }

      return deckName.replace(/\\/g, "\\\\").replace(/"/g, '\\"');
    }

    function escapeSearchTerm(term) {
      if (!term) {
        return "";
      }

      return term.replace(/"/g, '\\"').trim();
    }

    function stripHtml(value) {
      if (!value) {
        return "";
      }

      htmlParser.innerHTML = value;
      const text = htmlParser.textContent || htmlParser.innerText || "";
      htmlParser.textContent = "";
      return text.trim();
    }

    function selectFieldEntry(fieldEntries, preferredNames = [], fallbackIndex = 0) {
      const normalizedPreferences = preferredNames.map((name) => name.toLowerCase());
      for (const [fieldName, payload] of fieldEntries) {
        if (normalizedPreferences.includes(fieldName.toLowerCase())) {
          return [fieldName, payload];
        }
      }

      return fieldEntries[fallbackIndex] || null;
    }

    function createNoteDetails(note, deckName) {
      if (!note || !note.noteId || !note.fields) {
        return null;
      }

      const fieldEntries = Object.entries(note.fields);
      if (!fieldEntries.length) {
        return null;
      }

      const frontEntry =
        selectFieldEntry(fieldEntries, ["front"]) || selectFieldEntry(fieldEntries, [], 0);
      const backEntry =
        selectFieldEntry(fieldEntries, ["back"], 1) || selectFieldEntry(fieldEntries, [], 0);
      const exampleEntry = selectFieldEntry(fieldEntries, ["example"]);

      const getValue = (entry) =>
        entry && entry[1] && typeof entry[1].value === "string" ? entry[1].value : "";

      const frontHtml = getValue(frontEntry);
      const backHtml = getValue(backEntry);
      const exampleHtml = getValue(exampleEntry);

      return {
        id: note.noteId,
        deckName,
        modelName: note.modelName || "",
        tags: Array.isArray(note.tags) ? note.tags : [],
        fieldMap: {
          front: frontEntry ? frontEntry[0] : null,
          back: backEntry ? backEntry[0] : null,
          example: exampleEntry ? exampleEntry[0] : null,
        },
        fields: {
          frontHtml,
          backHtml,
          exampleHtml,
        },
        display: {
          frontText: stripHtml(frontHtml),
          backText: stripHtml(backHtml),
          exampleText: stripHtml(exampleHtml),
        },
      };
    }

    function mapDeckNotesToEntries(notesInfo, deckName, term) {
      if (!Array.isArray(notesInfo)) {
        return [];
      }

      return notesInfo
        .map((note) => {
          const noteDetails = createNoteDetails(note, deckName);
          if (!noteDetails) {
            return null;
          }

          const definitionText = noteDetails.display.backText || "(Back field is empty)";

          return {
            uniqueKey: `note-${noteDetails.id}`,
            word: noteDetails.display.frontText || term,
            source: deckName,
            deckName,
            isExistingNote: true,
            noteDetails,
            meanings: [
              {
                partOfSpeech: noteDetails.modelName || "Card content",
                definitions: [
                  {
                    definition: definitionText,
                    example: noteDetails.display.exampleText || "",
                  },
                ],
              },
            ],
            note: `Saved note #${noteDetails.id} in "${deckName}"`,
          };
        })
        .filter(Boolean);
    }

    async function findDeckEntries(term, deckName) {
      if (!deckName) {
        return {
          deckName: "",
          entries: [],
          totalCount: 0,
          shownCount: 0,
          truncated: false,
          error: "",
        };
      }

      const sanitizedDeckName = escapeDeckNameForQuery(deckName);
      const sanitizedTerm = escapeSearchTerm(term);
      const queryParts = [`deck:"${sanitizedDeckName}"`];
      if (sanitizedTerm) {
        queryParts.push(`"${sanitizedTerm}"`);
      }

      const query = queryParts.join(" ");

      try {
        const noteIds = await callAnkiConnect("findNotes", { query });
        if (!Array.isArray(noteIds) || !noteIds.length) {
          return {
            deckName,
            entries: [],
            totalCount: 0,
            shownCount: 0,
            truncated: false,
            error: "",
          };
        }

        const limitedNoteIds = noteIds.slice(0, NOTE_SEARCH_LIMIT);
        const notesInfo = await callAnkiConnect("notesInfo", { notes: limitedNoteIds });
        const entries = mapDeckNotesToEntries(notesInfo, deckName, sanitizedTerm || term);

        return {
          deckName,
          entries,
          totalCount: noteIds.length,
          shownCount: entries.length,
          truncated: noteIds.length > limitedNoteIds.length,
          error: "",
        };
      } catch (error) {
        console.warn(`Deck lookup failed for "${deckName}"`, error);
        return {
          deckName,
          entries: [],
          totalCount: 0,
          shownCount: 0,
          truncated: false,
          error: error?.message || "Deck lookup failed.",
        };
      }
    }

    function applyNoteToEditor(noteDetails) {
      if (!noteDetails) {
        return;
      }

      frontField.value = noteDetails.fields.frontHtml || "";
      backField.value = noteDetails.fields.backHtml || "";
      exampleField.value = noteDetails.fields.exampleHtml || "";

      if (Array.isArray(noteDetails.tags)) {
        tagsInput.value = noteDetails.tags.join(", ");
      } else {
        tagsInput.value = "";
      }

      updatePreview();
    }

    async function updateExistingNoteFromEditor(noteDetails) {
      if (!noteDetails || !noteDetails.id) {
        throw new Error("This note cannot be updated.");
      }

      const updateFields = {};

      if (noteDetails.fieldMap.front) {
        updateFields[noteDetails.fieldMap.front] = frontField.value.trim();
      }

      if (noteDetails.fieldMap.back) {
        updateFields[noteDetails.fieldMap.back] = backField.value.trim();
      }

      if (noteDetails.fieldMap.example) {
        updateFields[noteDetails.fieldMap.example] = exampleField.value.trim();
      }

      const fieldNames = Object.keys(updateFields);
      if (!fieldNames.length) {
        throw new Error("No mapped fields available for update.");
      }

      await callAnkiConnect("updateNoteFields", {
        note: {
          id: noteDetails.id,
          fields: updateFields,
        },
      });
    }

    function createMaskFromMatch(match) {
      if (!match) {
        return match;
      }

      const characters = Array.from(match);
      const masked = [];
      let preservedCount = 0;
      const maskableCharacters = characters.filter((char) => !/\s/.test(char));
      const keep = maskableCharacters.length >= 6 ? 2 : 1;

      characters.forEach((char) => {
        if (/\s/.test(char)) {
          masked.push(char);
        } else if (preservedCount < keep) {
          masked.push(char);
          preservedCount += 1;
        } else {
          masked.push("•");
        }
      });

      return masked.join("");
    }

    function maskTargetInText(text, target) {
      if (!text || !target) {
        return text;
      }

      const escaped = escapeRegExp(target.trim());
      if (!escaped) {
        return text;
      }

      const pattern = new RegExp(escaped, "gi");
      return text.replace(pattern, (match) => createMaskFromMatch(match));
    }

    async function loadNoteTypesForDeck(deckName) {
      if (!deckName) {
        pendingNoteTypeDeck = "";
        updateModelSuggestions([]);
        return;
      }

      pendingNoteTypeDeck = deckName;

      try {
        const sanitizedDeckName = escapeDeckNameForQuery(deckName);
        const noteIds = await callAnkiConnect("findNotes", {
          query: `deck:"${sanitizedDeckName}"`,
        });

        if (pendingNoteTypeDeck !== deckName) {
          return;
        }

        const noteTypeSet = new Set();

        if (Array.isArray(noteIds) && noteIds.length) {
          const batchLimit = Math.max(1, NOTE_SAMPLE_BATCH_LIMIT);
          for (
            let index = 0;
            index < noteIds.length && index / NOTE_SAMPLE_BATCH_SIZE < batchLimit;
            index += NOTE_SAMPLE_BATCH_SIZE
          ) {
            const batch = noteIds.slice(index, index + NOTE_SAMPLE_BATCH_SIZE);
            if (!batch.length) {
              continue;
            }

            const notesInfo = await callAnkiConnect("notesInfo", { notes: batch });

            if (pendingNoteTypeDeck !== deckName) {
              return;
            }

            if (Array.isArray(notesInfo)) {
              notesInfo.forEach((note) => {
                if (note && note.modelName) {
                  noteTypeSet.add(note.modelName);
                }
              });
            }

            if (batch.length < NOTE_SAMPLE_BATCH_SIZE) {
              break;
            }
          }
        }

        if (pendingNoteTypeDeck !== deckName) {
          return;
        }

        let noteTypes = Array.from(noteTypeSet).sort((a, b) => a.localeCompare(b));
        let statusMessage = "";

        if (!noteTypes.length) {
          const allModelNames = await callAnkiConnect("modelNames");

          if (pendingNoteTypeDeck !== deckName) {
            return;
          }

          if (Array.isArray(allModelNames)) {
            allModelNames.forEach((name) => {
              if (name) {
                noteTypeSet.add(name);
              }
            });
          }

          noteTypes = Array.from(noteTypeSet).sort((a, b) => a.localeCompare(b));

          if (!noteTypes.length) {
            throw new Error("No note types available.");
          }

          statusMessage = `No existing notes found in "${deckName}". Showing all note types.`;
        } else {
          statusMessage = `Loaded ${noteTypes.length} note type${
            noteTypes.length === 1 ? "" : "s"
          } from "${deckName}".`;
        }

        if (pendingNoteTypeDeck !== deckName) {
          return;
        }

        updateModelSuggestions(noteTypes);

        const currentModelName = modelNameInput.value.trim();
        if (!userModifiedNoteType || !noteTypes.includes(currentModelName)) {
          const preferredModelName = noteTypes.includes(DEFAULT_MODEL_NAME)
            ? DEFAULT_MODEL_NAME
            : noteTypes[0] || currentModelName;

          if (preferredModelName && preferredModelName !== currentModelName) {
            modelNameInput.value = preferredModelName;
            updatePreview();
          }

          userModifiedNoteType = false;
        }

        setStatus(statusMessage, "success");
      } catch (error) {
        if (pendingNoteTypeDeck !== deckName) {
          return;
        }

        console.error(error);
        updateModelSuggestions([]);
        setStatus(error.message || "Failed to load note types", "error");
      }
    }

    async function loadDecks() {
      setStatus("Loading decks…");
      loadDecksBtn.disabled = true;
      try {
        const deckNames = await callAnkiConnect("deckNames");
        deckSelect.innerHTML = "";
        if (!deckNames.length) {
          const option = document.createElement("option");
          option.textContent = "No decks found";
          option.disabled = true;
          option.selected = true;
          deckSelect.appendChild(option);
        } else {
          const placeholder = document.createElement("option");
          placeholder.textContent = "Choose a deck";
          placeholder.disabled = true;
          placeholder.selected = true;
          placeholder.value = "";
          deckSelect.appendChild(placeholder);
          for (const deck of deckNames) {
            const option = document.createElement("option");
            option.value = deck;
            option.textContent = deck;
            deckSelect.appendChild(option);
          }
          const savedDeck = getSessionItem(SESSION_KEYS.deck);
          if (savedDeck && deckNames.includes(savedDeck)) {
            deckSelect.value = savedDeck;
            persistDeckSelection();
            await loadNoteTypesForDeck(savedDeck);
            updatePreview();
            return;
          }
        }
        updateModelSuggestions([]);
        setStatus("Decks loaded", "success");
        updatePreview();
      } catch (error) {
        console.error(error);
        setStatus(error.message || "Failed to load decks", "error");
      } finally {
        loadDecksBtn.disabled = false;
      }
    }

    function buildDefinitionCard(entry, meaning, definitionIndex) {
      const card = document.createElement("div");
      card.className = "definition-card";

      let headword = null;
      if (entry.word) {
        headword = document.createElement("h3");
        headword.style.margin = "0 0 0.35rem 0";
        headword.style.fontSize = "1.05rem";
        headword.textContent = entry.word;
        card.appendChild(headword);
      }

      const header = document.createElement("header");
      const badgeGroup = document.createElement("div");
      badgeGroup.style.display = "flex";
      badgeGroup.style.flexWrap = "wrap";
      badgeGroup.style.gap = "0.4rem";
      badgeGroup.style.alignItems = "center";

      if (entry.isExistingNote) {
        const existingBadge = document.createElement("span");
        existingBadge.className = "badge";
        existingBadge.textContent = "Existing card";
        badgeGroup.appendChild(existingBadge);
      }

      if (entry.source) {
        const sourceBadge = document.createElement("span");
        sourceBadge.className = "badge secondary";
        sourceBadge.textContent = entry.source;
        badgeGroup.appendChild(sourceBadge);
      }

      const partOfSpeech = document.createElement("span");
      partOfSpeech.className = "badge";
      partOfSpeech.textContent = meaning.partOfSpeech || "Definition";
      badgeGroup.appendChild(partOfSpeech);

      header.appendChild(badgeGroup);

      if (entry.isExistingNote && entry.noteDetails) {
        const buttonGroup = document.createElement("div");
        buttonGroup.style.display = "flex";
        buttonGroup.style.flexWrap = "wrap";
        buttonGroup.style.gap = "0.5rem";

        const loadButton = document.createElement("button");
        loadButton.textContent = "Load this card";
        loadButton.addEventListener("click", () => {
          applyNoteToEditor(entry.noteDetails);
          const deckLabel = entry.noteDetails.deckName
            ? ` from "${entry.noteDetails.deckName}"`
            : "";
          setStatus(`Existing card loaded${deckLabel}.`, "success");
        });

        const updateButton = document.createElement("button");
        updateButton.textContent = "Update card";
        updateButton.addEventListener("click", async () => {
          try {
            setStatus("Updating existing card…");
            updateButton.disabled = true;
            await updateExistingNoteFromEditor(entry.noteDetails);
            if (entry.noteDetails.fieldMap.front) {
              entry.noteDetails.fields.frontHtml = frontField.value.trim();
              entry.noteDetails.display.frontText = stripHtml(
                entry.noteDetails.fields.frontHtml
              );
              if (entry.noteDetails.display.frontText) {
                entry.word = entry.noteDetails.display.frontText;
                if (headword) {
                  headword.textContent = entry.noteDetails.display.frontText;
                }
              }
            }
            if (entry.noteDetails.fieldMap.back) {
              entry.noteDetails.fields.backHtml = backField.value.trim();
              entry.noteDetails.display.backText = stripHtml(
                entry.noteDetails.fields.backHtml
              );
              if (meaning.definitions[definitionIndex]) {
                meaning.definitions[definitionIndex].definition =
                  entry.noteDetails.display.backText || "";
              }
            }
            if (entry.noteDetails.fieldMap.example) {
              entry.noteDetails.fields.exampleHtml = exampleField.value.trim();
              entry.noteDetails.display.exampleText = stripHtml(
                entry.noteDetails.fields.exampleHtml
              );
              if (meaning.definitions[definitionIndex]) {
                meaning.definitions[definitionIndex].example =
                  entry.noteDetails.display.exampleText || "";
              }
            }
            if (definitionText) {
              definitionText.textContent =
                meaning.definitions[definitionIndex]?.definition || "";
            }
            if (exampleParaRef) {
              exampleParaRef.textContent =
                meaning.definitions[definitionIndex]?.example || "";
            }
            updatePreview();
            const deckLabel = entry.noteDetails.deckName
              ? ` in "${entry.noteDetails.deckName}"`
              : "";
            setStatus(`Existing card updated${deckLabel}.`, "success");
          } catch (error) {
            setStatus(error.message || "Failed to update card", "error");
          } finally {
            updateButton.disabled = false;
          }
        });

        buttonGroup.appendChild(loadButton);
        buttonGroup.appendChild(updateButton);
        header.appendChild(buttonGroup);
      } else {
        const button = document.createElement("button");
        button.textContent = "Use this meaning";
        button.addEventListener("click", () => {
          const definitionText = meaning.definitions[definitionIndex]?.definition || "";
          const exampleText = meaning.definitions[definitionIndex]?.example || "";
          const lookupTerm = lookupTermInput.value.trim();
          frontField.value = lookupTerm;
          const maskedDefinition = maskTargetInText(definitionText, lookupTerm);
          backField.value = maskedDefinition;
          if (exampleText) {
            exampleField.value = maskTargetInText(exampleText, lookupTerm);
          }
          updatePreview();
          const sourceLabel = entry.source ? ` (${entry.source})` : "";
          setStatus(`Definition inserted into the card editor${sourceLabel}`, "success");
        });
        header.appendChild(button);
      }

      card.appendChild(header);

      if (entry.note) {
        const note = document.createElement("p");
        note.style.margin = "0";
        note.style.fontSize = "0.85rem";
        note.style.color = "#4a5781";
        note.textContent = entry.note;
        card.appendChild(note);
      }

      const definitionText = document.createElement("p");
      definitionText.className = "definition-text";
      definitionText.textContent = meaning.definitions[definitionIndex]?.definition || "";
      card.appendChild(definitionText);

      let exampleParaRef = null;
      const example = meaning.definitions[definitionIndex]?.example;
      if (example) {
        const examplePara = document.createElement("p");
        examplePara.className = "example-text";
        examplePara.textContent = example;
        if (entry.isExistingNote) {
          exampleParaRef = examplePara;
          card.appendChild(examplePara);
        } else {
          const exampleButton = document.createElement("button");
          exampleButton.textContent = "Use this example";
          exampleButton.addEventListener("click", () => {
            const lookupTerm = lookupTermInput.value.trim();
            exampleField.value = maskTargetInText(example, lookupTerm);
            updatePreview();
            setStatus("Example added to the card", "success");
          });

          const exampleWrapper = document.createElement("div");
          exampleWrapper.style.display = "grid";
          exampleWrapper.style.gap = "0.6rem";
          exampleWrapper.appendChild(examplePara);
          exampleWrapper.appendChild(exampleButton);
          card.appendChild(exampleWrapper);
        }
      }

      if (entry.phonetic) {
        const phonetic = document.createElement("p");
        phonetic.style.margin = "0";
        phonetic.innerHTML = `<strong>Phonetic:</strong> ${entry.phonetic}`;
        card.appendChild(phonetic);
      }

      return card;
    }

    function renderDictionaryResults(entries) {
      dictionaryResults.innerHTML = "";
      if (!entries || !entries.length) {
        dictionaryResults.textContent = "No results found.";
        return;
      }

      entries.forEach((entry) => {
        entry.meanings.forEach((meaning) => {
          meaning.definitions.forEach((_def, index) => {
            dictionaryResults.appendChild(buildDefinitionCard(entry, meaning, index));
          });
        });
      });
    }

    async function searchDictionary() {
      const term = lookupTermInput.value.trim();
      if (!term) {
        setStatus("Type a term to search", "error");
        return;
      }

      setStatus(`Searching all dictionaries for "${term}"…`);
      searchButton.disabled = true;
      dictionaryResults.textContent = "Searching…";

      const uniqueEntryKeys = new Set();
      const collectedEntries = [];
      const contributingProviders = new Set();
      let embeddedMatchCount = 0;

      const addEntries = (entries, providerLabel = "", options = {}) => {
        const { prepend = false, trackProvider = true } = options;
        if (!Array.isArray(entries)) {
          return;
        }

        const iterable = prepend ? [...entries].reverse() : entries;

        iterable.forEach((entry) => {
          if (!entry || !Array.isArray(entry.meanings) || !entry.meanings.length) {
            return;
          }

          const key = entry.uniqueKey
            ? entry.uniqueKey
            : JSON.stringify({
                source: entry.source || "",
                word: entry.word || "",
                meanings: entry.meanings.map((meaning) => ({
                  partOfSpeech: meaning.partOfSpeech || "",
                  definitions: (meaning.definitions || []).map((definition) => ({
                    definition: definition.definition || "",
                    example: definition.example || "",
                  })),
                })),
              });

          if (!uniqueEntryKeys.has(key)) {
            uniqueEntryKeys.add(key);
            if (prepend) {
              collectedEntries.unshift(entry);
            } else {
              collectedEntries.push(entry);
            }
            const contributorLabel = entry.source || providerLabel;
            if (trackProvider && contributorLabel) {
              contributingProviders.add(contributorLabel);
            }
          }
        });
      };

      try {
        const providerIds = Object.keys(dictionaryProviders);
        const deckName = deckSelect.value;

        const [providerResponses, deckLookupSummary] = await Promise.all([
          Promise.all(
            providerIds.map(async (providerId) => {
              const provider = dictionaryProviders[providerId];
              if (!provider) {
                return { providerId, entries: [], embeddedCount: 0 };
              }

              const providerEntries = [];
              let providerEmbeddedCount = 0;
              const providerLabel = provider.label || providerId;

              try {
                const directEntries = await provider.fetchEntries(term);
                if (Array.isArray(directEntries)) {
                  providerEntries.push(...directEntries);
                }
              } catch (error) {
                console.warn(`Lookup failed for ${providerLabel}`, error);
              }

              try {
                const embeddedEntries = await searchWithinEntries(term, providerId);
                providerEmbeddedCount += embeddedEntries.length;
                if (Array.isArray(embeddedEntries)) {
                  providerEntries.push(...embeddedEntries);
                }
              } catch (embeddedError) {
                console.warn(`Embedded search failed for ${providerLabel}`, embeddedError);
              }

              return { providerId, entries: providerEntries, embeddedCount: providerEmbeddedCount };
            })
          ),
          findDeckEntries(term, deckName),
        ]);

        providerResponses.forEach(({ providerId, entries, embeddedCount }) => {
          embeddedMatchCount += embeddedCount;
          const providerLabel = dictionaryProviders[providerId]?.label || providerId;
          addEntries(entries, providerLabel);
        });

        if (deckLookupSummary.entries.length) {
          addEntries(deckLookupSummary.entries, deckLookupSummary.deckName || "Existing cards", {
            prepend: true,
            trackProvider: false,
          });
        }

        if (!collectedEntries.length) {
          renderDictionaryResults([]);
          let emptyMessage = "No entries available.";
          if (deckLookupSummary.deckName && deckLookupSummary.error) {
            emptyMessage += ` Deck lookup failed for "${deckLookupSummary.deckName}": ${deckLookupSummary.error}`;
          }
          setStatus(emptyMessage, "error");
          return;
        }

        renderDictionaryResults(collectedEntries);
        const providerCount = contributingProviders.size;
        const totalProviders = providerIds.length;
        const providerList = Array.from(contributingProviders);
        let providerSummary;
        if (providerCount === totalProviders && providerCount > 0) {
          providerSummary = "all dictionaries";
        } else if (providerCount === 1) {
          providerSummary = providerList[0];
        } else if (providerCount > 1) {
          providerSummary = `${providerCount} dictionaries (${providerList.join(", ")})`;
        } else {
          providerSummary = "the available dictionaries";
        }

        const embeddedNote = embeddedMatchCount
          ? ` including ${embeddedMatchCount} embedded match${embeddedMatchCount === 1 ? "" : "es"}`
          : "";
        const statusParts = [`Dictionary results loaded from ${providerSummary}${embeddedNote}.`];

        if (deckLookupSummary.deckName) {
          if (deckLookupSummary.error) {
            statusParts.push(
              `Deck lookup failed for "${deckLookupSummary.deckName}": ${deckLookupSummary.error}`
            );
          } else if (deckLookupSummary.totalCount > 0) {
            let deckMessage = `Found ${deckLookupSummary.totalCount} existing card${
              deckLookupSummary.totalCount === 1 ? "" : "s"
            } in "${deckLookupSummary.deckName}"`;
            if (deckLookupSummary.truncated && deckLookupSummary.shownCount) {
              deckMessage += ` (showing first ${deckLookupSummary.shownCount}).`;
            } else {
              deckMessage += ".";
            }
            statusParts.push(deckMessage);
          } else {
            statusParts.push(`No existing cards matched in "${deckLookupSummary.deckName}".`);
          }
        }

        const statusType = deckLookupSummary.error ? "error" : "success";
        setStatus(statusParts.join(" "), statusType);
      } catch (error) {
        console.error(error);
        dictionaryResults.textContent = "No entries available.";
        setStatus(error.message || "Failed to fetch dictionary results", "error");
      } finally {
        searchButton.disabled = false;
      }
    }

    async function addCard() {
      const deckName = deckSelect.value;
      const modelName = modelNameInput.value.trim() || DEFAULT_MODEL_NAME;
      const front = frontField.value.trim();
      const back = backField.value.trim();

      if (!deckName) {
        setStatus("Please choose a deck", "error");
        return;
      }

      if (!front || !back) {
        setStatus("Front and back cannot be empty", "error");
        return;
      }

      setStatus("Adding card to deck…");
      addCardBtn.disabled = true;

      const example = exampleField.value.trim();
      const tags = tagsInput.value
        .split(",")
        .map((tag) => tag.trim())
        .filter(Boolean);

      const fields = {
        Front: front,
        Back: example ? `${back}\n\n<em>${example}</em>` : back,
      };

      try {
        await callAnkiConnect("addNote", {
          note: {
            deckName,
            modelName,
            fields,
            tags,
          },
        });

        try {
          await callAnkiConnect("sync");
          setStatus(
            "Card added and sync requested using Anki's saved session.",
            "success"
          );
        } catch (syncError) {
          console.warn("Sync failed", syncError);
          setStatus(
            `Card added but sync failed via saved session: ${syncError.message}`,
            "error"
          );
        }
      } catch (error) {
        console.error(error);
        setStatus(error.message || "Failed to add card", "error");
      } finally {
        addCardBtn.disabled = false;
      }
    }

    const initialDeckSelection = getSessionItem(SESSION_KEYS.deck);
    if (initialDeckSelection) {
      loadDecks();
    }

    loadDecksBtn.addEventListener("click", loadDecks);
    searchButton.addEventListener("click", searchDictionary);
    lookupTermInput.addEventListener("keydown", (event) => {
      if (event.key === "Enter") {
        event.preventDefault();
        searchDictionary();
      }
    });
    addCardBtn.addEventListener("click", addCard);

    updatePreview();
  </script>
</body>
</html>

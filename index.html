<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Anki Card Creator</title>
  <style>
    :root {
      color-scheme: light dark;
      font-family: "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      line-height: 1.5;
      font-size: 16px;
    }

    body {
      margin: 0;
      padding: clamp(1.5rem, 3vw, 3rem);
      background: radial-gradient(circle at top left, #f7f8ff, #eaeefd 40%, #e0e0f5);
      min-height: 100vh;
      color: #1e2a44;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      box-sizing: border-box;
    }

    .app {
      --note-sidebar-width: clamp(320px, 28vw, 420px);
      --settings-sidebar-width: clamp(260px, 22vw, 340px);
      background: rgba(255, 255, 255, 0.95);
      box-shadow: 0 22px 68px rgba(30, 42, 68, 0.28);
      border-radius: 28px;
      width: min(95vw, 1500px);
      display: grid;
      grid-template-columns: var(--note-sidebar-width) minmax(0, 1fr) var(--settings-sidebar-width);
      grid-template-areas: "note main settings";
      align-items: stretch;
      overflow: hidden;
      position: relative;
      transition: grid-template-columns 0.3s ease;
    }

    .note-sidebar,
    .settings-sidebar {
      padding: 2rem;
      box-sizing: border-box;
      height: 100%;
      overflow-y: auto;
      transition: transform 0.3s ease, opacity 0.3s ease, visibility 0.3s ease,
        width 0.3s ease;
      will-change: transform;
      z-index: 20;
    }

    .note-sidebar {
      grid-area: note;
      background: linear-gradient(180deg, #f8f9ff, #eef0ff);
      color: #1e2a44;
      border-right: 1px solid rgba(63, 100, 199, 0.12);
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
    }

    .note-sidebar .panel {
      background: rgba(255, 255, 255, 0.95);
      box-shadow: 0 10px 30px rgba(43, 58, 92, 0.08);
    }

    .settings-sidebar {
      grid-area: settings;
      background: linear-gradient(180deg, #2f3f87, #3f64c7);
      color: white;
      border-left: 1px solid rgba(17, 29, 61, 0.18);
    }

    .sidebar-handle,
    .note-sidebar-handle,
    .settings-sidebar-handle {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 2.75rem;
      height: 2.75rem;
      border-radius: 999px;
      background: linear-gradient(180deg, #3f64c7, #4650ac);
      position: absolute;
      top: clamp(1.5rem, 3vw, 3rem);
      box-shadow: 0 12px 36px rgba(63, 100, 199, 0.25);
      transition: transform 0.3s ease, opacity 0.3s ease;
      z-index: 40;
    }

    .note-sidebar-handle {
      left: calc(var(--note-sidebar-width) + 1rem);
    }

    .settings-sidebar-handle {
      right: calc(var(--settings-sidebar-width) + 1rem);
    }

    .app.is-note-collapsed {
      grid-template-columns: 0 minmax(0, 1fr) var(--settings-sidebar-width);
    }

    .app.is-note-collapsed .note-sidebar {
      transform: translateX(-100%);
      width: 0;
      opacity: 0;
      visibility: hidden;
      pointer-events: none;
    }

    .app.is-note-collapsed .note-sidebar-handle {
      left: 1.25rem;
      opacity: 0.95;
    }

    .app.is-note-collapsed .main {
      padding-left: clamp(3.25rem, 5vw, 4rem);
    }

    .app.is-settings-collapsed {
      grid-template-columns: var(--note-sidebar-width) minmax(0, 1fr) 0;
    }

    .app.is-settings-collapsed .settings-sidebar {
      transform: translateX(100%);
      width: 0;
      opacity: 0;
      visibility: hidden;
      pointer-events: none;
    }

    .app.is-settings-collapsed .settings-sidebar-handle {
      right: 1.25rem;
      opacity: 0.95;
    }

    .app.is-settings-collapsed .main {
      padding-right: clamp(3.25rem, 5vw, 4rem);
    }

    .app.is-note-collapsed.is-settings-collapsed {
      grid-template-columns: minmax(0, 1fr);
    }

    .app.is-note-collapsed.is-settings-collapsed .main {
      padding-left: clamp(3.25rem, 5vw, 4rem);
      padding-right: clamp(3.25rem, 5vw, 4rem);
    }

    .sidebar-toggle {
      width: 2.5rem;
      height: 2.5rem;
      border: none;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.22);
      color: white;
      display: grid;
      place-items: center;
      cursor: pointer;
      transition: background 0.2s ease, transform 0.2s ease;
      padding: 0;
    }

    .sidebar-toggle::before {
      font-size: 1rem;
      line-height: 1;
      transition: transform 0.2s ease;
    }

    .sidebar-toggle[data-side="note"]::before {
      content: "❮";
    }

    .sidebar-toggle[data-side="note"][data-state="collapsed"]::before {
      content: "❯";
    }

    .sidebar-toggle[data-side="settings"]::before {
      content: "❯";
    }

    .sidebar-toggle[data-side="settings"][data-state="collapsed"]::before {
      content: "❮";
    }

    .sidebar-toggle:hover,
    .sidebar-toggle:focus-visible {
      background: rgba(255, 255, 255, 0.35);
      transform: translateX(-1px);
      outline: none;
      box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.65);
    }

    .app.is-note-collapsed .sidebar-toggle[data-side="note"],
    .app.is-settings-collapsed .sidebar-toggle[data-side="settings"] {
      transform: none;
    }

    .settings-sidebar h1 {
      margin-top: 0;
      margin-bottom: 1.5rem;
      font-size: 1.9rem;
      letter-spacing: 0.02em;
    }

    .settings-sidebar section + section {
      margin-top: 2.5rem;
    }

    label {
      font-weight: 600;
      display: block;
      margin-bottom: 0.5rem;
    }

    input[type="text"],
    input[type="password"],
    textarea,
    select {
      width: 100%;
      border: 1px solid rgba(30, 42, 68, 0.2);
      border-radius: 10px;
      padding: 0.7rem 0.85rem;
      font-size: 1rem;
      font-family: inherit;
      box-sizing: border-box;
      background: rgba(255, 255, 255, 0.95);
      color: #1e2a44;
    }

    textarea {
      resize: vertical;
      overflow: hidden;
    }

    button {
      background: #3f64c7;
      border: none;
      border-radius: 999px;
      padding: 0.65rem 1.35rem;
      font-size: 0.95rem;
      font-weight: 600;
      color: white;
      cursor: pointer;
      transition: transform 0.15s ease, box-shadow 0.15s ease;
      box-shadow: 0 10px 30px rgba(63, 100, 199, 0.3);
    }

    button:hover {
      transform: translateY(-1px);
      box-shadow: 0 12px 32px rgba(63, 100, 199, 0.4);
    }

    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      box-shadow: none;
      transform: none;
    }

    .main {
      grid-area: main;
      padding: 2rem 2.5rem;
      background: rgba(249, 250, 255, 0.9);
      display: flex;
      flex-direction: column;
      gap: 2rem;
      max-height: calc(100vh - 4rem);
      overflow-y: auto;
      min-height: 0;
    }

    .panel {
      background: white;
      border-radius: 16px;
      padding: 1.5rem;
      box-shadow: 0 10px 30px rgba(43, 58, 92, 0.1);
    }


    #dictionary-panel {
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
      min-height: 0;
      grid-area: dictionary;
    }

    #dictionary-panel .dictionary-results {
      flex: 1 1 auto;
      overflow-y: auto;
      min-height: 0;
    }

    .note-panel {
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
      grid-area: note;
    }

    .note-grid {
      display: grid;
      gap: 1rem;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      grid-template-areas:
        "word masked"
        "definition definition"
        "example example";
    }

    .note-field {
      display: grid;
      gap: 0.5rem;
    }

    .note-field--word {
      grid-area: word;
    }

    .note-field--masked {
      grid-area: masked;
    }

    .note-field--definition {
      grid-area: definition;
    }

    .note-field--example {
      grid-area: example;
    }

    .note-actions {
      display: flex;
      gap: 1rem;
      align-items: center;
      flex-wrap: wrap;
    }

    @media (orientation: landscape) {
      #dictionary-panel .dictionary-results {
        padding-right: 0.25rem;
      }
    }

    #note-panel {
      width: 100%;
    }

    @media (min-width: 1024px) {
      .app {
        --note-sidebar-width: clamp(320px, 24vw, 420px);
        --settings-sidebar-width: clamp(280px, 20vw, 340px);
      }

      #note-panel {
        position: sticky;
        top: clamp(1.5rem, 3vw, 3rem);
        align-self: flex-start;
      }

      #dictionary-panel {
        overflow: hidden;
        height: 100%;
      }
    }

    @media (min-width: 1400px) {
      .app {
        --note-sidebar-width: clamp(340px, 22vw, 460px);
        --settings-sidebar-width: clamp(300px, 18vw, 380px);
      }
    }

    .setup-notice {
      border: 1px solid rgba(63, 100, 199, 0.18);
      background: linear-gradient(
        135deg,
        rgba(63, 100, 199, 0.14),
        rgba(70, 80, 172, 0.04)
      );
      display: grid;
      gap: 0.75rem;
    }

    .setup-notice.is-hidden {
      display: none;
    }

    .setup-steps {
      margin: 0;
      padding-left: 1.2rem;
      color: #2f4075;
    }

    .setup-steps li + li {
      margin-top: 0.4rem;
    }

    .setup-snippet {
      background: rgba(63, 100, 199, 0.12);
      border-radius: 12px;
      padding: 0.9rem 1rem;
      font-family: "Fira Code", "SFMono-Regular", Menlo, Monaco, Consolas,
        "Liberation Mono", "Courier New", monospace;
      font-size: 0.9rem;
      color: #1f2b4a;
      overflow-x: auto;
    }

    .setup-snippet pre {
      margin: 0;
      white-space: pre;
    }

    .setup-footnote {
      margin: 0;
      font-size: 0.85rem;
      color: #3f4d7a;
    }

    .panel h2 {
      margin-top: 0;
      font-size: 1.35rem;
      color: #2f4075;
    }

    .dictionary-controls {
      display: grid;
      grid-template-columns: minmax(0, 1fr) auto;
      gap: 0.75rem;
      align-items: center;
    }

    .dictionary-settings {
      margin-top: 1rem;
      display: grid;
      gap: 0.75rem;
    }

    .dictionary-settings label {
      display: block;
      margin-bottom: 0.4rem;
    }

    .dictionary-results {
      display: grid;
      gap: 1rem;
      margin-top: 1rem;
    }


    .definition-entry {
      border: 1px solid rgba(63, 100, 199, 0.18);
      border-radius: 16px;
      background: rgba(242, 245, 255, 0.6);
      padding: 0.3rem 0.6rem;
    }

    .definition-entry > summary {
      list-style: none;
      display: flex;
      justify-content: space-between;
      gap: 0.75rem;
      align-items: center;
      cursor: pointer;
      padding: 0.55rem 0.35rem;
    }

    .definition-entry > summary::-webkit-details-marker {
      display: none;
    }

    .entry-summary-text {
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
    }

    .entry-headword {
      font-size: 1.05rem;
      font-weight: 700;
      color: #1e2a44;
    }

    .badge-row {
      display: flex;
      gap: 0.35rem;
      flex-wrap: wrap;
      align-items: center;
    }

    .badge {
      background: rgba(63, 100, 199, 0.15);
      color: #2a3d82;
      border-radius: 999px;
      padding: 0.3rem 0.75rem;
      font-size: 0.75rem;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.02em;
    }

    .badge.secondary {
      background: rgba(42, 61, 130, 0.1);
      color: #3f64c7;
    }

    .entry-content {
      padding: 0 0.9rem 0.9rem 0.9rem;
      display: grid;
      gap: 0.9rem;
    }

    .entry-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 0.6rem;
    }

    .meaning-block {
      background: rgba(255, 255, 255, 0.8);
      border-radius: 12px;
      border: 1px solid rgba(63, 100, 199, 0.12);
      padding: 0.75rem 0.85rem;
      display: grid;
      gap: 0.75rem;
    }

    .meaning-title {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.6rem;
    }

    .definition-list {
      list-style: decimal inside;
      margin: 0;
      padding: 0;
      display: grid;
      gap: 0.65rem;
    }

    .definition-item {
      display: grid;
      gap: 0.45rem;
    }

    .definition-actions {
      display: grid;
      gap: 0.4rem;
      align-content: start;
    }

    .definition-actions button {
      justify-self: start;
    }

    .existing-note-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      align-items: center;
      margin-bottom: 0.75rem;
    }

    .existing-note-actions button {
      flex-shrink: 0;
    }

    .existing-note-actions span {
      font-size: 0.85rem;
      color: rgba(30, 42, 68, 0.72);
    }

    .definition-text {
      font-size: 1rem;
      color: #1e2a44;
    }

    .example-list {
      list-style: none;
      margin: 0;
      padding: 0;
      display: grid;
      gap: 0.45rem;
    }

    .example-item {
      display: grid;
      gap: 0.35rem;
    }

    .example-text {
      font-style: italic;
      color: #42507b;
    }

    .example-item button {
      justify-self: start;
    }

    .status {
      font-size: 0.95rem;
      min-height: 1.5rem;
    }

    .status.success {
      color: #1a8f5b;
    }

    .status.error {
      color: #cc2b3d;
    }

    .split {
      display: grid;
      gap: 1rem;
    }

    .additional-fields {
      margin-top: 1.5rem;
      display: grid;
      gap: 1.25rem;
    }

    .additional-field {
      display: grid;
      gap: 0.5rem;
    }

    @media (max-width: 980px) {
      body {
        padding: 1rem;
      }

      .app {
        grid-template-columns: 1fr;
        min-height: calc(100vh - 2rem);
      }

      .note-sidebar,
      .settings-sidebar {
        position: absolute;
        top: 0;
        bottom: 0;
        max-width: min(320px, 92vw);
        width: min(320px, 92vw);
        height: 100%;
        overflow-y: auto;
        box-shadow: 0 24px 48px rgba(58, 75, 115, 0.35);
        opacity: 0;
        visibility: hidden;
        pointer-events: none;
      }

      .note-sidebar {
        left: 0;
        border-radius: 0 16px 16px 0;
        transform: translateX(-100%);
      }

      .settings-sidebar {
        right: 0;
        border-radius: 16px 0 0 16px;
        transform: translateX(100%);
      }

      .app:not(.is-note-collapsed) .note-sidebar {
        transform: translateX(0);
        opacity: 1;
        visibility: visible;
        pointer-events: auto;
      }

      .app:not(.is-settings-collapsed) .settings-sidebar {
        transform: translateX(0);
        opacity: 1;
        visibility: visible;
        pointer-events: auto;
      }

      .note-sidebar-handle,
      .settings-sidebar-handle {
        position: fixed;
        top: 1.25rem;
      }

      .note-sidebar-handle {
        left: 1.25rem;
      }

      .settings-sidebar-handle {
        right: 1.25rem;
      }

      .main {
        padding: 1.5rem;
      }

      .sidebar-toggle,
      .app.is-note-collapsed .sidebar-toggle[data-side="note"],
      .app.is-settings-collapsed .sidebar-toggle[data-side="settings"] {
        width: 3rem;
        height: 3rem;
        border-radius: 999px;
        background: rgba(63, 100, 199, 0.95);
        transform: none;
      }

      .sidebar-toggle:hover,
      .sidebar-toggle:focus-visible {
        background: rgba(63, 100, 199, 1);
        transform: none;
      }
    }
  </style>
</head>
<body>
  <div class="app">
    <aside class="note-sidebar" id="note-sidebar" aria-label="Note editor">
      <section class="panel note-panel" id="note-panel">
        <div class="note-grid">
          <div class="note-field note-field--word">
            <textarea
              id="front-field"
              placeholder="Word"
              aria-label="Word"
              title="Word"
            ></textarea>
          </div>
          <div class="note-field note-field--masked" id="masked-field-container" hidden></div>
          <div class="note-field note-field--definition">
            <textarea
              id="back-field"
              placeholder="Definition"
              aria-label="Definition"
              title="Definition"
            ></textarea>
          </div>
          <div class="note-field note-field--example" id="example-field-wrapper">
            <textarea
              id="example-field"
              placeholder="Example"
              aria-label="Example"
              title="Example"
            ></textarea>
          </div>
        </div>
        <div class="additional-fields" id="additional-fields" hidden></div>
        <div class="note-actions">
          <button id="update-card" disabled>Update Loaded Card</button>
          <button id="add-card">Add Card to Deck</button>
          <span class="status" id="status"></span>
        </div>
      </section>
    </aside>

    <div class="note-sidebar-handle">
      <button
        id="note-sidebar-toggle"
        class="sidebar-toggle"
        type="button"
        aria-controls="note-sidebar"
        aria-expanded="true"
        data-state="expanded"
        data-side="note"
        aria-label="Hide note editor"
      ></button>
    </div>

    <main class="main">
      <section
        class="panel setup-notice"
        id="setup-notice"
        aria-live="polite"
      >
        <h2>Set up AnkiConnect for GitHub Pages</h2>
        <p style="margin: 0;">
          Allow this page to talk to AnkiConnect so decks and cards can be
          managed from the browser.
        </p>
        <ol class="setup-steps">
          <li>
            In Anki, open <strong>Tools → Add-ons → AnkiConnect → Config</strong>.
          </li>
          <li>
            Add your GitHub Pages URL to the <code>webCorsOriginList</code>
            setting.
          </li>
          <li>Save the configuration and restart Anki if prompted.</li>
        </ol>
        <div class="setup-snippet" role="region" aria-label="Sample AnkiConnect configuration">
          <pre><code>{
  "webCorsOriginList": [
    "https://&lt;your-username&gt;.github.io",
    "https://&lt;your-username&gt;.github.io/anki/"
  ]
}</code></pre>
        </div>
        <p class="setup-footnote">
          This notice hides automatically after AnkiConnect responds
          successfully.
        </p>
        <p class="setup-footnote">
          Ensure your AnkiConnect configuration allows the
          <code>findNotes</code>, <code>notesInfo</code>, and
          <code>updateNoteFields</code> actions so this tool can surface and
          refresh existing cards within your decks.
        </p>
      </section>

      <section class="panel" id="dictionary-panel">
        <div class="dictionary-controls">
          <input type="text" id="lookup-term" placeholder="Search term" />
          <button id="search-dictionary">Search</button>
        </div>
        <div class="dictionary-settings">
          <div>
            <label for="existing-deck-select" style="font-weight: 600; color: #2f4075;">Existing cards deck</label>
            <select id="existing-deck-select">
              <option value="current" selected>Current deck</option>
            </select>
          </div>
        </div>
        <div class="dictionary-results" id="dictionary-results"></div>
      </section>
    </main>

    <div class="settings-sidebar-handle">
      <button
        id="settings-sidebar-toggle"
        class="sidebar-toggle"
        type="button"
        aria-controls="settings-sidebar"
        aria-expanded="true"
        data-state="expanded"
        data-side="settings"
        aria-label="Hide settings"
      ></button>
    </div>

    <aside class="settings-sidebar" id="settings-sidebar">
      <h1>Anki Card Creator</h1>
      <section>
        <label for="anki-username">AnkiWeb Username</label>
        <input type="text" id="anki-username" placeholder="name@example.com" autocomplete="username" />
        <label for="anki-password" style="margin-top: 1rem;">AnkiWeb Password</label>
        <input type="password" id="anki-password" placeholder="••••••••" autocomplete="current-password" />
      </section>

      <section>
        <label for="deck-select">Deck</label>
        <div class="split">
          <select id="deck-select">
            <option value="" disabled selected>Load decks via AnkiConnect</option>
          </select>
          <button id="load-decks">Load Decks</button>
        </div>
      </section>

      <section>
        <label for="model-name">Note Type</label>
        <input type="text" id="model-name" value="Basic" list="model-suggestions" />
        <datalist id="model-suggestions"></datalist>
      </section>
    </aside>
  </div>

  <script>
    const deckSelect = document.getElementById("deck-select");
    const loadDecksBtn = document.getElementById("load-decks");
    const lookupTermInput = document.getElementById("lookup-term");
    const searchButton = document.getElementById("search-dictionary");
    const dictionaryResults = document.getElementById("dictionary-results");
    const existingDeckSelect = document.getElementById("existing-deck-select");
    const frontField = document.getElementById("front-field");
    const backField = document.getElementById("back-field");
    const exampleField = document.getElementById("example-field");
    const exampleFieldWrapper = document.getElementById("example-field-wrapper");
    const maskedFieldContainer = document.getElementById("masked-field-container");
    const additionalFieldsContainer = document.getElementById("additional-fields");
    const updateCardBtn = document.getElementById("update-card");
    const addCardBtn = document.getElementById("add-card");
    const statusEl = document.getElementById("status");
    const usernameInput = document.getElementById("anki-username");
    const passwordInput = document.getElementById("anki-password");
    const modelNameInput = document.getElementById("model-name");
    const modelSuggestions = document.getElementById("model-suggestions");
    const tagsInput = document.getElementById("tags");
    const setupNotice = document.getElementById("setup-notice");
    const appContainer = document.querySelector(".app");
    const noteSidebar = document.getElementById("note-sidebar");
    const settingsSidebar = document.getElementById("settings-sidebar");
    const noteSidebarToggle = document.getElementById("note-sidebar-toggle");
    const settingsSidebarToggle = document.getElementById("settings-sidebar-toggle");

    const DEFAULT_FIELD_PLACEHOLDERS = {
      front: "Word",
      back: "Definition",
      example: "Example",
    };

    function adjustTextareaHeight(textarea) {
      if (!textarea) {
        return;
      }
      requestAnimationFrame(() => {
        textarea.style.height = "auto";
        textarea.style.height = `${textarea.scrollHeight}px`;
      });
    }

    const SESSION_KEYS = {
      credentials: "anki.session.credentials",
      deck: "anki.session.deck",
      setupNoticeDismissed: "anki.session.setupDismissed",
    };

    const LOCAL_STORAGE_KEYS = {
      noteSidebarCollapsed: "anki.ui.noteSidebarCollapsed",
      settingsSidebarCollapsed: "anki.ui.settingsSidebarCollapsed",
    };

    const DEFAULT_MODEL_NAME = "Basic";
    const NOTE_SAMPLE_BATCH_SIZE = 200;
    const NOTE_SAMPLE_BATCH_LIMIT = 5;
    const NOTE_SEARCH_LIMIT = 25;
    const modelFieldCache = new Map();
    const pendingModelFieldRequests = new Map();
    let modelFieldLoadToken = 0;
    let activeModelFieldMetadata = {
      modelName: "",
      orderedFieldNames: [],
      roleMap: {
        word: null,
        definition: null,
        example: null,
        masked: null,
      },
    };
    const fieldEditors = new Map();
    const additionalFieldEditors = new Map();
    let availableDeckNames = [];
    let activeLoadedNote = null;
    const PART_OF_SPEECH_ALIASES = {
      noun: ["noun", "n", "n.", "countable noun", "uncountable noun", "plural noun"],
      verb: ["verb", "v", "v.", "transitive verb", "intransitive verb", "phrasal verb"],
      adjective: ["adjective", "adj", "adj.", "adjectival"],
      adverb: ["adverb", "adv", "adv."],
      pronoun: ["pronoun", "prn", "prn."],
      preposition: ["preposition", "prep", "prep."],
      conjunction: ["conjunction", "conj", "conj."],
      interjection: ["interjection", "int", "int."],
      determiner: ["determiner", "det", "det.", "article"],
      idiom: ["idiom", "phrase", "set phrase", "expression", "idiomatic"],
    };
    const FIELD_ROLE_ALIASES = {
      word: ["word", "front", "term", "expression", "question", "prompt", "target"],
      definition: [
        "definition",
        "meaning",
        "back",
        "translation",
        "answer",
        "response",
        "explanation",
      ],
      example: ["example", "sentence", "usage", "context"],
    };
    const MASK_FIELD_ALIASES = ["w•••", "w...", "masked", "mask"];

    const htmlParser = document.createElement("div");

    let userModifiedNoteType = false;
    let pendingNoteTypeDeck = "";

    function safeParseJSON(value, fallback = null) {
      if (!value) {
        return fallback;
      }
      try {
        return JSON.parse(value);
      } catch (error) {
        console.warn("Failed to parse session JSON", error);
        return fallback;
      }
    }

    function getSessionItem(key) {
      try {
        return sessionStorage.getItem(key);
      } catch (error) {
        console.warn("Session storage unavailable", error);
        return null;
      }
    }

    function setSessionItem(key, value) {
      try {
        if (value === null || value === undefined) {
          sessionStorage.removeItem(key);
        } else {
          sessionStorage.setItem(key, value);
        }
      } catch (error) {
        console.warn("Failed to persist session value", error);
      }
    }

    function getLocalStorageItem(key) {
      try {
        return localStorage.getItem(key);
      } catch (error) {
        console.warn("Local storage unavailable", error);
        return null;
      }
    }

    function setLocalStorageItem(key, value) {
      try {
        if (value === null || value === undefined) {
          localStorage.removeItem(key);
        } else {
          localStorage.setItem(key, value);
        }
      } catch (error) {
        console.warn("Failed to persist local value", error);
      }
    }

    const focusableSidebarSelector = [
      "button:not([disabled])",
      "input:not([disabled])",
      "select:not([disabled])",
      "textarea:not([disabled])",
      "[href]",
      "[tabindex]:not([tabindex='-1'])",
    ].join(", ");

    function setupSidebarToggle({
      toggleButton,
      target,
      collapsedClass,
      storageKey,
      expandedLabel,
      collapsedLabel,
      defaultCollapsedMediaQuery,
    }) {
      if (!appContainer || !toggleButton || !target) {
        return;
      }

      const applyState = (
        collapsed,
        { shouldStore = true, shouldFocus = false } = {}
      ) => {
        appContainer.classList.toggle(collapsedClass, collapsed);
        toggleButton.setAttribute("aria-expanded", String(!collapsed));
        toggleButton.setAttribute("data-state", collapsed ? "collapsed" : "expanded");
        toggleButton.setAttribute(
          "aria-label",
          collapsed ? collapsedLabel : expandedLabel
        );

        if (shouldStore && storageKey) {
          setLocalStorageItem(storageKey, collapsed ? "true" : "false");
        }

        if (shouldFocus) {
          if (collapsed) {
            toggleButton.focus();
            return;
          }

          const focusTarget = target.querySelector(focusableSidebarSelector) || target;
          if (focusTarget === target && !target.hasAttribute("tabindex")) {
            target.setAttribute("tabindex", "-1");
          }
          focusTarget.focus();
        }
      };

      const storedPreference = storageKey ? getLocalStorageItem(storageKey) : null;
      let collapsed = storedPreference === "true";

      if (storedPreference === null && defaultCollapsedMediaQuery && window.matchMedia) {
        try {
          collapsed = window.matchMedia(defaultCollapsedMediaQuery).matches;
        } catch (error) {
          collapsed = false;
        }
      }

      applyState(collapsed, { shouldStore: false });

      const toggle = () => {
        const isCollapsed = appContainer.classList.contains(collapsedClass);
        applyState(!isCollapsed, { shouldFocus: true });
      };

      toggleButton.addEventListener("click", toggle);
      toggleButton.addEventListener("keydown", (event) => {
        if (event.key === "Enter" || event.key === " ") {
          event.preventDefault();
          toggle();
        }
      });

      target.addEventListener("keydown", (event) => {
        if (event.key === "Escape" && !appContainer.classList.contains(collapsedClass)) {
          event.preventDefault();
          applyState(true, { shouldFocus: true });
        }
      });
    }

    function initializeSidebarToggles() {
      setupSidebarToggle({
        toggleButton: noteSidebarToggle,
        target: noteSidebar,
        collapsedClass: "is-note-collapsed",
        storageKey: LOCAL_STORAGE_KEYS.noteSidebarCollapsed,
        expandedLabel: "Hide note editor",
        collapsedLabel: "Show note editor",
      });

      setupSidebarToggle({
        toggleButton: settingsSidebarToggle,
        target: settingsSidebar,
        collapsedClass: "is-settings-collapsed",
        storageKey: LOCAL_STORAGE_KEYS.settingsSidebarCollapsed,
        expandedLabel: "Hide settings",
        collapsedLabel: "Show settings",
      });
    }

    function canonicalizePartOfSpeech(label) {
      if (!label) {
        return "";
      }

      const cleaned = label
        .toString()
        .toLowerCase()
        .replace(/<[^>]*>/g, "")
        .replace(/[^a-z\s]/g, " ")
        .replace(/\s+/g, " ")
        .trim();

      if (!cleaned) {
        return "";
      }

      for (const [canonical, aliases] of Object.entries(PART_OF_SPEECH_ALIASES)) {
        if (aliases.some((alias) => cleaned === alias || cleaned.includes(alias))) {
          return canonical;
        }
      }

      return cleaned;
    }

    function generateSearchVariants(term) {
      const variants = new Set();
      const trimmed = (term || "").trim();
      if (!trimmed) {
        return [];
      }

      variants.add(trimmed);
      variants.add(trimmed.replace(/\s+/g, "-"));
      variants.add(trimmed.replace(/\s+/g, ""));
      variants.add(trimmed.replace(/-/g, " "));
      variants.add(trimmed.replace(/-/g, ""));
      variants.add(trimmed.replace(/[’']/g, ""));

      return Array.from(variants).filter(Boolean);
    }

    function parseLookupTerm(rawTerm) {
      const original = rawTerm;
      let working = rawTerm.trim();
      let posHint = "";

      const asMatch = working.match(/^(.*?)[\s,:-]*as\s+an?\s+([a-z-]+)/i);
      if (asMatch) {
        working = asMatch[1].trim();
        posHint = posHint || asMatch[2].trim();
      }

      const parenMatch = working.match(/^(.*?)[\s]*\(([^)]+)\)\s*$/);
      if (parenMatch) {
        working = parenMatch[1].trim();
        posHint = posHint || parenMatch[2].trim();
      }

      const commaMatch = working.match(/^(.*?)[\s,;-]+(noun|verb|adjective|adverb|pronoun|preposition|conjunction|interjection|idiom|phrase)$/i);
      if (commaMatch) {
        working = commaMatch[1].trim();
        posHint = posHint || commaMatch[2].trim();
      }

      const partOfSpeech = canonicalizePartOfSpeech(posHint);
      const normalizedTerm = working.replace(/\s+/g, " ").trim();
      const variants = generateSearchVariants(normalizedTerm);
      const tokens = normalizedTerm.split(/\s+/).filter(Boolean);

      return {
        originalTerm: original,
        term: normalizedTerm,
        partOfSpeech,
        variants,
        tokens,
      };
    }

    function filterEntryByPartOfSpeech(entry, partOfSpeech) {
      if (!partOfSpeech || !entry || !Array.isArray(entry.meanings)) {
        return entry;
      }

      const filteredMeanings = entry.meanings
        .map((meaning) => {
          if (!meaning || !Array.isArray(meaning.definitions) || !meaning.definitions.length) {
            return null;
          }

          const meaningPos = canonicalizePartOfSpeech(meaning.partOfSpeech || "");

          if (meaningPos) {
            if (meaningPos !== partOfSpeech && !meaningPos.includes(partOfSpeech)) {
              return null;
            }
          } else {
            const rawPos = (meaning.partOfSpeech || "").toString().toLowerCase();
            if (rawPos && !rawPos.includes(partOfSpeech)) {
              return null;
            }
          }

          return {
            ...meaning,
            partOfSpeech: meaning.partOfSpeech,
            definitions: meaning.definitions,
          };
        })
        .filter(Boolean);

      if (!filteredMeanings.length) {
        return null;
      }

      return {
        ...entry,
        meanings: filteredMeanings,
      };
    }

    function getProviderCredentials() {
      return {};
    }

    function persistCredentials() {
      const username = usernameInput.value.trim();
      const password = passwordInput.value;
      if (!username && !password) {
        setSessionItem(SESSION_KEYS.credentials, null);
        return;
      }

      setSessionItem(
        SESSION_KEYS.credentials,
        JSON.stringify({ username, password })
      );
    }

    function persistDeckSelection() {
      const deck = deckSelect.value;
      if (deck) {
        setSessionItem(SESSION_KEYS.deck, deck);
      } else {
        setSessionItem(SESSION_KEYS.deck, null);
      }
    }

    function setStatus(message, type = "") {
      statusEl.textContent = message;
      statusEl.className = "status" + (type ? " " + type : "");
    }

    function parseTagsFromInput() {
      if (!tagsInput) {
        return [];
      }

      return tagsInput.value
        .split(",")
        .map((tag) => tag.trim())
        .filter(Boolean);
    }

    function updateLoadedNoteButtonState() {
      if (!updateCardBtn) {
        return;
      }

      const hasLoadedNote = Boolean(activeLoadedNote && activeLoadedNote.id);
      updateCardBtn.disabled = !hasLoadedNote;

      if (hasLoadedNote) {
        updateCardBtn.dataset.noteId = String(activeLoadedNote.id);
      } else {
        delete updateCardBtn.dataset.noteId;
      }
    }

    function setActiveLoadedNote(noteDetails) {
      activeLoadedNote = noteDetails || null;
      updateLoadedNoteButtonState();
    }

    function hideSetupNotice() {
      if (setupNotice) {
        setupNotice.classList.add("is-hidden");
      }
    }

    function showSetupNotice() {
      if (setupNotice) {
        setupNotice.classList.remove("is-hidden");
      }
    }

    let hasSuccessfulAnkiConnect =
      getSessionItem(SESSION_KEYS.setupNoticeDismissed) === "true";

    if (hasSuccessfulAnkiConnect) {
      hideSetupNotice();
    } else {
      showSetupNotice();
    }

    function markAnkiConnectSuccess() {
      if (hasSuccessfulAnkiConnect) {
        return;
      }
      hasSuccessfulAnkiConnect = true;
      hideSetupNotice();
      setSessionItem(SESSION_KEYS.setupNoticeDismissed, "true");
    }

    const savedCredentials = safeParseJSON(getSessionItem(SESSION_KEYS.credentials), {});
    if (savedCredentials?.username) {
      usernameInput.value = savedCredentials.username;
    }
    if (savedCredentials?.password) {
      passwordInput.value = savedCredentials.password;
    }

    [frontField, backField, exampleField, tagsInput]
      .filter(Boolean)
      .forEach((element) => {
        element.addEventListener("input", () => {
          if (element === frontField) {
            refreshMaskedWordField();
          }
          if (element?.tagName === "TEXTAREA") {
            adjustTextareaHeight(element);
          }
        });
        element.addEventListener("change", () => {
          if (element === frontField) {
            refreshMaskedWordField();
          }
          if (element?.tagName === "TEXTAREA") {
            adjustTextareaHeight(element);
          }
        });
      });

    [frontField, backField, exampleField].forEach((textarea) => {
      adjustTextareaHeight(textarea);
    });

    function handleModelNameInput(event) {
      userModifiedNoteType = true;
      if (event?.type === "change") {
        refreshModelFieldsForCurrentModel();
      }
    }

    modelNameInput.addEventListener("input", handleModelNameInput);
    modelNameInput.addEventListener("change", handleModelNameInput);

    function updateModelSuggestions(noteTypes) {
      if (!modelSuggestions) {
        return;
      }

      modelSuggestions.innerHTML = "";
      noteTypes.forEach((noteType) => {
        if (!noteType) {
          return;
        }
        const option = document.createElement("option");
        option.value = noteType;
        modelSuggestions.appendChild(option);
      });
    }

    deckSelect.addEventListener("change", () => {
      persistDeckSelection();
      userModifiedNoteType = false;
      const deckName = deckSelect.value;
      updateExistingDeckSelectOptions();
      if (deckName) {
        loadNoteTypesForDeck(deckName);
      } else {
        updateModelSuggestions([]);
      }
    });

    usernameInput.addEventListener("input", persistCredentials);
    passwordInput.addEventListener("input", persistCredentials);
    async function callAnkiConnect(action, params = {}) {
      let response;
      try {
        response = await fetch("http://127.0.0.1:8765", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ action, version: 6, params }),
        });
      } catch (networkError) {
        console.error(networkError);
        throw new Error(
          "Unable to reach AnkiConnect. Please ensure Anki is running and the AnkiConnect add-on is installed."
        );
      }

      if (!response.ok) {
        throw new Error(`AnkiConnect request failed: ${response.status}`);
      }

      const data = await response.json();
      if (data.error) {
        const originalErrorMessage = data.error;
        if (
          action === "sync" &&
          typeof originalErrorMessage === "string" &&
          /com\.google\.gson\.(JsonSyntaxException|stream\.MalformedJsonException)/.test(
            originalErrorMessage,
          )
        ) {
          throw new Error(
            "Sync failed because AnkiConnect's saved AnkiWeb session is no longer valid. " +
              "Please open Anki or AnkiDroid, perform a manual sync, and then try again.",
          );
        }

        throw new Error(originalErrorMessage);
      }

      markAnkiConnectSuccess();

      return data.result;
    }

    function textContainsTerm(text, term) {
      return text && term && text.toLowerCase().includes(term.toLowerCase());
    }

    function collectExampleStrings(example, results = []) {
      if (example === null || example === undefined) {
        return results;
      }

      const target = Array.isArray(results) ? results : [];
      const pushClean = (value) => {
        if (!value) {
          return;
        }
        const cleaned = stripHtml(value)
          .replace(/\s+/g, " ")
          .replace(/[\[\]]/g, "")
          .trim();
        if (cleaned) {
          target.push(cleaned);
        }
      };

      if (typeof example === "string") {
        pushClean(example);
        return target;
      }

      if (Array.isArray(example)) {
        example.forEach((entry) => collectExampleStrings(entry, target));
        return target;
      }

      if (typeof example === "object") {
        const keysToInspect = [
          "text",
          "example",
          "examples",
          "quote",
          "quotes",
          "quotation",
          "contents",
        ];
        keysToInspect.forEach((key) => {
          if (key in example) {
            collectExampleStrings(example[key], target);
          }
        });
      }

      return target;
    }

    function cleanExample(example) {
      const examples = collectExampleStrings(example);
      return examples.length ? examples[0] : "";
    }

    function normalizeDefinitions(definitions = []) {
      return definitions
        .map((item) => {
          if (!item) {
            return null;
          }

          const rawDefinition =
            typeof item === "string"
              ? item
              : item.definition || item.meaning || item.text || "";

          const definition = stripHtml(rawDefinition.toString()).trim();
          if (!definition) {
            return null;
          }

          let example = "";
          let examples = [];
          const exampleAccumulator = [];
          if (item && typeof item === "object") {
            const exampleSources = [item.example, item.examples, item.quotes, item.quote];
            exampleSources.forEach((source) => {
              collectExampleStrings(source, exampleAccumulator);
            });
            if (Array.isArray(item.examples) && item.examples.length) {
              collectExampleStrings(item.examples, exampleAccumulator);
            }
            if (!exampleAccumulator.length && item.example) {
              exampleAccumulator.push(cleanExample(item.example));
            }
            examples = Array.from(
              new Set(exampleAccumulator.filter((entry) => typeof entry === "string" && entry.trim()))
            );
            example = examples[0] || "";
          } else if (example) {
            examples = [example];
          }

          return { definition, example, examples };
        })
        .filter(Boolean);
    }

    function normalizeWiktionaryRestEntries(payload, term) {
      if (!payload || typeof payload !== "object") {
        return [];
      }

      let englishEntries = Array.isArray(payload.en) ? payload.en : [];

      if (!englishEntries.length && Array.isArray(payload.definitions)) {
        englishEntries = payload.definitions
          .filter((entry) => {
            const language = entry?.language || entry?.lang;
            return (
              !language ||
              (typeof language === "string" && language.toLowerCase().startsWith("en"))
            );
          })
          .map((entry) => {
            const definitionPool = Array.isArray(entry.definitions)
              ? entry.definitions
              : Array.isArray(entry.senses)
              ? entry.senses
              : Array.isArray(entry.text)
              ? entry.text
              : [entry];

            return {
              partOfSpeech:
                entry.partOfSpeech || entry.part_of_speech || entry.pos || entry.lexicalCategory || "",
              definitions: definitionPool,
            };
          });
      }

      if (!englishEntries.length && Array.isArray(payload.items)) {
        englishEntries = payload.items
          .filter((item) => {
            const language = item?.language || item?.lang;
            return (
              !language ||
              (typeof language === "string" && language.toLowerCase().startsWith("en"))
            );
          })
          .map((item) => {
            const senses = Array.isArray(item.senses)
              ? item.senses
              : Array.isArray(item.entries)
              ? item.entries
              : [];

            const definitionPool = [];
            senses.forEach((sense) => {
              if (Array.isArray(sense.definitions)) {
                definitionPool.push(...sense.definitions);
              } else {
                definitionPool.push(sense);
              }
            });

            if (!definitionPool.length && Array.isArray(item.definitions)) {
              definitionPool.push(...item.definitions);
            }

            if (!definitionPool.length && Array.isArray(item.text)) {
              definitionPool.push(...item.text);
            }

            if (!definitionPool.length) {
              definitionPool.push(item);
            }

            return {
              partOfSpeech: item.partOfSpeech || item.pos || item.lexicalCategory || "",
              definitions: definitionPool,
            };
          });
      }

      if (!englishEntries.length) {
        return [];
      }

      const meanings = englishEntries
        .map((item) => {
          const definitionList = [];

          if (Array.isArray(item.definitions)) {
            item.definitions.forEach((definitionEntry) => {
              if (!definitionEntry) {
                return;
              }

              if (typeof definitionEntry === "string") {
                definitionList.push({ definition: definitionEntry });
                return;
              }

              const entryDefinition =
                definitionEntry.definition ||
                definitionEntry.meaning ||
                (Array.isArray(definitionEntry.glosses)
                  ? definitionEntry.glosses[0]
                  : definitionEntry.text || "");

              const entryExample = cleanExample([
                definitionEntry.example,
                definitionEntry.examples,
                definitionEntry.quotes,
                definitionEntry.quote,
              ]);

              definitionList.push({
                definition: entryDefinition,
                example: entryExample,
              });
            });
          }

          if (!definitionList.length && Array.isArray(item.glosses)) {
            item.glosses.forEach((gloss) => {
              if (gloss) {
                definitionList.push({ definition: gloss });
              }
            });
          }

          if (!definitionList.length && Array.isArray(item.text)) {
            item.text.forEach((textEntry) => {
              if (!textEntry) {
                return;
              }
              if (typeof textEntry === "string") {
                definitionList.push({ definition: textEntry });
              } else {
                const exampleSources = [
                  textEntry.example,
                  textEntry.examples,
                  textEntry.quotes,
                  textEntry.quote,
                ];
                definitionList.push({
                  definition:
                    textEntry.definition ||
                    textEntry.meaning ||
                    textEntry.text ||
                    "",
                  example: cleanExample(exampleSources),
                  examples: collectExampleStrings(exampleSources),
                });
              }
            });
          }

          const normalizedDefinitions = normalizeDefinitions(definitionList);
          if (!normalizedDefinitions.length) {
            return null;
          }

          return {
            partOfSpeech: item.partOfSpeech || "Definition",
            definitions: normalizedDefinitions,
          };
        })
        .filter(Boolean);

      if (!meanings.length) {
        return [];
      }

      return [
        {
          word: term,
          source: "Wiktionary",
          meanings,
        },
      ];
    }

    function parseWiktionaryHtmlToEntries(html, term) {
      if (!html || typeof DOMParser === "undefined") {
        return [];
      }

      const parser = new DOMParser();
      const doc = parser.parseFromString(html, "text/html");
      if (!doc) {
        return [];
      }

      const englishHeader = Array.from(doc.querySelectorAll("h2")).find((header) => {
        const headline = header.querySelector(".mw-headline");
        return headline && headline.textContent?.trim().toLowerCase() === "english";
      });

      if (!englishHeader) {
        return [];
      }

      const sections = [];
      let currentHeading = "";
      let pendingDefinitions = [];

      const flushSection = () => {
        if (!pendingDefinitions.length) {
          return;
        }
        const normalized = normalizeDefinitions(pendingDefinitions);
        pendingDefinitions = [];
        if (!normalized.length) {
          return;
        }
        const canonical = canonicalizePartOfSpeech(currentHeading);
        const label = canonical
          ? canonical.charAt(0).toUpperCase() + canonical.slice(1)
          : currentHeading || "Definition";
        sections.push({
          partOfSpeech: label,
          definitions: normalized,
        });
      };

      let node = englishHeader.nextElementSibling;
      while (node && node.tagName !== "H2") {
        if (/^H[3-4]$/.test(node.tagName)) {
          flushSection();
          const headline = node.querySelector(".mw-headline");
          currentHeading = (headline ? headline.textContent : node.textContent || "").trim();
        } else if (node.tagName === "OL") {
          const items = Array.from(node.querySelectorAll(":scope > li"));
          items.forEach((item) => {
            const clone = item.cloneNode(true);
            clone.querySelectorAll("ol, ul, dl, table, div").forEach((child) => child.remove());
            const definitionText = clone.textContent
              .replace(/\s+/g, " ")
              .replace(/\[[^\]]*\]/g, "")
              .trim();
            if (!definitionText) {
              return;
            }
            const examples = Array.from(item.querySelectorAll("ul li"))
              .map((exampleNode) =>
                exampleNode.textContent
                  .replace(/\s+/g, " ")
                  .replace(/\[[^\]]*\]/g, "")
                  .trim()
              )
              .filter(Boolean);
            pendingDefinitions.push({
              definition: definitionText,
              example: examples[0] || "",
              examples,
            });
          });
        }
        node = node.nextElementSibling;
      }

      flushSection();

      if (!sections.length) {
        return [];
      }

      return [
        {
          word: term,
          source: "Wiktionary",
          meanings: sections,
        },
      ];
    }

    async function fetchWiktionaryHtmlEntries(term) {
      const url =
        `https://en.wiktionary.org/w/api.php?action=parse&page=${encodeURIComponent(term)}` +
        "&prop=text&format=json&formatversion=2&origin=*";

      let response;
      try {
        response = await fetch(url, {
          headers: { Accept: "application/json" },
        });
      } catch (networkError) {
        throw new Error("Wiktionary lookup failed (network error)");
      }

      if (response.status === 404) {
        return [];
      }

      if (!response.ok) {
        throw new Error(`Wiktionary lookup failed (status ${response.status})`);
      }

      const data = await response.json();
      if (data?.error?.code === "missingtitle") {
        return [];
      }

      const html = data?.parse?.text;
      if (!html) {
        return [];
      }

      return parseWiktionaryHtmlToEntries(html, term);
    }

    async function fetchWiktionaryRestEntries(term, parsedTerm) {
      const lookup = parsedTerm?.term || term;
      if (!lookup) {
        return [];
      }
      const endpoints = [
        `https://en.wiktionary.org/api/rest_v1/page/definition/${encodeURIComponent(lookup)}?redirect=true&origin=*`,
        `https://en.wiktionary.org/api/rest_v1/page/definition/en/${encodeURIComponent(lookup)}?redirect=true&origin=*`,
      ];

      for (let index = 0; index < endpoints.length; index += 1) {
        const endpoint = endpoints[index];
        try {
          const response = await fetch(endpoint, {
            headers: { Accept: "application/json" },
          });

          if (response.status === 404) {
            continue;
          }

          if (!response.ok) {
            throw new Error(`Wiktionary lookup failed (status ${response.status})`);
          }

          const data = await response.json();
          const normalized = normalizeWiktionaryRestEntries(data, lookup);
          if (normalized.length) {
            return normalized;
          }
        } catch (error) {
          if (index === endpoints.length - 1) {
            console.warn("Primary Wiktionary lookup failed", error);
          } else {
            continue;
          }
        }
      }

      return fetchWiktionaryHtmlEntries(lookup);
    }

    const dictionaryProviders = {
      wiktionary: {
        id: "wiktionary",
        label: "Wiktionary",
        fetchEntries: fetchWiktionaryRestEntries,
        supportsEmbeddedSearch: false,
        defaultEnabled: true,
        type: "definition",
      },
    };

    initializeSidebarToggles();

    function escapeRegExp(value) {
      if (value === null || value === undefined) {
        return "";
      }

      return String(value).replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }

    function escapeDeckNameForQuery(deckName) {
      if (!deckName) {
        return "";
      }

      return deckName.replace(/\\/g, "\\\\").replace(/"/g, '\\"');
    }

    function escapeSearchTerm(term) {
      if (!term) {
        return "";
      }

      return term.replace(/"/g, '\\"').trim();
    }

    function stripHtml(value) {
      if (!value) {
        return "";
      }

      htmlParser.innerHTML = value;
      const text = htmlParser.textContent || htmlParser.innerText || "";
      htmlParser.textContent = "";
      return text.trim();
    }

    function normalizeFieldIdentifier(value) {
      return (value || "").replace(/\s+/g, "").toLowerCase();
    }

    function escapeForAnkiQuery(value) {
      if (!value) {
        return "";
      }

      return value.replace(/(["\\])/g, "\\$1");
    }

    function escapeFieldNameForAnkiQuery(fieldName) {
      if (!fieldName) {
        return "";
      }

      const escaped = escapeForAnkiQuery(fieldName);
      return /\s/.test(fieldName) ? `"${escaped}"` : escaped;
    }

    async function findDuplicateNoteId({ modelName, wordFieldName, wordValue }) {
      const candidates = Array.from(
        new Set(
          [wordValue, stripHtml(wordValue)]
            .map((candidate) => (candidate || "").trim())
            .filter(Boolean)
        )
      );

      if (!candidates.length) {
        return null;
      }

      const escapedModel = escapeForAnkiQuery(modelName || "");
      const fieldNameQuery = escapeFieldNameForAnkiQuery(wordFieldName || "");
      const seenQueries = new Set();

      const tryQueries = async (queries) => {
        for (const query of queries) {
          if (!query || seenQueries.has(query)) {
            continue;
          }
          seenQueries.add(query);
          try {
            const noteIds = await callAnkiConnect("findNotes", { query });
            if (Array.isArray(noteIds) && noteIds.length) {
              return noteIds[0];
            }
          } catch (queryError) {
            console.warn(`findNotes failed for query "${query}"`, queryError);
          }
        }
        return null;
      };

      const primaryQueries = candidates.map((candidate) => {
        const escapedValue = escapeForAnkiQuery(candidate);
        const parts = [];
        if (escapedModel) {
          parts.push(`note:"${escapedModel}"`);
        }
        if (fieldNameQuery) {
          parts.push(`${fieldNameQuery}:"${escapedValue}"`);
        } else {
          parts.push(`"${escapedValue}"`);
        }
        return parts.join(" ").trim();
      });

      const primaryMatch = await tryQueries(primaryQueries);
      if (primaryMatch) {
        return primaryMatch;
      }

      if (fieldNameQuery) {
        const fallbackQueries = candidates.map((candidate) => {
          const escapedValue = escapeForAnkiQuery(candidate);
          const parts = [];
          if (escapedModel) {
            parts.push(`note:"${escapedModel}"`);
          }
          parts.push(`"${escapedValue}"`);
          return parts.join(" ").trim();
        });

        const fallbackMatch = await tryQueries(fallbackQueries);
        if (fallbackMatch) {
          return fallbackMatch;
        }
      }

      const globalQueries = candidates.map((candidate) => {
        const escapedValue = escapeForAnkiQuery(candidate);
        return `"${escapedValue}"`;
      });

      return tryQueries(globalQueries);
    }

    function createFieldEditorId(fieldName) {
      const slug = (fieldName || "")
        .toString()
        .trim()
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, "-")
        .replace(/^-+|-+$/g, "");
      const fallback = Math.random().toString(36).slice(2, 10);
      return `additional-${slug || fallback}`;
    }

    function computeFieldRoleMap(fieldNames = []) {
      const normalizedEntries = fieldNames
        .filter((name) => typeof name === "string" && name.trim())
        .map((name, index) => ({
          name,
          index,
          lower: name.toLowerCase(),
          compact: normalizeFieldIdentifier(name),
        }));

      const used = new Set();
      const roleMap = {
        word: null,
        definition: null,
        example: null,
        masked: null,
      };

      const findByAliases = (aliases = [], { allowPartial = true } = {}) => {
        for (const alias of aliases) {
          const aliasLower = alias.toLowerCase();
          const aliasCompact = normalizeFieldIdentifier(alias);
          for (const entry of normalizedEntries) {
            if (used.has(entry.name)) {
              continue;
            }
            if (entry.lower === aliasLower || entry.compact === aliasCompact) {
              used.add(entry.name);
              return entry.name;
            }
          }
        }

        if (!allowPartial) {
          return null;
        }

        for (const alias of aliases) {
          const aliasLower = alias.toLowerCase();
          const aliasCompact = normalizeFieldIdentifier(alias);
          for (const entry of normalizedEntries) {
            if (used.has(entry.name)) {
              continue;
            }
            if (
              entry.lower.includes(aliasLower) ||
              entry.compact.includes(aliasCompact)
            ) {
              used.add(entry.name);
              return entry.name;
            }
          }
        }

        return null;
      };

      const maskedField = findByAliases(MASK_FIELD_ALIASES);
      if (maskedField) {
        roleMap.masked = maskedField;
      }

      const wordField = findByAliases(FIELD_ROLE_ALIASES.word);
      if (wordField) {
        roleMap.word = wordField;
      }

      const definitionField = findByAliases(FIELD_ROLE_ALIASES.definition);
      if (definitionField) {
        roleMap.definition = definitionField;
      }

      const exampleField = findByAliases(FIELD_ROLE_ALIASES.example);
      if (exampleField) {
        roleMap.example = exampleField;
      }

      if (!roleMap.word && normalizedEntries.length) {
        const fallback = normalizedEntries.find((entry) => !used.has(entry.name));
        if (fallback) {
          roleMap.word = fallback.name;
          used.add(fallback.name);
        }
      }

      if (!roleMap.definition && normalizedEntries.length) {
        const fallback = normalizedEntries.find((entry) => !used.has(entry.name));
        if (fallback) {
          roleMap.definition = fallback.name;
          used.add(fallback.name);
        }
      }

      if (!roleMap.example && normalizedEntries.length > 2) {
        const fallback = normalizedEntries
          .slice()
          .reverse()
          .find((entry) => !used.has(entry.name));
        if (fallback) {
          roleMap.example = fallback.name;
          used.add(fallback.name);
        }
      }

      return roleMap;
    }

    function deriveMaskedWordValue(wordValue) {
      const plain = stripHtml(wordValue || "");
      if (!plain) {
        return "";
      }
      return maskTargetInText(plain, plain);
    }

    function setMaskedEditorUserEdited(editor, userEdited) {
      if (!editor) {
        return;
      }
      editor.dataset.userEdited = userEdited ? "true" : "false";
    }

    function isMaskedEditorUserEdited(editor) {
      return editor?.dataset.userEdited === "true";
    }

    function initializeMaskedFieldEditor(editor, { userEditedOnInit } = {}) {
      if (!editor) {
        return;
      }

      const updateUserEditedState = () => {
        const trimmed = editor.value.trim();
        setMaskedEditorUserEdited(editor, Boolean(trimmed));
      };

      if (editor.dataset.maskedInitialized !== "true") {
        editor.addEventListener("input", () => {
          updateUserEditedState();
          adjustTextareaHeight(editor);
        });
        editor.dataset.maskedInitialized = "true";
      }

      if (userEditedOnInit === undefined) {
        updateUserEditedState();
      } else {
        setMaskedEditorUserEdited(editor, userEditedOnInit);
      }

      adjustTextareaHeight(editor);
    }

    function setMaskedEditorAutoValue(editor, value) {
      if (!editor) {
        return;
      }
      if (editor.value !== value) {
        editor.value = value;
      }
      setMaskedEditorUserEdited(editor, false);
      adjustTextareaHeight(editor);
    }

    function updateNoteDetailsDisplay(noteDetails) {
      if (!noteDetails) {
        return;
      }

      const orderedFieldNames = Array.isArray(noteDetails.orderedFields)
        ? noteDetails.orderedFields.map((field) => field.name)
        : [];
      const fields = noteDetails.fields || {};
      const roleMap = noteDetails.roleMap || {};

      const wordFieldName =
        roleMap.word || orderedFieldNames[0] || Object.keys(fields)[0] || null;
      const definitionFieldName =
        roleMap.definition ||
        orderedFieldNames.find((name) => name && name !== wordFieldName) ||
        null;
      const exampleFieldName = roleMap.example || null;

      const frontValue = wordFieldName ? fields[wordFieldName] || "" : "";
      const backValue = definitionFieldName ? fields[definitionFieldName] || "" : "";
      const exampleValue = exampleFieldName ? fields[exampleFieldName] || "" : "";

      noteDetails.display = {
        frontText: stripHtml(frontValue),
        backText: stripHtml(backValue),
        exampleText: stripHtml(exampleValue),
      };
    }

    function refreshActiveLoadedNoteSnapshot(fields, { modelName, tags } = {}) {
      if (!activeLoadedNote) {
        return;
      }

      if (fields) {
        const updatedFields = { ...fields };
        activeLoadedNote.fields = updatedFields;
        if (Array.isArray(activeLoadedNote.orderedFields)) {
          activeLoadedNote.orderedFields.forEach((entry) => {
            if (!entry || !entry.name) {
              return;
            }
            entry.value = updatedFields[entry.name] || "";
          });
        }
      }

      if (modelName) {
        activeLoadedNote.modelName = modelName;
      }

      if (Array.isArray(tags)) {
        activeLoadedNote.tags = tags.slice();
      }

      activeLoadedNote.roleMap = activeModelFieldMetadata.roleMap;
      updateNoteDetailsDisplay(activeLoadedNote);
    }

    function getActiveWordFieldName(metadata = activeModelFieldMetadata) {
      if (!metadata) {
        return null;
      }
      return (
        metadata.roleMap?.word ||
        (Array.isArray(metadata.orderedFieldNames)
          ? metadata.orderedFieldNames[0]
          : null)
      );
    }

    function refreshMaskedWordField({ force = false } = {}) {
      const maskedFieldName = activeModelFieldMetadata.roleMap?.masked;
      const wordFieldName = getActiveWordFieldName();
      if (!maskedFieldName || !wordFieldName) {
        return;
      }

      const wordEditor = fieldEditors.get(wordFieldName);
      const maskedEditor = fieldEditors.get(maskedFieldName);
      if (!wordEditor || !maskedEditor) {
        return;
      }

      const trimmedMaskedValue = maskedEditor.value.trim();
      if (!force && isMaskedEditorUserEdited(maskedEditor) && trimmedMaskedValue) {
        return;
      }

      const derivedValue = deriveMaskedWordValue(wordEditor.value);
      setMaskedEditorAutoValue(maskedEditor, derivedValue);
    }

    function applyModelFieldMetadata(
      modelName,
      orderedFieldNames = [],
      roleMapOverride = null
    ) {
      const normalizedFieldNames = Array.isArray(orderedFieldNames)
        ? orderedFieldNames.filter((name) => typeof name === "string" && name.trim())
        : [];
      const roleMap = roleMapOverride || computeFieldRoleMap(normalizedFieldNames);

      const preservedValues = new Map();
      fieldEditors.forEach((element, fieldName) => {
        if (fieldName && element) {
          preservedValues.set(fieldName, element.value);
        }
      });

      fieldEditors.clear();
      additionalFieldEditors.clear();

      if (additionalFieldsContainer) {
        additionalFieldsContainer.innerHTML = "";
        additionalFieldsContainer.hidden = true;
      }

      if (maskedFieldContainer) {
        maskedFieldContainer.innerHTML = "";
        maskedFieldContainer.hidden = true;
      }

      const assignedFields = new Set();

      const assignPrimaryEditor = (element, defaultLabel, fieldName) => {
        if (!element) {
          return;
        }

        const previousValue =
          fieldName && preservedValues.has(fieldName) ? preservedValues.get(fieldName) : "";
        element.dataset.fieldName = fieldName || "";
        element.value = fieldName ? previousValue : "";
        const labelText = fieldName || defaultLabel;
        if (labelText) {
          element.placeholder = labelText;
          element.setAttribute("aria-label", labelText);
          element.title = labelText;
        } else {
          element.removeAttribute("placeholder");
          element.removeAttribute("aria-label");
          element.removeAttribute("title");
        }
        if (element.tagName === "TEXTAREA") {
          adjustTextareaHeight(element);
        }

        if (fieldName) {
          fieldEditors.set(fieldName, element);
          assignedFields.add(fieldName);
        }
      };

      const wordFieldName = roleMap.word || normalizedFieldNames[0] || null;
      const definitionFieldName =
        roleMap.definition ||
        normalizedFieldNames.find((name) => name && name !== wordFieldName) ||
        null;
      const exampleFieldName = roleMap.example || null;
      const maskedFieldName = roleMap.masked || null;

      assignPrimaryEditor(frontField, DEFAULT_FIELD_PLACEHOLDERS.front, wordFieldName);
      assignPrimaryEditor(backField, DEFAULT_FIELD_PLACEHOLDERS.back, definitionFieldName);

      if (exampleFieldWrapper) {
        exampleFieldWrapper.hidden = !exampleFieldName;
      }
      assignPrimaryEditor(
        exampleField,
        DEFAULT_FIELD_PLACEHOLDERS.example,
        exampleFieldName
      );
      if (!exampleFieldName && exampleField) {
        exampleField.value = "";
        adjustTextareaHeight(exampleField);
      }

      if (maskedFieldName && maskedFieldContainer) {
        const previousValue = preservedValues.has(maskedFieldName)
          ? preservedValues.get(maskedFieldName)
          : "";
        const editorId = createFieldEditorId(maskedFieldName);
        const textarea = document.createElement("textarea");
        textarea.id = editorId;
        textarea.dataset.fieldName = maskedFieldName;
        textarea.value = previousValue;
        const labelText = maskedFieldName || "W•••";
        textarea.placeholder = labelText;
        textarea.setAttribute("aria-label", labelText);
        textarea.title = labelText;
        initializeMaskedFieldEditor(textarea, {
          userEditedOnInit: Boolean(previousValue.trim()),
        });

        maskedFieldContainer.appendChild(textarea);
        maskedFieldContainer.hidden = false;

        fieldEditors.set(maskedFieldName, textarea);
        assignedFields.add(maskedFieldName);
      }

      if (additionalFieldsContainer) {
        normalizedFieldNames.forEach((fieldName) => {
          if (!fieldName || assignedFields.has(fieldName)) {
            return;
          }

          const wrapper = document.createElement("div");
          wrapper.className = "additional-field";

          const label = document.createElement("label");
          const editorId = createFieldEditorId(fieldName);
          label.htmlFor = editorId;
          label.textContent = fieldName;

          const textarea = document.createElement("textarea");
          textarea.id = editorId;
          textarea.dataset.fieldName = fieldName;
          textarea.value = preservedValues.get(fieldName) ?? "";
          if (fieldName === maskedFieldName) {
            initializeMaskedFieldEditor(textarea, {
              userEditedOnInit: Boolean((textarea.value || "").trim()),
            });
          } else {
            textarea.addEventListener("input", () => adjustTextareaHeight(textarea));
            adjustTextareaHeight(textarea);
          }

          wrapper.appendChild(label);
          wrapper.appendChild(textarea);
          additionalFieldsContainer.appendChild(wrapper);

          fieldEditors.set(fieldName, textarea);
          additionalFieldEditors.set(fieldName, { element: textarea, label, wrapper });
        });

        additionalFieldsContainer.hidden = additionalFieldEditors.size === 0;
      }

      activeModelFieldMetadata = {
        modelName,
        orderedFieldNames: normalizedFieldNames,
        roleMap: {
          word: wordFieldName,
          definition: definitionFieldName,
          example: exampleFieldName,
          masked: maskedFieldName,
        },
      };

      if (modelName && normalizedFieldNames.length) {
        modelFieldCache.set(modelName, {
          orderedFieldNames: normalizedFieldNames,
          roleMap: activeModelFieldMetadata.roleMap,
        });
      }

      refreshMaskedWordField();
      fieldEditors.forEach((editor, fieldName) => {
        if (!editor) {
          return;
        }
        if (fieldName === maskedFieldName && !isMaskedEditorUserEdited(editor)) {
          setMaskedEditorAutoValue(editor, editor.value || "");
        } else {
          adjustTextareaHeight(editor);
        }
      });
    }

    async function ensureModelFieldMetadata(modelName) {
      if (!modelName) {
        return { orderedFieldNames: [], roleMap: {} };
      }

      const cached = modelFieldCache.get(modelName);
      if (cached && Array.isArray(cached.orderedFieldNames) && cached.orderedFieldNames.length) {
        return cached;
      }

      if (pendingModelFieldRequests.has(modelName)) {
        return pendingModelFieldRequests.get(modelName);
      }

      const requestPromise = (async () => {
        let orderedFieldNames = [];

        try {
          const fieldConfig = await callAnkiConnect("modelFieldNamesAndConfig", { modelName });
          if (fieldConfig && Array.isArray(fieldConfig.fields)) {
            orderedFieldNames = fieldConfig.fields
              .slice()
              .sort((a, b) => (a?.ord ?? 0) - (b?.ord ?? 0))
              .map((field) => field.name)
              .filter(Boolean);
          }
        } catch (error) {
          console.warn(`modelFieldNamesAndConfig failed for "${modelName}"`, error);
        }

        if (!orderedFieldNames.length) {
          const fallbackNames = await callAnkiConnect("modelFieldNames", { modelName });
          if (Array.isArray(fallbackNames)) {
            orderedFieldNames = fallbackNames.filter(Boolean);
          }
        }

        if (!orderedFieldNames.length) {
          throw new Error(`No fields available for "${modelName}".`);
        }

        const metadata = {
          orderedFieldNames,
          roleMap: computeFieldRoleMap(orderedFieldNames),
        };

        modelFieldCache.set(modelName, metadata);
        return metadata;
      })();

      pendingModelFieldRequests.set(modelName, requestPromise);

      try {
        return await requestPromise;
      } finally {
        pendingModelFieldRequests.delete(modelName);
      }
    }

    async function refreshModelFieldsForCurrentModel({ modelName } = {}) {
      const resolvedModelName = modelName || modelNameInput.value.trim() || DEFAULT_MODEL_NAME;
      const requestId = ++modelFieldLoadToken;

      try {
        const metadata = await ensureModelFieldMetadata(resolvedModelName);
        if (requestId !== modelFieldLoadToken) {
          return metadata;
        }

        applyModelFieldMetadata(
          resolvedModelName,
          metadata.orderedFieldNames,
          metadata.roleMap
        );

        return metadata;
      } catch (error) {
        if (requestId !== modelFieldLoadToken) {
          return null;
        }

        console.warn(`Failed to load field metadata for "${resolvedModelName}"`, error);
        applyModelFieldMetadata(resolvedModelName, [], null);
        return null;
      }
    }

    function createNoteDetails(note, deckName) {
      if (!note || !note.noteId || !note.fields) {
        return null;
      }

      const fieldEntries = Object.entries(note.fields)
        .map(([name, payload], index) => ({
          name,
          value:
            payload && typeof payload.value === "string" ? payload.value : "",
          order: typeof payload?.order === "number" ? payload.order : index,
        }))
        .filter((entry) => entry.name);

      if (!fieldEntries.length) {
        return null;
      }

      fieldEntries.sort((a, b) => (a.order ?? 0) - (b.order ?? 0));

      const orderedFields = fieldEntries.map((entry) => ({ ...entry }));
      const fields = {};
      orderedFields.forEach((entry) => {
        fields[entry.name] = entry.value;
      });

      const fieldNames = orderedFields.map((entry) => entry.name);
      const roleMap = computeFieldRoleMap(fieldNames);

      const noteDetails = {
        id: note.noteId,
        deckName,
        modelName: note.modelName || "",
        tags: Array.isArray(note.tags) ? note.tags : [],
        orderedFields,
        fields,
        roleMap,
        display: {
          frontText: "",
          backText: "",
          exampleText: "",
        },
      };

      updateNoteDetailsDisplay(noteDetails);

      return noteDetails;
    }

    function cloneNoteDetails(noteDetails) {
      if (!noteDetails) {
        return null;
      }

      const cloned = {
        id: noteDetails.id,
        deckName: noteDetails.deckName,
        modelName: noteDetails.modelName,
        tags: Array.isArray(noteDetails.tags) ? noteDetails.tags.slice() : [],
        orderedFields: Array.isArray(noteDetails.orderedFields)
          ? noteDetails.orderedFields.map((entry) => ({ ...entry }))
          : [],
        fields: { ...(noteDetails.fields || {}) },
        roleMap: { ...(noteDetails.roleMap || {}) },
        display: noteDetails.display ? { ...noteDetails.display } : {},
      };

      return cloned;
    }

    function mapDeckNotesToEntries(notesInfo, deckName, lookupContext = {}) {
      if (!Array.isArray(notesInfo)) {
        return [];
      }

      const context =
        typeof lookupContext === "object" && lookupContext !== null
          ? lookupContext
          : { searchTerm: lookupContext, sanitizedTerm: lookupContext };

      const termCandidates = [];
      if (context.searchTerm) {
        termCandidates.push(context.searchTerm);
      }
      if (context.originalTerm) {
        termCandidates.push(context.originalTerm);
      }
      if (context.term) {
        termCandidates.push(context.term);
      }
      if (context.sanitizedTerm) {
        termCandidates.push(context.sanitizedTerm);
      }

      const fallbackTermRaw =
        (typeof context.searchTerm === "string" && context.searchTerm) ||
        (typeof context.originalTerm === "string" && context.originalTerm) ||
        (typeof context.term === "string" && context.term) ||
        (typeof context.sanitizedTerm === "string" && context.sanitizedTerm) ||
        "";

      const fallbackTerm = fallbackTermRaw.replace(/\\(.)/g, "$1");

      const normalizedTargets = Array.from(
        new Set(
          termCandidates
            .map((candidate) => {
              if (typeof candidate !== "string") {
                return "";
              }
              const unescaped = candidate.replace(/\\(.)/g, "$1");
              return stripHtml(unescaped).trim().toLowerCase();
            })
            .filter(Boolean)
        )
      );

      return notesInfo
        .map((note) => {
          const noteDetails = createNoteDetails(note, deckName);
          if (!noteDetails) {
            return null;
          }

          const definitionText = noteDetails.display.backText || "(Back field is empty)";
          const headwordText = noteDetails.display.frontText || "";
          const normalizedHeadword = headwordText.trim().toLowerCase();
          const headwordMatch =
            normalizedHeadword && normalizedTargets.length
              ? normalizedTargets.includes(normalizedHeadword)
              : false;

          return {
            uniqueKey: `note-${noteDetails.id}`,
            word: noteDetails.display.frontText || fallbackTerm,
            source: deckName,
            deckName,
            isExistingNote: true,
            noteDetails,
            headwordMatch,
            meanings: [
              {
                partOfSpeech: noteDetails.modelName || "Card content",
                definitions: [
                  {
                    definition: definitionText,
                    example: noteDetails.display.exampleText || "",
                  },
                ],
              },
            ],
            note: `Saved note #${noteDetails.id} in "${deckName}"`,
          };
        })
        .filter(Boolean);
    }

    function determineDeckSelectionLabel() {
      if (!existingDeckSelect) {
        return deckSelect.value || "Selected deck";
      }

      const selection = existingDeckSelect.value || "current";
      const currentDeckName = deckSelect.value;

      if (selection === "current") {
        return currentDeckName ? `Current deck (${currentDeckName})` : "Current deck";
      }

      if (selection === "__all__") {
        return "All decks";
      }

      return selection;
    }

    function updateExistingDeckSelectOptions() {
      if (!existingDeckSelect) {
        return;
      }

      const previousValue = existingDeckSelect.value || "current";
      const currentDeckName = deckSelect.value;
      existingDeckSelect.innerHTML = "";

      const makeOption = (value, label) => {
        const option = document.createElement("option");
        option.value = value;
        option.textContent = label;
        return option;
      };

      const currentLabel = currentDeckName
        ? `Current deck (${currentDeckName})`
        : "Current deck";
      existingDeckSelect.appendChild(makeOption("current", currentLabel));

      const otherDecks = Array.isArray(availableDeckNames)
        ? availableDeckNames.filter((deck) => deck && deck !== currentDeckName)
        : [];

      if (otherDecks.length > 1) {
        existingDeckSelect.appendChild(makeOption("__all__", "All decks"));
      }

      otherDecks.forEach((deckName) => {
        existingDeckSelect.appendChild(makeOption(deckName, deckName));
      });

      const availableValues = Array.from(existingDeckSelect.options).map(
        (option) => option.value
      );
      if (availableValues.includes(previousValue)) {
        existingDeckSelect.value = previousValue;
      } else {
        existingDeckSelect.value = "current";
      }
    }

    async function findDeckEntriesForSelection(term) {
      const selection = existingDeckSelect ? existingDeckSelect.value || "current" : "current";
      const currentDeckName = deckSelect.value;

      if (selection === "current" || !existingDeckSelect) {
        if (!currentDeckName) {
          return [];
        }
        const summary = await findDeckEntries(term, currentDeckName);
        return [summary];
      }

      if (selection === "__all__") {
        const decksToSearch = Array.isArray(availableDeckNames)
          ? availableDeckNames.filter((deck) => deck && deck !== currentDeckName)
          : [];
        const uniqueDecks = Array.from(new Set(decksToSearch));
        if (!uniqueDecks.length) {
          return [];
        }
        const summaries = await Promise.all(
          uniqueDecks.map((deckName) => findDeckEntries(term, deckName))
        );
        return summaries;
      }

      const summary = await findDeckEntries(term, selection);
      return [summary];
    }

    async function findDeckEntries(term, deckName) {
      if (!deckName) {
        return {
          deckName: "",
          entries: [],
          totalCount: 0,
          shownCount: 0,
          truncated: false,
          error: "",
        };
      }

      const sanitizedDeckName = escapeDeckNameForQuery(deckName);
      const sanitizedTerm = escapeSearchTerm(term);
      const queryParts = [`deck:"${sanitizedDeckName}"`];
      if (sanitizedTerm) {
        queryParts.push(`"${sanitizedTerm}"`);
      }

      const query = queryParts.join(" ");

      try {
        const noteIds = await callAnkiConnect("findNotes", { query });
        if (!Array.isArray(noteIds) || !noteIds.length) {
          return {
            deckName,
            entries: [],
            totalCount: 0,
            shownCount: 0,
            truncated: false,
            error: "",
          };
        }

        const limitedNoteIds = noteIds.slice(0, NOTE_SEARCH_LIMIT);
        const notesInfo = await callAnkiConnect("notesInfo", { notes: limitedNoteIds });
        const entries = mapDeckNotesToEntries(notesInfo, deckName, {
          searchTerm: term,
          sanitizedTerm: sanitizedTerm || term,
        });

        return {
          deckName,
          entries,
          totalCount: noteIds.length,
          shownCount: entries.length,
          truncated: noteIds.length > limitedNoteIds.length,
          error: "",
        };
      } catch (error) {
        console.warn(`Deck lookup failed for "${deckName}"`, error);
        return {
          deckName,
          entries: [],
          totalCount: 0,
          shownCount: 0,
          truncated: false,
          error: error?.message || "Deck lookup failed.",
        };
      }
    }

    function applyNoteToEditor(noteDetails) {
      if (!noteDetails) {
        return;
      }

      const modelName =
        noteDetails.modelName || modelNameInput.value.trim() || DEFAULT_MODEL_NAME;

      if (modelName) {
        modelNameInput.value = modelName;
        userModifiedNoteType = false;
      }

      const fieldNames = Array.isArray(noteDetails.orderedFields)
        ? noteDetails.orderedFields.map((field) => field.name)
        : Object.keys(noteDetails.fields || {});

      applyModelFieldMetadata(modelName, fieldNames, noteDetails.roleMap);

      const fields = noteDetails.fields || {};
      const maskedFieldName = activeModelFieldMetadata.roleMap?.masked;
      fieldEditors.forEach((editor, fieldName) => {
        if (!editor) {
          return;
        }
        editor.value = fields[fieldName] || "";
        if (fieldName === maskedFieldName) {
          initializeMaskedFieldEditor(editor, {
            userEditedOnInit: Boolean((editor.value || "").trim()),
          });
        } else {
          adjustTextareaHeight(editor);
        }
      });

      noteDetails.modelName = modelName;
      noteDetails.roleMap = activeModelFieldMetadata.roleMap;

      if (Array.isArray(noteDetails.orderedFields)) {
        noteDetails.orderedFields.forEach((entry) => {
          if (!entry || !entry.name) {
            return;
          }
          const editor = fieldEditors.get(entry.name);
          if (editor) {
            entry.value = editor.value;
            fields[entry.name] = editor.value;
          }
        });
      }

      refreshMaskedWordField();
      if (maskedFieldName) {
        const maskedEditor = fieldEditors.get(maskedFieldName);
        if (maskedEditor) {
          fields[maskedFieldName] = maskedEditor.value;
        }
      }

      noteDetails.fields = fields;

      updateNoteDetailsDisplay(noteDetails);

      if (tagsInput) {
        if (Array.isArray(noteDetails.tags)) {
          tagsInput.value = noteDetails.tags.join(", ");
        } else {
          tagsInput.value = "";
        }
      }

      return noteDetails;

    }

    function createMaskFromMatch(match) {
      if (!match) {
        return match;
      }

      const characters = Array.from(match);
      const masked = [];
      let preservedCount = 0;
      const maskableCharacters = characters.filter((char) => !/\s/.test(char));
      const keep = maskableCharacters.length >= 6 ? 2 : 1;

      characters.forEach((char) => {
        if (/\s/.test(char)) {
          masked.push(char);
        } else if (preservedCount < keep) {
          masked.push(char);
          preservedCount += 1;
        } else {
          masked.push("•");
        }
      });

      return masked.join("");
    }

    function maskTargetInText(text, target) {
      if (!text || !target) {
        return text;
      }

      const escaped = escapeRegExp(target.trim());
      if (!escaped) {
        return text;
      }

      const pattern = new RegExp(escaped, "gi");
      return text.replace(pattern, (match) => createMaskFromMatch(match));
    }

    function sanitizeDictionaryText(text) {
      if (text === null || text === undefined) {
        return "";
      }

      const raw = typeof text === "string" ? text : String(text);
      const withoutCloze = raw.replace(/\{\{c\d+::(.*?)(::.*?)?\}\}/gi, (_, content) => {
        return content ? content.trim() : "";
      });

      const withoutNbsp = withoutCloze.replace(/\u00a0/g, " ");
      const collapsedSpaces = withoutNbsp.replace(/ {2,}/g, " ");
      return collapsedSpaces.replace(/ \n/g, "\n").trim();
    }

    async function loadNoteTypesForDeck(deckName) {
      if (!deckName) {
        pendingNoteTypeDeck = "";
        updateModelSuggestions([]);
        return;
      }

      pendingNoteTypeDeck = deckName;

      try {
        const sanitizedDeckName = escapeDeckNameForQuery(deckName);
        const noteIds = await callAnkiConnect("findNotes", {
          query: `deck:"${sanitizedDeckName}"`,
        });

        if (pendingNoteTypeDeck !== deckName) {
          return;
        }

        const noteTypeSet = new Set();

        if (Array.isArray(noteIds) && noteIds.length) {
          const batchLimit = Math.max(1, NOTE_SAMPLE_BATCH_LIMIT);
          for (
            let index = 0;
            index < noteIds.length && index / NOTE_SAMPLE_BATCH_SIZE < batchLimit;
            index += NOTE_SAMPLE_BATCH_SIZE
          ) {
            const batch = noteIds.slice(index, index + NOTE_SAMPLE_BATCH_SIZE);
            if (!batch.length) {
              continue;
            }

            const notesInfo = await callAnkiConnect("notesInfo", { notes: batch });

            if (pendingNoteTypeDeck !== deckName) {
              return;
            }

            if (Array.isArray(notesInfo)) {
              notesInfo.forEach((note) => {
                if (note && note.modelName) {
                  noteTypeSet.add(note.modelName);
                }
              });
            }

            if (batch.length < NOTE_SAMPLE_BATCH_SIZE) {
              break;
            }
          }
        }

        if (pendingNoteTypeDeck !== deckName) {
          return;
        }

        let noteTypes = Array.from(noteTypeSet).sort((a, b) => a.localeCompare(b));
        let statusMessage = "";

        if (!noteTypes.length) {
          const allModelNames = await callAnkiConnect("modelNames");

          if (pendingNoteTypeDeck !== deckName) {
            return;
          }

          if (Array.isArray(allModelNames)) {
            allModelNames.forEach((name) => {
              if (name) {
                noteTypeSet.add(name);
              }
            });
          }

          noteTypes = Array.from(noteTypeSet).sort((a, b) => a.localeCompare(b));

          if (!noteTypes.length) {
            throw new Error("No note types available.");
          }

          statusMessage = `No existing notes found in "${deckName}". Showing all note types.`;
        } else {
          statusMessage = `Loaded ${noteTypes.length} note type${
            noteTypes.length === 1 ? "" : "s"
          } from "${deckName}".`;
        }

        if (pendingNoteTypeDeck !== deckName) {
          return;
        }

        updateModelSuggestions(noteTypes);

        const currentModelName = modelNameInput.value.trim();
        if (!userModifiedNoteType || !noteTypes.includes(currentModelName)) {
          const preferredModelName = noteTypes.includes(DEFAULT_MODEL_NAME)
            ? DEFAULT_MODEL_NAME
            : noteTypes[0] || currentModelName;

          if (preferredModelName && preferredModelName !== currentModelName) {
            modelNameInput.value = preferredModelName;
          }

          userModifiedNoteType = false;
        }

        await refreshModelFieldsForCurrentModel({
          modelName: modelNameInput.value.trim() || DEFAULT_MODEL_NAME,
        });

        setStatus(statusMessage, "success");
      } catch (error) {
        if (pendingNoteTypeDeck !== deckName) {
          return;
        }

        console.error(error);
        updateModelSuggestions([]);
        setStatus(error.message || "Failed to load note types", "error");
      }
    }

    async function loadDecks() {
      setStatus("Loading decks…");
      loadDecksBtn.disabled = true;
      try {
        const deckNames = await callAnkiConnect("deckNames");
        availableDeckNames = Array.isArray(deckNames) ? deckNames.slice() : [];
        deckSelect.innerHTML = "";
        if (!Array.isArray(deckNames) || !deckNames.length) {
          const option = document.createElement("option");
          option.textContent = "No decks found";
          option.disabled = true;
          option.selected = true;
          deckSelect.appendChild(option);
        } else {
          const placeholder = document.createElement("option");
          placeholder.textContent = "Choose a deck";
          placeholder.disabled = true;
          placeholder.selected = true;
          placeholder.value = "";
          deckSelect.appendChild(placeholder);
          for (const deck of deckNames) {
            const option = document.createElement("option");
            option.value = deck;
            option.textContent = deck;
            deckSelect.appendChild(option);
          }
          const savedDeck = getSessionItem(SESSION_KEYS.deck);
          if (savedDeck && deckNames.includes(savedDeck)) {
            deckSelect.value = savedDeck;
            updateExistingDeckSelectOptions();
            persistDeckSelection();
            await loadNoteTypesForDeck(savedDeck);
            return;
          }
        }
        updateExistingDeckSelectOptions();
        updateModelSuggestions([]);
        await refreshModelFieldsForCurrentModel();
        setStatus("Decks loaded", "success");
      } catch (error) {
        console.error(error);
        setStatus(error.message || "Failed to load decks", "error");
      } finally {
        loadDecksBtn.disabled = false;
      }
    }

    function applyMaskedContent(element, text, lookupTerm) {
      if (!element) {
        return;
      }

      const cleaned = sanitizeDictionaryText(text);
      if (!cleaned) {
        element.textContent = "";
        return;
      }

      const masked = maskTargetInText(cleaned, lookupTerm);
      if (masked && masked !== cleaned) {
        element.innerHTML = masked;
      } else {
        element.textContent = cleaned;
      }
    }

    function createBadge(text, variant = "") {
      const badge = document.createElement("span");
      badge.className = "badge" + (variant ? " " + variant : "");
      badge.textContent = text;
      return badge;
    }

    function buildDefinitionEntry(entry, lookupTerm) {
      const details = document.createElement("details");
      details.className = "definition-entry";

      const summary = document.createElement("summary");
      const summaryText = document.createElement("div");
      summaryText.className = "entry-summary-text";

      const headword = document.createElement("span");
      headword.className = "entry-headword";
      headword.textContent = entry.word || lookupTerm;
      summaryText.appendChild(headword);

      const badgeRow = document.createElement("div");
      badgeRow.className = "badge-row";
      if (entry.isExistingNote) {
        badgeRow.appendChild(createBadge("Existing card"));
      }
      if (entry.source) {
        badgeRow.appendChild(createBadge(entry.source, "secondary"));
      }
      const partLabels = new Set();
      (entry.meanings || []).forEach((meaning) => {
        if (meaning?.partOfSpeech) {
          partLabels.add(meaning.partOfSpeech);
        }
      });
      if (!partLabels.size) {
        partLabels.add("Definition");
      }
      partLabels.forEach((label) => badgeRow.appendChild(createBadge(label)));
      summaryText.appendChild(badgeRow);

      summary.appendChild(summaryText);
      details.appendChild(summary);

      const content = document.createElement("div");
      content.className = "entry-content";

      if (entry.note && !entry.isExistingNote) {
        const noteParagraph = document.createElement("p");
        noteParagraph.style.margin = "0";
        noteParagraph.textContent = entry.note;
        content.appendChild(noteParagraph);
      }

      if (entry.phonetic) {
        const phonetic = document.createElement("p");
        phonetic.style.margin = "0";
        phonetic.innerHTML = `<strong>Phonetic:</strong> ${entry.phonetic}`;
        content.appendChild(phonetic);
      }

      if (entry.isExistingNote && entry.noteDetails) {
        const existingNoteActions = document.createElement("div");
        existingNoteActions.className = "existing-note-actions";

        const loadButton = document.createElement("button");
        loadButton.type = "button";
        loadButton.textContent = "Load this note";
        loadButton.addEventListener("click", () => {
          const clonedDetails = cloneNoteDetails(entry.noteDetails);
          if (!clonedDetails) {
            return;
          }

          if (!clonedDetails.deckName && entry.deckName) {
            clonedDetails.deckName = entry.deckName;
          }

          const appliedDetails = applyNoteToEditor(clonedDetails) || clonedDetails;
          setActiveLoadedNote(appliedDetails);

          const descriptionParts = [];
          const displayWord =
            (appliedDetails.display && appliedDetails.display.frontText) ||
            entry.word ||
            lookupTerm ||
            "";
          if (displayWord) {
            descriptionParts.push(`"${displayWord}"`);
          }

          const deckLabel = appliedDetails.deckName || entry.deckName || "";
          if (deckLabel) {
            descriptionParts.push(`from "${deckLabel}"`);
          }

          const summaryText = descriptionParts.length
            ? `Loaded existing card ${descriptionParts.join(" ")}`
            : "Loaded existing card";

          setStatus(
            `${summaryText}. Edit the fields and choose "Update Loaded Card" to save changes.`,
            "success"
          );
        });

        existingNoteActions.appendChild(loadButton);

        if (entry.noteDetails.id) {
          const noteIdLabel = document.createElement("span");
          noteIdLabel.textContent = `Note #${entry.noteDetails.id}`;
          existingNoteActions.appendChild(noteIdLabel);
        }

        content.appendChild(existingNoteActions);
      }

      let sanitizedNoteWord = "";
      let resolveMaskTarget = () => sanitizeDictionaryText(lookupTerm || "");

      if (entry.isExistingNote && entry.noteDetails) {
        sanitizedNoteWord = sanitizeDictionaryText(
          (entry.noteDetails.display && entry.noteDetails.display.frontText) ||
            entry.word ||
            lookupTerm ||
            ""
        );

        resolveMaskTarget = () => {
          const currentWordValue = frontField ? sanitizeDictionaryText(frontField.value) : "";
          return sanitizedNoteWord || currentWordValue || sanitizeDictionaryText(lookupTerm || "");
        };
      }

      (entry.meanings || []).forEach((meaning) => {
        const meaningBlock = document.createElement("div");
        meaningBlock.className = "meaning-block";

        const meaningTitle = document.createElement("div");
        meaningTitle.className = "meaning-title";
        meaningTitle.appendChild(createBadge(meaning.partOfSpeech || "Definition"));
        const definitionCount = Array.isArray(meaning.definitions)
          ? meaning.definitions.length
          : 0;
        if (definitionCount > 1) {
          meaningTitle.appendChild(createBadge(`${definitionCount} defs`, "secondary"));
        }
        meaningBlock.appendChild(meaningTitle);

        const definitionList = document.createElement("ol");
        definitionList.className = "definition-list";

        (meaning.definitions || []).forEach((definition) => {
          const listItem = document.createElement("li");
          listItem.className = "definition-item";

          const definitionText = document.createElement("p");
          definitionText.className = "definition-text";
          const sanitizedDefinition = sanitizeDictionaryText(definition.definition);
          if (!sanitizedDefinition) {
            return;
          }

          applyMaskedContent(definitionText, sanitizedDefinition, lookupTerm);
          listItem.appendChild(definitionText);

          const exampleCandidates = Array.isArray(definition.examples)
            ? definition.examples.slice()
            : [];
          if ((!exampleCandidates || !exampleCandidates.length) && definition.example) {
            exampleCandidates.push(definition.example);
          }

          const examples = Array.from(
            new Set(
              exampleCandidates
                .map((candidate) => sanitizeDictionaryText((candidate || "").toString()))
                .filter(Boolean)
            )
          );

          let exampleList = null;
          if (examples.length) {
            exampleList = document.createElement("ul");
            exampleList.className = "example-list";

            examples.forEach((exampleText, index) => {
              const exampleItem = document.createElement("li");
              exampleItem.className = "example-item";

              const exampleTextElement = document.createElement("p");
              exampleTextElement.className = "example-text";
              applyMaskedContent(exampleTextElement, exampleText, lookupTerm);
              exampleItem.appendChild(exampleTextElement);

              if (exampleField) {
                const exampleButton = document.createElement("button");
                exampleButton.type = "button";
                const defaultLabel =
                  examples.length > 1 ? `Use example ${index + 1}` : "Use this example";
                exampleButton.textContent = entry.isExistingNote ? "Use this example" : defaultLabel;
                exampleButton.addEventListener("click", () => {
                  const sanitizedExample = sanitizeDictionaryText(exampleText);
                  const targetWord = resolveMaskTarget();
                  const maskedExample = maskTargetInText(
                    sanitizedExample,
                    entry.isExistingNote ? targetWord : lookupTerm
                  );
                  exampleField.value = maskedExample;
                  adjustTextareaHeight(exampleField);
                  if (frontField && !frontField.value.trim()) {
                    frontField.value = entry.word || lookupTerm;
                    adjustTextareaHeight(frontField);
                  }
                  refreshMaskedWordField();
                  const message = entry.isExistingNote
                    ? "Example added from existing card. Ready to create a new card."
                    : "Example added to the card";
                  setStatus(message, "success");
                });
                exampleItem.appendChild(exampleButton);
              }

              exampleList.appendChild(exampleItem);
            });

            listItem.appendChild(exampleList);
          }

          let actions = null;
          if (backField && sanitizedDefinition) {
            actions = document.createElement("div");
            actions.className = "definition-actions";

            const definitionButton = document.createElement("button");
            definitionButton.type = "button";
            definitionButton.textContent = "Use this definition";
            definitionButton.addEventListener("click", () => {
              const targetWord = resolveMaskTarget();
              const maskedDefinition = maskTargetInText(
                sanitizedDefinition,
                entry.isExistingNote ? targetWord : lookupTerm
              );
              backField.value = maskedDefinition;
              adjustTextareaHeight(backField);
              if (frontField && !frontField.value.trim()) {
                frontField.value = entry.word || lookupTerm;
                adjustTextareaHeight(frontField);
              }
              refreshMaskedWordField();
              const message = entry.isExistingNote
                ? "Definition added from existing card. Ready to create a new card."
                : "Definition added to the card";
              setStatus(message, "success");
            });
            actions.appendChild(definitionButton);
          }

          if (actions) {
            if (entry.isExistingNote && exampleList) {
              listItem.insertBefore(actions, exampleList);
            } else {
              listItem.appendChild(actions);
            }
          }

          definitionList.appendChild(listItem);
        });

        meaningBlock.appendChild(definitionList);
        content.appendChild(meaningBlock);
      });

      details.appendChild(content);
      return details;
    }

    function renderDictionaryResults(entries, parsedTerm) {
      dictionaryResults.innerHTML = "";
      if (!entries || !entries.length) {
        dictionaryResults.textContent = "No results found.";
        return;
      }

      entries.forEach((entry, index) => {
        const element = buildDefinitionEntry(entry, parsedTerm.term);
        if (!element) {
          return;
        }
        if (index === 0) {
          element.open = true;
        }
        dictionaryResults.appendChild(element);
      });
    }

    async function searchDictionary() {
      const rawInput = lookupTermInput.value.trim();
      if (!rawInput) {
        setStatus("Type a term to search", "error");
        return;
      }

      const parsedTerm = parseLookupTerm(rawInput);
      if (!parsedTerm.term) {
        setStatus("Type a term to search", "error");
        return;
      }

      setStatus(`Searching online dictionaries and decks for "${parsedTerm.term}"…`);
      searchButton.disabled = true;
      dictionaryResults.textContent = "Searching…";

      const uniqueEntryKeys = new Set();
      const contributingProviders = new Set();
      const providerErrors = [];
      let deckLookupSummaries = [];

      const onlineEntries = [];
      const deckEntries = [];

      const deckEntryComparator = (a, b) => {
        const aMatch = a.headwordMatch ? 1 : 0;
        const bMatch = b.headwordMatch ? 1 : 0;
        if (aMatch !== bMatch) {
          return bMatch - aMatch;
        }
        const aOrder = typeof a._insertionOrder === "number" ? a._insertionOrder : 0;
        const bOrder = typeof b._insertionOrder === "number" ? b._insertionOrder : 0;
        if (aOrder !== bOrder) {
          return aOrder - bOrder;
        }
        const aWord = typeof a.word === "string" ? a.word.toLowerCase() : "";
        const bWord = typeof b.word === "string" ? b.word.toLowerCase() : "";
        if (aWord && bWord && aWord !== bWord) {
          return aWord.localeCompare(bWord);
        }
        const aKey = typeof a.uniqueKey === "string" ? a.uniqueKey : "";
        const bKey = typeof b.uniqueKey === "string" ? b.uniqueKey : "";
        return aKey.localeCompare(bKey);
      };

      const getCombinedEntries = () => {
        if (!deckEntries.length) {
          return onlineEntries.slice();
        }
        const sortedDeckEntries = deckEntries.slice().sort(deckEntryComparator);
        return [...onlineEntries, ...sortedDeckEntries];
      };

      const refreshCombinedResults = () => {
        const combined = getCombinedEntries();
        if (combined.length) {
          renderDictionaryResults(combined, parsedTerm);
        }
      };

      const addEntries = (entries, providerLabel = "", options = {}) => {
        const { trackProvider = true, category = "online", skipPosFilter = false } = options;
        if (!Array.isArray(entries)) {
          return;
        }

        let appended = false;

        entries.forEach((entry) => {
          if (!entry || !Array.isArray(entry.meanings) || !entry.meanings.length) {
            return;
          }

          let workingEntry = entry;
          if (!skipPosFilter && parsedTerm.partOfSpeech) {
            const filtered = filterEntryByPartOfSpeech(entry, parsedTerm.partOfSpeech);
            if (!filtered) {
              return;
            }
            workingEntry = filtered;
          }

          const key = workingEntry.uniqueKey
            ? workingEntry.uniqueKey
            : JSON.stringify({
                source: workingEntry.source || providerLabel || "",
                word: workingEntry.word || "",
                meanings: (workingEntry.meanings || []).map((meaning) => ({
                  partOfSpeech: meaning.partOfSpeech || "",
                  definitions: (meaning.definitions || []).map((definition) => ({
                    definition: definition.definition || "",
                    example: definition.example || "",
                  })),
                })),
              });

          if (uniqueEntryKeys.has(key)) {
            return;
          }
          uniqueEntryKeys.add(key);

          const entryToAdd = { ...workingEntry };
          if (!entryToAdd.source && providerLabel) {
            entryToAdd.source = providerLabel;
          }

          if (category === "deck") {
            entryToAdd._insertionOrder = deckEntries.length;
            deckEntries.push(entryToAdd);
          } else {
            onlineEntries.push(entryToAdd);
          }
          appended = true;

          if (trackProvider) {
            const contributor = entryToAdd.source || providerLabel;
            if (contributor) {
              contributingProviders.add(contributor);
            }
          }
        });

        if (appended) {
          refreshCombinedResults();
        }
      };

      try {
        const providerPromises = Object.values(dictionaryProviders).map((provider) => {
          if (!provider || typeof provider.fetchEntries !== "function") {
            return Promise.resolve();
          }

          return provider
            .fetchEntries(parsedTerm.term, parsedTerm, {
              credentials: getProviderCredentials(provider.id),
            })
            .then((entries) => {
              addEntries(entries, provider.label || provider.id);
            })
            .catch((error) => {
              console.warn(
                `Dictionary lookup failed for ${provider.label || provider.id}`,
                error
              );
              providerErrors.push(
                `${provider.label || provider.id}: ${error?.message || "Lookup failed."}`
              );
            });
        });

        const deckLookupPromise = findDeckEntriesForSelection(parsedTerm.term)
          .then((summaries) => {
            deckLookupSummaries = Array.isArray(summaries) ? summaries : [];
            deckLookupSummaries.forEach((summary) => {
              if (Array.isArray(summary.entries) && summary.entries.length) {
                addEntries(summary.entries, summary.deckName || "Existing cards", {
                  category: "deck",
                  trackProvider: false,
                  skipPosFilter: true,
                });
              }
            });
            return deckLookupSummaries;
          })
          .catch((error) => {
            console.warn("Deck lookup failed", error);
            const failureSummary = {
              deckName: determineDeckSelectionLabel(),
              entries: [],
              totalCount: 0,
              shownCount: 0,
              truncated: false,
              error: error?.message || "Deck lookup failed.",
            };
            deckLookupSummaries = [failureSummary];
            return deckLookupSummaries;
          });

        await Promise.allSettled([...providerPromises, deckLookupPromise]);

        const combinedEntries = getCombinedEntries();

        if (!combinedEntries.length) {
          renderDictionaryResults([], parsedTerm);
          let emptyMessage = "No entries available.";
          deckLookupSummaries.forEach((summary) => {
            if (summary.deckName && summary.error) {
              emptyMessage += ` Deck lookup failed for "${summary.deckName}": ${summary.error}`;
            }
          });
          if (providerErrors.length) {
            emptyMessage += ` Dictionary errors: ${providerErrors.join("; ")}.`;
          }
          setStatus(emptyMessage, "error");
          return;
        }

        renderDictionaryResults(combinedEntries, parsedTerm);

        const statusParts = [];
        const providerList = Array.from(contributingProviders);

        if (providerList.length) {
          statusParts.push(
            `Dictionary results loaded from ${
              providerList.length === 1
                ? providerList[0]
                : `${providerList.length} dictionaries (${providerList.join(", ")})`
            }.`
          );
        } else if (!providerErrors.length) {
          statusParts.push("No online dictionary entries were found.");
        }

        if (deckLookupSummaries.length) {
          deckLookupSummaries.forEach((summary) => {
            if (!summary.deckName) {
              return;
            }
            if (summary.error) {
              statusParts.push(`Deck lookup failed for "${summary.deckName}": ${summary.error}`);
              return;
            }

            if (summary.totalCount > 0) {
              let deckMessage = `Found ${summary.totalCount} existing card${
                summary.totalCount === 1 ? "" : "s"
              } in "${summary.deckName}"`;
              if (summary.truncated && summary.shownCount) {
                deckMessage += ` (showing first ${summary.shownCount})`;
              }
              statusParts.push(`${deckMessage}.`);
            } else {
              statusParts.push(`No existing cards matched in "${summary.deckName}".`);
            }
          });
        }

        if (providerErrors.length) {
          statusParts.push(`Dictionary errors: ${providerErrors.join("; ")}.`);
        }

        const hasDeckErrors = deckLookupSummaries.some((summary) => summary.error);
        const statusType = hasDeckErrors || providerErrors.length ? "error" : "success";
        setStatus(statusParts.join(" "), statusType);
      } catch (error) {
        console.error(error);
        dictionaryResults.textContent = "No entries available.";
        setStatus(error.message || "Failed to fetch dictionary results", "error");
      } finally {
        searchButton.disabled = false;
      }
    }
    async function collectNoteFieldValues({ requireDeck = true } = {}) {
      const deckName = deckSelect.value;
      if (requireDeck && !deckName) {
        throw new Error("Please choose a deck");
      }

      const modelName = modelNameInput.value.trim() || DEFAULT_MODEL_NAME;

      refreshMaskedWordField();

      const tags = parseTagsFromInput();

      let metadata = modelFieldCache.get(modelName);
      try {
        if (!metadata || !Array.isArray(metadata.orderedFieldNames) || !metadata.orderedFieldNames.length) {
          metadata = await ensureModelFieldMetadata(modelName);
        }
      } catch (metadataError) {
        console.error(metadataError);
        throw new Error(
          metadataError?.message || `Failed to load fields for "${modelName}"`
        );
      }

      const orderedFieldNames = Array.isArray(metadata?.orderedFieldNames) && metadata.orderedFieldNames.length
        ? metadata.orderedFieldNames
        : Array.isArray(activeModelFieldMetadata?.orderedFieldNames)
        ? activeModelFieldMetadata.orderedFieldNames
        : [];

      if (!orderedFieldNames.length) {
        throw new Error(`The note type "${modelName}" has no fields.`);
      }

      const fields = {};
      orderedFieldNames.forEach((fieldName) => {
        const editor = fieldEditors.get(fieldName);
        fields[fieldName] = editor ? editor.value.trim() : "";
      });

      fieldEditors.forEach((editor, fieldName) => {
        if (!(fieldName in fields)) {
          fields[fieldName] = editor ? editor.value.trim() : "";
        }
      });

      const roleMap = metadata?.roleMap || activeModelFieldMetadata.roleMap || {};
      const wordFieldName =
        roleMap.word ||
        (orderedFieldNames.length ? orderedFieldNames[0] : getActiveWordFieldName());
      const definitionFieldName =
        roleMap.definition ||
        orderedFieldNames.find((name) => name && name !== wordFieldName) ||
        null;

      const wordValue = wordFieldName ? (fields[wordFieldName] || "").trim() : "";
      const definitionValue = definitionFieldName
        ? (fields[definitionFieldName] || "").trim()
        : "";

      if (!wordValue) {
        throw new Error("Primary fields cannot be empty for this note type.");
      }

      if (definitionFieldName && !definitionValue) {
        throw new Error("Primary fields cannot be empty for this note type.");
      }

      if (wordFieldName) {
        fields[wordFieldName] = wordValue;
      }
      if (definitionFieldName) {
        fields[definitionFieldName] = definitionValue;
      }

      const maskedFieldName = roleMap.masked || activeModelFieldMetadata.roleMap?.masked;
      if (maskedFieldName) {
        const maskedEditor = fieldEditors.get(maskedFieldName);
        let maskedValue = maskedEditor ? maskedEditor.value.trim() : fields[maskedFieldName] || "";
        if (!maskedValue && wordFieldName && (!maskedEditor || !isMaskedEditorUserEdited(maskedEditor))) {
          maskedValue = deriveMaskedWordValue(wordValue);
          if (maskedEditor) {
            setMaskedEditorAutoValue(maskedEditor, maskedValue);
          }
        }
        fields[maskedFieldName] = maskedValue;
      }

      return {
        deckName,
        modelName,
        fields,
        tags,
        wordFieldName,
        wordValue,
        definitionFieldName,
        definitionValue,
      };
    }

    async function commitNoteUpdate(
      noteId,
      fields,
      { successMessage, syncFailurePrefix } = {}
    ) {
      if (!noteId) {
        throw new Error("A note identifier is required to update.");
      }

      await callAnkiConnect("updateNoteFields", {
        note: { id: noteId, fields },
      });

      try {
        await callAnkiConnect("sync");
        if (successMessage) {
          setStatus(successMessage, "success");
        }
      } catch (syncError) {
        console.warn("Sync failed", syncError);
        const failureMessage = syncFailurePrefix
          ? `${syncFailurePrefix}: ${syncError.message}`
          : `Sync failed via saved session: ${syncError.message}`;
        setStatus(failureMessage, "error");
      }
    }

    async function addCard() {
      setStatus("Adding card to deck…");
      addCardBtn.disabled = true;

      if (updateCardBtn) {
        updateCardBtn.disabled = true;
      }

      let payload;
      try {
        payload = await collectNoteFieldValues({ requireDeck: true });
      } catch (error) {
        setStatus(error?.message || "Failed to prepare the card", "error");
        addCardBtn.disabled = false;
        updateLoadedNoteButtonState();
        return;
      }

      const { deckName, modelName, fields, tags, wordFieldName, wordValue } = payload;

      try {
        await callAnkiConnect("addNote", {
          note: {
            deckName,
            modelName,
            fields,
            tags,
          },
        });

        try {
          await callAnkiConnect("sync");
          setStatus(
            "Card added and sync requested using Anki's saved session.",
            "success"
          );
        } catch (syncError) {
          console.warn("Sync failed", syncError);
          setStatus(
            `Card added but sync failed via saved session: ${syncError.message}`,
            "error"
          );
        }
      } catch (error) {
        console.error(error);
        const errorMessage = error?.message || "Failed to add card";
        if (
          typeof window !== "undefined" &&
          errorMessage.toLowerCase().includes("cannot create note because it is a duplicate")
        ) {
          try {
            const duplicateNoteId = await findDuplicateNoteId({
              modelName,
              wordFieldName,
              wordValue,
            });

            if (
              duplicateNoteId &&
              activeLoadedNote &&
              Number(activeLoadedNote.id) === Number(duplicateNoteId)
            ) {
              await commitNoteUpdate(duplicateNoteId, fields, {
                successMessage:
                  "Existing card updated because a duplicate was detected. Sync requested using Anki's saved session.",
                syncFailurePrefix:
                  "Existing card updated but sync failed via saved session",
              });
              refreshActiveLoadedNoteSnapshot(fields, {
                modelName,
                tags,
              });
            } else {
              setStatus(
                "Card was not added because an existing note already contains these primary fields.",
                "error"
              );
            }
          } catch (updateError) {
            console.error(updateError);
            setStatus(updateError.message || "Failed to update existing card", "error");
          }
        } else {
          setStatus(errorMessage, "error");
        }
      } finally {
        addCardBtn.disabled = false;
        updateLoadedNoteButtonState();
      }
    }

    async function updateLoadedCard() {
      if (!activeLoadedNote || !activeLoadedNote.id) {
        setStatus("Load an existing card before updating.", "error");
        return;
      }

      setStatus("Updating loaded card…");
      if (updateCardBtn) {
        updateCardBtn.disabled = true;
      }

      let payload;
      try {
        payload = await collectNoteFieldValues({ requireDeck: false });
      } catch (error) {
        setStatus(error?.message || "Failed to prepare the update", "error");
        updateLoadedNoteButtonState();
        return;
      }

      const { modelName, fields, tags } = payload;

      try {
        await commitNoteUpdate(activeLoadedNote.id, fields, {
          successMessage:
            "Loaded card updated and sync requested using Anki's saved session.",
          syncFailurePrefix: "Loaded card updated but sync failed via saved session",
        });
        refreshActiveLoadedNoteSnapshot(fields, { modelName, tags });
      } catch (error) {
        console.error(error);
        setStatus(error?.message || "Failed to update loaded card", "error");
      } finally {
        updateLoadedNoteButtonState();
      }
    }

    const initialDeckSelection = getSessionItem(SESSION_KEYS.deck);
    if (initialDeckSelection) {
      loadDecks();
    }

    updateLoadedNoteButtonState();
    if (updateCardBtn) {
      updateCardBtn.addEventListener("click", updateLoadedCard);
    }

    loadDecksBtn.addEventListener("click", loadDecks);
    searchButton.addEventListener("click", searchDictionary);
    lookupTermInput.addEventListener("keydown", (event) => {
      if (event.key === "Enter") {
        event.preventDefault();
        searchDictionary();
      }
    });
    addCardBtn.addEventListener("click", addCard);

  </script>
</body>
</html>

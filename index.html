<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Anki Card Creator</title>
  <style>
    :root {
      color-scheme: light dark;
      font-family: "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      line-height: 1.5;
      font-size: 16px;
    }

    body {
      margin: 0;
      padding: 0;
      background: radial-gradient(circle at top left, #f7f8ff, #eaeefd 40%, #e0e0f5);
      min-height: 100vh;
      color: #1e2a44;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      padding: 2rem;
      box-sizing: border-box;
    }

    .app {
      background: rgba(255, 255, 255, 0.92);
      box-shadow: 0 20px 60px rgba(58, 75, 115, 0.25);
      border-radius: 20px;
      max-width: 1100px;
      width: 100%;
      display: grid;
      grid-template-columns: minmax(280px, 340px) minmax(2.5rem, 3rem) 1fr;
      overflow: hidden;
      position: relative;
      transition: grid-template-columns 0.3s ease;
    }

    .sidebar {
      padding: 2rem;
      background: linear-gradient(180deg, #3f64c7, #4650ac);
      color: white;
      width: 100%;
      max-width: 340px;
      box-sizing: border-box;
      transform: translateX(0);
      transition: transform 0.3s ease, opacity 0.3s ease, visibility 0.3s ease,
        width 0.3s ease;
      will-change: transform;
      z-index: 20;
    }

    .sidebar-handle {
      display: flex;
      align-items: center;
      justify-content: center;
      background: linear-gradient(180deg, #3f64c7, #4650ac);
      transition: min-width 0.3s ease, width 0.3s ease, opacity 0.3s ease;
      min-width: 2.75rem;
      width: 100%;
      height: 100%;
      align-self: stretch;
      position: relative;
      z-index: 30;
    }

    .app.is-sidebar-collapsed { 
      grid-template-columns: 0 minmax(0, 1.1rem) 1fr;
    }

    .app.is-sidebar-collapsed .sidebar {
      transform: translateX(-100%);
      width: 0;
      opacity: 0;
      visibility: hidden;
      pointer-events: none;
    }

    .app.is-sidebar-collapsed .sidebar-handle {
      min-width: 1.1rem;
      opacity: 0.95;
    }

    .sidebar h1 {
      margin-top: 0;
      margin-bottom: 1.5rem;
      font-size: 1.9rem;
      letter-spacing: 0.02em;
    }

    .sidebar section + section {
      margin-top: 2.5rem;
    }

    label {
      font-weight: 600;
      display: block;
      margin-bottom: 0.5rem;
    }

    input[type="text"],
    input[type="password"],
    textarea,
    select {
      width: 100%;
      border: 1px solid rgba(30, 42, 68, 0.2);
      border-radius: 10px;
      padding: 0.7rem 0.85rem;
      font-size: 1rem;
      font-family: inherit;
      box-sizing: border-box;
      background: rgba(255, 255, 255, 0.95);
      color: #1e2a44;
    }

    textarea {
      resize: vertical;
      overflow: hidden;
    }

    button {
      background: #3f64c7;
      border: none;
      border-radius: 999px;
      padding: 0.65rem 1.35rem;
      font-size: 0.95rem;
      font-weight: 600;
      color: white;
      cursor: pointer;
      transition: transform 0.15s ease, box-shadow 0.15s ease;
      box-shadow: 0 10px 30px rgba(63, 100, 199, 0.3);
    }

    button:hover {
      transform: translateY(-1px);
      box-shadow: 0 12px 32px rgba(63, 100, 199, 0.4);
    }

    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      box-shadow: none;
      transform: none;
    }

    .main {
      padding: 2rem 2.5rem;
      background: rgba(249, 250, 255, 0.9);
      display: flex;
      flex-direction: column;
      gap: 2rem;
      max-height: calc(100vh - 4rem);
      overflow-y: auto;
      min-height: 0;
    }

    .sidebar-toggle {
      width: 2.5rem;
      height: 2.5rem;
      border: none;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.22);
      color: white;
      display: grid;
      place-items: center;
      cursor: pointer;
      transition: background 0.2s ease, transform 0.2s ease;
      padding: 0;
    }

    .sidebar-toggle::before {
      content: "❮";
      font-size: 1rem;
      line-height: 1;
      transition: transform 0.2s ease;
    }

    .sidebar-toggle[data-state="collapsed"]::before {
      content: "❯";
    }

    .sidebar-toggle:hover,
    .sidebar-toggle:focus-visible {
      background: rgba(255, 255, 255, 0.35);
      transform: translateX(-1px);
      outline: none;
      box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.65);
    }

    .app.is-sidebar-collapsed .sidebar-toggle {
      width: 100%;
      height: 100%;
      border-radius: 0;
      background: transparent;
      transform: none;
    }

    .app.is-sidebar-collapsed .sidebar-toggle:hover,
    .app.is-sidebar-collapsed .sidebar-toggle:focus-visible {
      background: rgba(255, 255, 255, 0.2);
    }

    .panel {
      background: white;
      border-radius: 16px;
      padding: 1.5rem;
      box-shadow: 0 10px 30px rgba(43, 58, 92, 0.1);
    }

    .dictionary-workspace {
      display: grid;
      gap: 1.5rem;
      min-height: 0;
      flex: 1 1 auto;
    }

    .dictionary-workspace > .panel {
      min-height: 0;
    }

    #dictionary-panel {
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
      min-height: 0;
    }

    #dictionary-panel .dictionary-results {
      flex: 1 1 auto;
      overflow-y: auto;
      min-height: 0;
    }

    .note-panel {
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
    }

    .note-grid {
      display: grid;
      gap: 1rem;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      grid-template-areas:
        "word masked"
        "definition definition"
        "example example";
    }

    .note-field {
      display: grid;
      gap: 0.5rem;
    }

    .note-field--word {
      grid-area: word;
    }

    .note-field--masked {
      grid-area: masked;
    }

    .note-field--definition {
      grid-area: definition;
    }

    .note-field--example {
      grid-area: example;
    }

    .note-actions {
      display: flex;
      gap: 1rem;
      align-items: center;
      flex-wrap: wrap;
    }

    @media (orientation: landscape) {
      .dictionary-workspace {
        grid-template-columns: minmax(260px, 360px) minmax(0, 1fr);
        align-items: stretch;
        grid-auto-rows: minmax(0, 1fr);
      }

      #dictionary-panel {
        overflow: hidden;
        height: 100%;
      }

      #dictionary-panel .dictionary-results {
        padding-right: 0.25rem;
      }
    }

    #note-panel {
      position: sticky;
      top: 2rem;
      align-self: flex-start;
      width: 100%;
    }

    .setup-notice {
      border: 1px solid rgba(63, 100, 199, 0.18);
      background: linear-gradient(
        135deg,
        rgba(63, 100, 199, 0.14),
        rgba(70, 80, 172, 0.04)
      );
      display: grid;
      gap: 0.75rem;
    }

    .setup-notice.is-hidden {
      display: none;
    }

    .setup-steps {
      margin: 0;
      padding-left: 1.2rem;
      color: #2f4075;
    }

    .setup-steps li + li {
      margin-top: 0.4rem;
    }

    .setup-snippet {
      background: rgba(63, 100, 199, 0.12);
      border-radius: 12px;
      padding: 0.9rem 1rem;
      font-family: "Fira Code", "SFMono-Regular", Menlo, Monaco, Consolas,
        "Liberation Mono", "Courier New", monospace;
      font-size: 0.9rem;
      color: #1f2b4a;
      overflow-x: auto;
    }

    .setup-snippet pre {
      margin: 0;
      white-space: pre;
    }

    .setup-footnote {
      margin: 0;
      font-size: 0.85rem;
      color: #3f4d7a;
    }

    .panel h2 {
      margin-top: 0;
      font-size: 1.35rem;
      color: #2f4075;
    }

    .dictionary-controls {
      display: grid;
      grid-template-columns: minmax(0, 1fr) auto auto;
      gap: 0.75rem;
      align-items: center;
    }

    .dictionary-scope {
      background: rgba(63, 100, 199, 0.12);
      color: #2a3d82;
      border-radius: 999px;
      padding: 0.45rem 1rem;
      font-weight: 600;
      white-space: nowrap;
    }

    .dictionary-settings {
      margin-top: 1rem;
      display: grid;
      gap: 1rem;
    }

    .scope-toggle {
      display: inline-flex;
      background: rgba(63, 100, 199, 0.1);
      border-radius: 999px;
      padding: 0.2rem;
      gap: 0.2rem;
      flex-wrap: wrap;
    }

    .scope-toggle button {
      background: transparent;
      border-radius: 999px;
      padding: 0.45rem 0.95rem;
      border: none;
      color: #2a3d82;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.15s ease, color 0.15s ease;
    }

    .scope-toggle button.is-active {
      background: #3f64c7;
      color: white;
    }

    .dictionary-provider-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 0.5rem;
    }

    .provider-option {
      background: rgba(63, 100, 199, 0.08);
      border: 1px solid rgba(63, 100, 199, 0.14);
      border-radius: 12px;
      padding: 0.55rem 0.75rem;
      display: flex;
      align-items: center;
      gap: 0.6rem;
      font-weight: 500;
      color: #2a3d82;
    }

    .provider-option input[type="checkbox"] {
      width: 1rem;
      height: 1rem;
      margin: 0;
    }

    .dictionary-results {
      display: grid;
      gap: 1rem;
      margin-top: 1rem;
    }

    .suggestions {
      margin-top: 0.5rem;
      font-size: 0.95rem;
      color: #2f4075;
      display: flex;
      gap: 0.4rem;
      flex-wrap: wrap;
      align-items: center;
    }

    .suggestions button {
      background: rgba(63, 100, 199, 0.15);
      color: #2a3d82;
      border-radius: 999px;
      border: none;
      padding: 0.3rem 0.75rem;
      cursor: pointer;
      font-weight: 600;
    }

    .definition-entry {
      border: 1px solid rgba(63, 100, 199, 0.18);
      border-radius: 16px;
      background: rgba(242, 245, 255, 0.6);
      padding: 0.3rem 0.6rem;
    }

    .definition-entry > summary {
      list-style: none;
      display: flex;
      justify-content: space-between;
      gap: 0.75rem;
      align-items: center;
      cursor: pointer;
      padding: 0.55rem 0.35rem;
    }

    .definition-entry > summary::-webkit-details-marker {
      display: none;
    }

    .entry-summary-text {
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
    }

    .entry-headword {
      font-size: 1.05rem;
      font-weight: 700;
      color: #1e2a44;
    }

    .badge-row {
      display: flex;
      gap: 0.35rem;
      flex-wrap: wrap;
      align-items: center;
    }

    .badge {
      background: rgba(63, 100, 199, 0.15);
      color: #2a3d82;
      border-radius: 999px;
      padding: 0.3rem 0.75rem;
      font-size: 0.75rem;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.02em;
    }

    .badge.secondary {
      background: rgba(42, 61, 130, 0.1);
      color: #3f64c7;
    }

    .entry-content {
      padding: 0 0.9rem 0.9rem 0.9rem;
      display: grid;
      gap: 0.9rem;
    }

    .entry-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 0.6rem;
    }

    .meaning-block {
      background: rgba(255, 255, 255, 0.8);
      border-radius: 12px;
      border: 1px solid rgba(63, 100, 199, 0.12);
      padding: 0.75rem 0.85rem;
      display: grid;
      gap: 0.75rem;
    }

    .meaning-title {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.6rem;
    }

    .definition-list {
      list-style: decimal inside;
      margin: 0;
      padding: 0;
      display: grid;
      gap: 0.65rem;
    }

    .definition-item {
      display: grid;
      gap: 0.45rem;
    }

    .definition-text {
      font-size: 1rem;
      color: #1e2a44;
    }

    .example-text {
      font-style: italic;
      color: #42507b;
    }

    .synonym-cloud {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
    }

    .synonym-cloud button {
      background: rgba(63, 100, 199, 0.15);
      border: none;
      border-radius: 999px;
      padding: 0.35rem 0.8rem;
      font-weight: 600;
      color: #2a3d82;
      cursor: pointer;
    }

    .status {
      font-size: 0.95rem;
      min-height: 1.5rem;
    }

    .status.success {
      color: #1a8f5b;
    }

    .status.error {
      color: #cc2b3d;
    }

    .split {
      display: grid;
      gap: 1rem;
    }

    .additional-fields {
      margin-top: 1.5rem;
      display: grid;
      gap: 1.25rem;
    }

    .additional-field {
      display: grid;
      gap: 0.5rem;
    }

    @media (max-width: 980px) {
      body {
        padding: 1rem;
      }

      .app {
        grid-template-columns: 1fr;
        min-height: calc(100vh - 2rem);
      }

      .sidebar {
        position: absolute;
        top: 0;
        left: 0;
        bottom: 0;
        max-width: min(320px, 90vw);
        width: min(320px, 90vw);
        height: 100%;
        overflow-y: auto;
        border-bottom-left-radius: 16px;
        border-bottom-right-radius: 16px;
        box-shadow: 0 24px 48px rgba(58, 75, 115, 0.35);
        transform: translateX(-100%);
        opacity: 0;
        visibility: hidden;
        pointer-events: none;
      }

      .sidebar-handle {
        position: fixed;
        top: 1.25rem;
        right: 1.25rem;
        min-width: auto;
        width: auto;
        height: auto;
        background: transparent;
        z-index: 60;
      }

      .app:not(.is-sidebar-collapsed) .sidebar {
        transform: translateX(0);
        opacity: 1;
        visibility: visible;
        pointer-events: auto;
      }

      .app.is-sidebar-collapsed {
        grid-template-columns: 1fr;
      }

      .app.is-sidebar-collapsed .sidebar-handle {
        min-width: auto;
        opacity: 1;
      }

      .main {
        padding: 1.5rem;
      }

      .sidebar-toggle,
      .app.is-sidebar-collapsed .sidebar-toggle {
        width: 3rem;
        height: 3rem;
        border-radius: 999px;
        background: rgba(63, 100, 199, 0.95);
        transform: none;
      }

      .sidebar-toggle:hover,
      .sidebar-toggle:focus-visible {
        background: rgba(63, 100, 199, 1);
        transform: none;
      }
    }
  </style>
</head>
<body>
  <div class="app">
    <aside class="sidebar" id="sidebar">
      <h1>Anki Card Creator</h1>
      <section>
        <label for="anki-username">AnkiWeb Username</label>
        <input type="text" id="anki-username" placeholder="name@example.com" autocomplete="username" />
        <label for="anki-password" style="margin-top: 1rem;">AnkiWeb Password</label>
        <input type="password" id="anki-password" placeholder="••••••••" autocomplete="current-password" />
      </section>

      <section>
        <label for="deck-select">Deck</label>
        <div class="split">
          <select id="deck-select">
            <option value="" disabled selected>Load decks via AnkiConnect</option>
          </select>
          <button id="load-decks">Load Decks</button>
        </div>
      </section>

      <section>
        <label for="model-name">Note Type</label>
        <input type="text" id="model-name" value="Basic" list="model-suggestions" />
        <datalist id="model-suggestions"></datalist>
        <label for="tags" style="margin-top: 1rem;">Tags (comma separated)</label>
        <input type="text" id="tags" placeholder="vocab, dictionary" />
      </section>

      <section>
        <p style="margin-top: 0; font-weight: 600;">Dictionary resources</p>
        <p style="font-size: 0.85rem; line-height: 1.5; color: rgba(255, 255, 255, 0.9);">
          Built-in lookups now use public dictionary sites directly—no API keys required.
          Enable or disable providers from the dictionary panel to customise results.
        </p>
      </section>
    </aside>

    <div class="sidebar-handle">
      <button
        id="sidebar-toggle"
        class="sidebar-toggle"
        type="button"
        aria-controls="sidebar"
        aria-expanded="true"
        data-state="expanded"
        aria-label="Hide sidebar"
      ></button>
    </div>

    <main class="main">
      <section
        class="panel setup-notice"
        id="setup-notice"
        aria-live="polite"
      >
        <h2>Set up AnkiConnect for GitHub Pages</h2>
        <p style="margin: 0;">
          Allow this page to talk to AnkiConnect so decks and cards can be
          managed from the browser.
        </p>
        <ol class="setup-steps">
          <li>
            In Anki, open <strong>Tools → Add-ons → AnkiConnect → Config</strong>.
          </li>
          <li>
            Add your GitHub Pages URL to the <code>webCorsOriginList</code>
            setting.
          </li>
          <li>Save the configuration and restart Anki if prompted.</li>
        </ol>
        <div class="setup-snippet" role="region" aria-label="Sample AnkiConnect configuration">
          <pre><code>{
  "webCorsOriginList": [
    "https://&lt;your-username&gt;.github.io",
    "https://&lt;your-username&gt;.github.io/anki/"
  ]
}</code></pre>
        </div>
        <p class="setup-footnote">
          This notice hides automatically after AnkiConnect responds
          successfully.
        </p>
        <p class="setup-footnote">
          Ensure your AnkiConnect configuration allows the
          <code>findNotes</code>, <code>notesInfo</code>, and
          <code>updateNoteFields</code> actions so this tool can surface and
          refresh existing cards within your decks.
        </p>
      </section>

      <div class="dictionary-workspace">
        <section class="panel note-panel" id="note-panel">
          <div class="note-grid">
            <div class="note-field note-field--word">
              <label for="front-field">Word</label>
              <textarea id="front-field" placeholder="Word"></textarea>
            </div>
            <div class="note-field note-field--masked" id="masked-field-container" hidden></div>
            <div class="note-field note-field--definition">
              <label for="back-field">Definition</label>
              <textarea id="back-field" placeholder="Definition"></textarea>
            </div>
            <div class="note-field note-field--example" id="example-field-wrapper">
              <label for="example-field">Example Sentence (optional)</label>
              <textarea
                id="example-field"
                placeholder="Add your own or pick one from the dictionary results"
              ></textarea>
            </div>
          </div>
          <div class="additional-fields" id="additional-fields" hidden></div>
          <div class="note-actions">
            <button id="add-card">Add Card to Deck</button>
            <span class="status" id="status"></span>
          </div>
        </section>

        <section class="panel" id="dictionary-panel">
          <h2>Dictionary Lookup</h2>
          <div class="dictionary-controls">
            <input type="text" id="lookup-term" placeholder="Search term" />
            <div class="dictionary-scope" aria-live="polite">All dictionaries</div>
            <button id="search-dictionary">Search</button>
          </div>
          <div class="dictionary-settings">
            <div>
              <p style="margin: 0 0 0.5rem 0; font-weight: 600; color: #2f4075;">Search scope</p>
              <div class="scope-toggle" role="group" aria-label="Search scope">
                <button type="button" class="is-active" data-scope="online-decks">Online + decks</button>
                <button type="button" data-scope="online-only">Online only</button>
                <button type="button" data-scope="decks-only">Decks only</button>
              </div>
            </div>
            <div>
              <p style="margin: 0 0 0.5rem 0; font-weight: 600; color: #2f4075;">Dictionaries</p>
              <div class="dictionary-provider-grid" id="dictionary-provider-grid"></div>
            </div>
          </div>
          <div class="suggestions" id="spelling-suggestions" hidden></div>
          <div class="dictionary-results" id="dictionary-results"></div>
        </section>
      </div>

      <section class="panel" id="preview-panel">
        <h2>Preview</h2>
        <p><strong>Deck:</strong> <span id="preview-deck">—</span></p>
        <p><strong>Note Type:</strong> <span id="preview-model">Basic</span></p>
        <p><strong>Tags:</strong> <span id="preview-tags">—</span></p>
        <article style="margin-top: 1rem; padding: 1rem; border-radius: 12px; background: rgba(63, 100, 199, 0.08);">
          <h3 style="margin-top: 0;">Front</h3>
          <p id="preview-front" style="white-space: pre-wrap;"></p>
          <h3>Back</h3>
          <p id="preview-back" style="white-space: pre-wrap;"></p>
          <h3>Example</h3>
          <p id="preview-example" style="white-space: pre-wrap;"></p>
        </article>
      </section>
    </main>
  </div>

  <script>
    const deckSelect = document.getElementById("deck-select");
    const loadDecksBtn = document.getElementById("load-decks");
    const lookupTermInput = document.getElementById("lookup-term");
    const searchButton = document.getElementById("search-dictionary");
    const dictionaryScopeDisplay = document.querySelector(".dictionary-scope");
    const dictionaryProviderGrid = document.getElementById("dictionary-provider-grid");
    const dictionaryResults = document.getElementById("dictionary-results");
    const spellingSuggestions = document.getElementById("spelling-suggestions");
    const frontField = document.getElementById("front-field");
    const backField = document.getElementById("back-field");
    const exampleField = document.getElementById("example-field");
    const frontFieldLabel = document.querySelector("label[for='front-field']");
    const backFieldLabel = document.querySelector("label[for='back-field']");
    const exampleFieldLabel = document.querySelector("label[for='example-field']");
    const exampleFieldWrapper = document.getElementById("example-field-wrapper");
    const maskedFieldContainer = document.getElementById("masked-field-container");
    const additionalFieldsContainer = document.getElementById("additional-fields");
    const addCardBtn = document.getElementById("add-card");
    const statusEl = document.getElementById("status");
    const usernameInput = document.getElementById("anki-username");
    const passwordInput = document.getElementById("anki-password");
    const modelNameInput = document.getElementById("model-name");
    const modelSuggestions = document.getElementById("model-suggestions");
    const tagsInput = document.getElementById("tags");
    const setupNotice = document.getElementById("setup-notice");
    const scopeToggleButtons = document.querySelectorAll(".scope-toggle button");
    const appContainer = document.querySelector(".app");
    const sidebar = document.getElementById("sidebar");
    const sidebarToggle = document.getElementById("sidebar-toggle");

    const previewDeck = document.getElementById("preview-deck");
    const previewModel = document.getElementById("preview-model");
    const previewTags = document.getElementById("preview-tags");
    const previewFront = document.getElementById("preview-front");
    const previewBack = document.getElementById("preview-back");
    const previewExample = document.getElementById("preview-example");

    const DEFAULT_FIELD_LABELS = {
      front: frontFieldLabel ? frontFieldLabel.textContent : "Word",
      back: backFieldLabel ? backFieldLabel.textContent : "Definition",
      example: exampleFieldLabel ? exampleFieldLabel.textContent : "Example Sentence (optional)",
    };

    function adjustTextareaHeight(textarea) {
      if (!textarea) {
        return;
      }
      requestAnimationFrame(() => {
        textarea.style.height = "auto";
        textarea.style.height = `${textarea.scrollHeight}px`;
      });
    }

    const SESSION_KEYS = {
      credentials: "anki.session.credentials",
      deck: "anki.session.deck",
      setupNoticeDismissed: "anki.session.setupDismissed",
    };

    const LOCAL_STORAGE_KEYS = {
      providerSelection: "anki.dictionary.providers",
      searchScope: "anki.dictionary.scope",
      sidebarCollapsed: "anki.ui.sidebarCollapsed",
    };

    const DEFAULT_MODEL_NAME = "Basic";
    const NOTE_SAMPLE_BATCH_SIZE = 200;
    const NOTE_SAMPLE_BATCH_LIMIT = 5;
    const NOTE_SEARCH_LIMIT = 25;
    const SEARCH_SCOPES = {
      onlineDecks: "online-decks",
      onlineOnly: "online-only",
      decksOnly: "decks-only",
    };

    const modelFieldCache = new Map();
    const pendingModelFieldRequests = new Map();
    let modelFieldLoadToken = 0;
    let activeModelFieldMetadata = {
      modelName: "",
      orderedFieldNames: [],
      roleMap: {
        word: null,
        definition: null,
        example: null,
        masked: null,
      },
    };
    const fieldEditors = new Map();
    const additionalFieldEditors = new Map();
    const PART_OF_SPEECH_ALIASES = {
      noun: ["noun", "n", "n.", "countable noun", "uncountable noun", "plural noun"],
      verb: ["verb", "v", "v.", "transitive verb", "intransitive verb", "phrasal verb"],
      adjective: ["adjective", "adj", "adj.", "adjectival"],
      adverb: ["adverb", "adv", "adv."],
      pronoun: ["pronoun", "prn", "prn."],
      preposition: ["preposition", "prep", "prep."],
      conjunction: ["conjunction", "conj", "conj."],
      interjection: ["interjection", "int", "int."],
      determiner: ["determiner", "det", "det.", "article"],
      idiom: ["idiom", "phrase", "set phrase", "expression", "idiomatic"],
    };
    const FIELD_ROLE_ALIASES = {
      word: ["word", "front", "term", "expression", "question", "prompt", "target"],
      definition: [
        "definition",
        "meaning",
        "back",
        "translation",
        "answer",
        "response",
        "explanation",
      ],
      example: ["example", "sentence", "usage", "context"],
    };
    const MASK_FIELD_ALIASES = ["w•••", "w...", "masked", "mask"];

    const htmlParser = document.createElement("div");

    let userModifiedNoteType = false;
    let pendingNoteTypeDeck = "";
    const providerSelectionRaw = safeParseJSON(
      getLocalStorageItem(LOCAL_STORAGE_KEYS.providerSelection),
      []
    );
    let activeSearchScope =
      getLocalStorageItem(LOCAL_STORAGE_KEYS.searchScope) || "online-decks";

    const activeProviderSelection = new Set(
      Array.isArray(providerSelectionRaw) ? providerSelectionRaw : []
    );

    if (!Object.values(SEARCH_SCOPES).includes(activeSearchScope)) {
      activeSearchScope = SEARCH_SCOPES.onlineDecks;
    }

    let lastPartOfSpeechFilter = "";

    function safeParseJSON(value, fallback = null) {
      if (!value) {
        return fallback;
      }
      try {
        return JSON.parse(value);
      } catch (error) {
        console.warn("Failed to parse session JSON", error);
        return fallback;
      }
    }

    function getSessionItem(key) {
      try {
        return sessionStorage.getItem(key);
      } catch (error) {
        console.warn("Session storage unavailable", error);
        return null;
      }
    }

    function setSessionItem(key, value) {
      try {
        if (value === null || value === undefined) {
          sessionStorage.removeItem(key);
        } else {
          sessionStorage.setItem(key, value);
        }
      } catch (error) {
        console.warn("Failed to persist session value", error);
      }
    }

    function getLocalStorageItem(key) {
      try {
        return localStorage.getItem(key);
      } catch (error) {
        console.warn("Local storage unavailable", error);
        return null;
      }
    }

    function setLocalStorageItem(key, value) {
      try {
        if (value === null || value === undefined) {
          localStorage.removeItem(key);
        } else {
          localStorage.setItem(key, value);
        }
      } catch (error) {
        console.warn("Failed to persist local value", error);
      }
    }

    const SIDEBAR_TOGGLE_LABELS = {
      expanded: "Hide sidebar",
      collapsed: "Show sidebar",
    };

    const focusableSidebarSelector = [
      "button:not([disabled])",
      "input:not([disabled])",
      "select:not([disabled])",
      "textarea:not([disabled])",
      "[href]",
      "[tabindex]:not([tabindex='-1'])",
    ].join(", ");

    function applySidebarCollapsedState(
      collapsed,
      { shouldStore = true, shouldFocus = false } = {}
    ) {
      if (!appContainer || !sidebarToggle) {
        return;
      }

      appContainer.classList.toggle("is-sidebar-collapsed", collapsed);
      sidebarToggle.setAttribute("aria-expanded", String(!collapsed));
      sidebarToggle.setAttribute(
        "aria-label",
        collapsed
          ? SIDEBAR_TOGGLE_LABELS.collapsed
          : SIDEBAR_TOGGLE_LABELS.expanded
      );
      sidebarToggle.setAttribute(
        "data-state",
        collapsed ? "collapsed" : "expanded"
      );

      if (shouldStore) {
        setLocalStorageItem(
          LOCAL_STORAGE_KEYS.sidebarCollapsed,
          collapsed ? "true" : "false"
        );
      }

      if (shouldFocus) {
        if (collapsed) {
          sidebarToggle.focus();
          return;
        }

        const focusTarget =
          (sidebar && sidebar.querySelector(focusableSidebarSelector)) ||
          sidebar;

        if (focusTarget) {
          if (focusTarget === sidebar && !sidebar.hasAttribute("tabindex")) {
            sidebar.setAttribute("tabindex", "-1");
          }
          focusTarget.focus();
        }
      }
    }

    function toggleSidebarState() {
      if (!appContainer) {
        return;
      }

      const currentlyCollapsed = appContainer.classList.contains(
        "is-sidebar-collapsed"
      );
      applySidebarCollapsedState(!currentlyCollapsed, { shouldFocus: true });
    }

    function initializeSidebarToggle() {
      if (!appContainer || !sidebar || !sidebarToggle) {
        return;
      }

      const storedPreference = getLocalStorageItem(
        LOCAL_STORAGE_KEYS.sidebarCollapsed
      );
      let collapsed = storedPreference === "true";

      if (storedPreference === null && window.matchMedia) {
        try {
          collapsed = window.matchMedia("(max-width: 980px)").matches;
        } catch (error) {
          collapsed = false;
        }
      }

      applySidebarCollapsedState(collapsed, { shouldStore: false });

      sidebarToggle.addEventListener("click", () => {
        toggleSidebarState();
      });

      sidebarToggle.addEventListener("keydown", (event) => {
        if (event.key === "Enter" || event.key === " ") {
          event.preventDefault();
          toggleSidebarState();
        }
      });

      if (sidebar) {
        sidebar.addEventListener("keydown", (event) => {
          if (
            event.key === "Escape" &&
            !appContainer.classList.contains("is-sidebar-collapsed")
          ) {
            event.preventDefault();
            applySidebarCollapsedState(true, { shouldFocus: true });
          }
        });
      }
    }

    function canonicalizePartOfSpeech(label) {
      if (!label) {
        return "";
      }

      const cleaned = label
        .toString()
        .toLowerCase()
        .replace(/<[^>]*>/g, "")
        .replace(/[^a-z\s]/g, " ")
        .replace(/\s+/g, " ")
        .trim();

      if (!cleaned) {
        return "";
      }

      for (const [canonical, aliases] of Object.entries(PART_OF_SPEECH_ALIASES)) {
        if (aliases.some((alias) => cleaned === alias || cleaned.includes(alias))) {
          return canonical;
        }
      }

      return cleaned;
    }

    function generateSearchVariants(term) {
      const variants = new Set();
      const trimmed = (term || "").trim();
      if (!trimmed) {
        return [];
      }

      variants.add(trimmed);
      variants.add(trimmed.replace(/\s+/g, "-"));
      variants.add(trimmed.replace(/\s+/g, ""));
      variants.add(trimmed.replace(/-/g, " "));
      variants.add(trimmed.replace(/-/g, ""));
      variants.add(trimmed.replace(/[’']/g, ""));

      return Array.from(variants).filter(Boolean);
    }

    function parseLookupTerm(rawTerm) {
      const original = rawTerm;
      let working = rawTerm.trim();
      let posHint = "";

      const asMatch = working.match(/^(.*?)[\s,:-]*as\s+an?\s+([a-z-]+)/i);
      if (asMatch) {
        working = asMatch[1].trim();
        posHint = posHint || asMatch[2].trim();
      }

      const parenMatch = working.match(/^(.*?)[\s]*\(([^)]+)\)\s*$/);
      if (parenMatch) {
        working = parenMatch[1].trim();
        posHint = posHint || parenMatch[2].trim();
      }

      const commaMatch = working.match(/^(.*?)[\s,;-]+(noun|verb|adjective|adverb|pronoun|preposition|conjunction|interjection|idiom|phrase)$/i);
      if (commaMatch) {
        working = commaMatch[1].trim();
        posHint = posHint || commaMatch[2].trim();
      }

      const partOfSpeech = canonicalizePartOfSpeech(posHint);
      const normalizedTerm = working.replace(/\s+/g, " ").trim();
      const variants = generateSearchVariants(normalizedTerm);
      const tokens = normalizedTerm.split(/\s+/).filter(Boolean);

      return {
        originalTerm: original,
        term: normalizedTerm,
        partOfSpeech,
        variants,
        tokens,
      };
    }

    function filterEntryByPartOfSpeech(entry, partOfSpeech) {
      if (!partOfSpeech || !entry || !Array.isArray(entry.meanings)) {
        return entry;
      }

      const filteredMeanings = entry.meanings
        .map((meaning) => {
          if (!meaning || !Array.isArray(meaning.definitions) || !meaning.definitions.length) {
            return null;
          }

          const meaningPos = canonicalizePartOfSpeech(meaning.partOfSpeech || "");

          if (meaningPos) {
            if (meaningPos !== partOfSpeech && !meaningPos.includes(partOfSpeech)) {
              return null;
            }
          } else {
            const rawPos = (meaning.partOfSpeech || "").toString().toLowerCase();
            if (rawPos && !rawPos.includes(partOfSpeech)) {
              return null;
            }
          }

          return {
            ...meaning,
            partOfSpeech: meaning.partOfSpeech,
            definitions: meaning.definitions,
          };
        })
        .filter(Boolean);

      if (!filteredMeanings.length) {
        return null;
      }

      return {
        ...entry,
        meanings: filteredMeanings,
      };
    }

    function getProviderCredentials() {
      return {};
    }

    function persistProviderSelection() {
      const ids = Array.from(activeProviderSelection);
      if (!ids.length) {
        setLocalStorageItem(LOCAL_STORAGE_KEYS.providerSelection, null);
        return;
      }
      setLocalStorageItem(LOCAL_STORAGE_KEYS.providerSelection, JSON.stringify(ids));
    }

    function getActiveDictionaryProviderIds() {
      if (activeProviderSelection.size) {
        return Array.from(activeProviderSelection).filter(
          (id) => !!dictionaryProviders[id]
        );
      }

      return Object.values(dictionaryProviders)
        .filter((provider) => provider?.defaultEnabled !== false)
        .map((provider) => provider.id);
    }

    function updateDictionaryScopeLabel(partOfSpeechLabel = lastPartOfSpeechFilter) {
      if (!dictionaryScopeDisplay) {
        return;
      }

      const providerIds = activeSearchScope === SEARCH_SCOPES.decksOnly
        ? []
        : getActiveDictionaryProviderIds();

      const providerLabels = providerIds
        .map((id) => dictionaryProviders[id]?.label || id)
        .filter(Boolean);

      let providerSummary = "No online dictionaries";
      if (providerLabels.length === 1) {
        providerSummary = providerLabels[0];
      } else if (providerLabels.length > 1) {
        if (providerLabels.length <= 3) {
          providerSummary = providerLabels.join(", ");
        } else {
          providerSummary = `${providerLabels.slice(0, 2).join(", ")}, +${
            providerLabels.length - 2
          } more`;
        }
      }

      const scopeLabelMap = {
        [SEARCH_SCOPES.onlineDecks]: "Online + decks",
        [SEARCH_SCOPES.onlineOnly]: "Online only",
        [SEARCH_SCOPES.decksOnly]: "Decks only",
      };

      const scopeText = scopeLabelMap[activeSearchScope] || "Custom scope";

      const parts = [scopeText];
      if (activeSearchScope !== SEARCH_SCOPES.decksOnly) {
        parts.push(providerSummary);
      }
      if (partOfSpeechLabel) {
        parts.push(`POS: ${partOfSpeechLabel}`);
      }

      dictionaryScopeDisplay.textContent = parts.join(" • ");
    }

    function setSearchScope(scope) {
      if (!scope || activeSearchScope === scope) {
        updateDictionaryScopeLabel();
        return;
      }

      activeSearchScope = scope;
      setLocalStorageItem(LOCAL_STORAGE_KEYS.searchScope, scope);

      scopeToggleButtons.forEach((button) => {
        button.classList.toggle("is-active", button.dataset.scope === scope);
      });

      updateDictionaryScopeLabel();
    }

    function initializeScopeButtons() {
      scopeToggleButtons.forEach((button) => {
        const scope = button.dataset.scope;
        button.classList.toggle("is-active", scope === activeSearchScope);
        button.addEventListener("click", () => {
          setSearchScope(scope);
        });
      });
    }

    function initializeDictionaryProviderOptions() {
      if (!dictionaryProviderGrid) {
        return;
      }

      dictionaryProviderGrid.innerHTML = "";

      const defaultsAdded = new Set();

      Object.values(dictionaryProviders).forEach((provider) => {
        if (!provider || provider.hidden) {
          return;
        }

        const option = document.createElement("label");
        option.className = "provider-option";

        const checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkbox.value = provider.id;

        let isSelected = activeProviderSelection.has(provider.id);
        if (!activeProviderSelection.size && provider.defaultEnabled !== false) {
          isSelected = true;
          defaultsAdded.add(provider.id);
        }

        checkbox.checked = isSelected;
        if (isSelected) {
          activeProviderSelection.add(provider.id);
        }

        checkbox.addEventListener("change", () => {
          if (checkbox.checked) {
            activeProviderSelection.add(provider.id);
          } else {
            activeProviderSelection.delete(provider.id);
          }
          persistProviderSelection();
          updateDictionaryScopeLabel();
        });

        option.appendChild(checkbox);

        const labelText = document.createElement("span");
        labelText.textContent = provider.label || provider.id;
        option.appendChild(labelText);

        dictionaryProviderGrid.appendChild(option);
      });

      if (defaultsAdded.size) {
        persistProviderSelection();
      }

      updateDictionaryScopeLabel();
    }

    function persistCredentials() {
      const username = usernameInput.value.trim();
      const password = passwordInput.value;
      if (!username && !password) {
        setSessionItem(SESSION_KEYS.credentials, null);
        return;
      }

      setSessionItem(
        SESSION_KEYS.credentials,
        JSON.stringify({ username, password })
      );
    }

    function persistDeckSelection() {
      const deck = deckSelect.value;
      if (deck) {
        setSessionItem(SESSION_KEYS.deck, deck);
      } else {
        setSessionItem(SESSION_KEYS.deck, null);
      }
    }

    function setStatus(message, type = "") {
      statusEl.textContent = message;
      statusEl.className = "status" + (type ? " " + type : "");
    }

    function hideSetupNotice() {
      if (setupNotice) {
        setupNotice.classList.add("is-hidden");
      }
    }

    function showSetupNotice() {
      if (setupNotice) {
        setupNotice.classList.remove("is-hidden");
      }
    }

    let hasSuccessfulAnkiConnect =
      getSessionItem(SESSION_KEYS.setupNoticeDismissed) === "true";

    if (hasSuccessfulAnkiConnect) {
      hideSetupNotice();
    } else {
      showSetupNotice();
    }

    function markAnkiConnectSuccess() {
      if (hasSuccessfulAnkiConnect) {
        return;
      }
      hasSuccessfulAnkiConnect = true;
      hideSetupNotice();
      setSessionItem(SESSION_KEYS.setupNoticeDismissed, "true");
    }

    const savedCredentials = safeParseJSON(getSessionItem(SESSION_KEYS.credentials), {});
    if (savedCredentials?.username) {
      usernameInput.value = savedCredentials.username;
    }
    if (savedCredentials?.password) {
      passwordInput.value = savedCredentials.password;
    }

    function updatePreview() {
      const deckName = deckSelect.value ? deckSelect.value : "—";
      previewDeck.textContent = deckName;
      previewModel.textContent = modelNameInput.value.trim() || DEFAULT_MODEL_NAME;
      const tags = tagsInput.value.trim();
      previewTags.textContent = tags || "—";
      previewFront.textContent = frontField.value;
      previewBack.textContent = backField.value;
      previewExample.textContent = exampleField.value;
    }

    [frontField, backField, exampleField, tagsInput].forEach((element) => {
      element.addEventListener("input", () => {
        updatePreview();
        if (element === frontField) {
          refreshMaskedWordField();
        }
        if (element?.tagName === "TEXTAREA") {
          adjustTextareaHeight(element);
        }
      });
      element.addEventListener("change", () => {
        updatePreview();
        if (element === frontField) {
          refreshMaskedWordField();
        }
        if (element?.tagName === "TEXTAREA") {
          adjustTextareaHeight(element);
        }
      });
    });

    [frontField, backField, exampleField].forEach((textarea) => {
      adjustTextareaHeight(textarea);
    });

    function handleModelNameInput(event) {
      userModifiedNoteType = true;
      updatePreview();
      if (event?.type === "change") {
        refreshModelFieldsForCurrentModel();
      }
    }

    modelNameInput.addEventListener("input", handleModelNameInput);
    modelNameInput.addEventListener("change", handleModelNameInput);

    function updateModelSuggestions(noteTypes) {
      if (!modelSuggestions) {
        return;
      }

      modelSuggestions.innerHTML = "";
      noteTypes.forEach((noteType) => {
        if (!noteType) {
          return;
        }
        const option = document.createElement("option");
        option.value = noteType;
        modelSuggestions.appendChild(option);
      });
    }

    deckSelect.addEventListener("change", () => {
      persistDeckSelection();
      userModifiedNoteType = false;
      updatePreview();
      const deckName = deckSelect.value;
      if (deckName) {
        loadNoteTypesForDeck(deckName);
      } else {
        updateModelSuggestions([]);
      }
    });

    usernameInput.addEventListener("input", persistCredentials);
    passwordInput.addEventListener("input", persistCredentials);
    async function callAnkiConnect(action, params = {}) {
      let response;
      try {
        response = await fetch("http://127.0.0.1:8765", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ action, version: 6, params }),
        });
      } catch (networkError) {
        console.error(networkError);
        throw new Error(
          "Unable to reach AnkiConnect. Please ensure Anki is running and the AnkiConnect add-on is installed."
        );
      }

      if (!response.ok) {
        throw new Error(`AnkiConnect request failed: ${response.status}`);
      }

      const data = await response.json();
      if (data.error) {
        throw new Error(data.error);
      }

      markAnkiConnectSuccess();

      return data.result;
    }

    function textContainsTerm(text, term) {
      return text && term && text.toLowerCase().includes(term.toLowerCase());
    }

    function cleanExample(example) {
      if (!example) {
        return "";
      }
      const cleaned = stripHtml(example)
        .replace(/\s+/g, " ")
        .replace(/[\[\]]/g, "")
        .trim();
      return cleaned;
    }

    function normalizeDefinitions(definitions = []) {
      return definitions
        .map((item) => {
          if (!item) {
            return null;
          }
          const definition = stripHtml(
            (item.definition || item.meaning || item.text || "").toString()
          ).trim();
          if (!definition) {
            return null;
          }
          let example = "";
          if (typeof item.example === "string") {
            example = cleanExample(item.example);
          } else if (Array.isArray(item.examples) && item.examples.length) {
            example = cleanExample(item.examples[0]);
          }
          return { definition, example };
        })
        .filter(Boolean);
    }

    function extractNodeText(node) {
      if (!node) {
        return "";
      }
      return node.textContent.replace(/\s+/g, " ").trim();
    }

    function queryTextContent(root, selectors) {
      if (!root || !selectors) {
        return "";
      }

      const selectorList = Array.isArray(selectors) ? selectors : [selectors];
      for (const selector of selectorList) {
        if (!selector) {
          continue;
        }
        const element = root.querySelector(selector);
        const text = extractNodeText(element);
        if (text) {
          return text;
        }
      }

      return "";
    }

    function buildDictionarySlugCandidates(term) {
      const normalized = (term || "").trim();
      if (!normalized) {
        return [];
      }

      const compact = normalized.replace(/\s+/g, " ");
      const sanitized = compact.replace(/['"`]/g, "");
      const hyphenated = sanitized.replace(/\s+/g, "-");
      const simple = sanitized.replace(/\s+/g, "");

      const candidates = new Set([
        compact,
        hyphenated,
        simple,
        compact.toLowerCase(),
        hyphenated.toLowerCase(),
        simple.toLowerCase(),
      ]);

      return Array.from(candidates).filter(Boolean);
    }

    const DICTIONARY_PROXY_HOSTS = new Set([
      "www.merriam-webster.com",
      "www.ldoceonline.com",
      "www.oxfordlearnersdictionaries.com",
      "dictionary.cambridge.org",
    ]);

    function rewriteDictionaryRequestUrl(url) {
      if (!url) {
        return url;
      }

      try {
        const base =
          typeof window !== "undefined" && window.location
            ? window.location.origin
            : "http://localhost";
        const targetUrl = new URL(url, base);

        if (targetUrl.pathname === "/proxy") {
          return url;
        }

        const host = targetUrl.host.toLowerCase();
        if (!DICTIONARY_PROXY_HOSTS.has(host)) {
          return url;
        }

        const encoded = encodeURIComponent(targetUrl.toString());
        return `/proxy?url=${encoded}`;
      } catch (error) {
        return url;
      }
    }

    async function fetchHtmlDocument(url, { label } = {}) {
      const requestUrl = rewriteDictionaryRequestUrl(url);
      let response;
      try {
        response = await fetch(requestUrl, {
          headers: {
            Accept: "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
          },
        });
      } catch (networkError) {
        throw new Error(label || "Lookup failed (network error)");
      }

      if (response.status === 404) {
        return null;
      }

      if (!response.ok) {
        throw new Error((label || "Lookup failed") + ` (status ${response.status})`);
      }

      const html = await response.text();
      const parser = new DOMParser();
      return parser.parseFromString(html, "text/html");
    }

    function normalizeUrbanEntries(data, term) {
      const list = Array.isArray(data?.list) ? data.list.slice(0, 10) : [];
      return list
        .map((item, index) => {
          const definitions = normalizeDefinitions([
            {
              definition: item.definition,
              example: item.example,
            },
          ]);

          if (!definitions.length) {
            return null;
          }

          return {
            word: item.word || term,
            phonetic: "",
            source: "Urban Dictionary",
            meanings: [
              {
                partOfSpeech: item.word_type || item.tag || `Entry ${index + 1}`,
                definitions,
              },
            ],
          };
        })
        .filter(Boolean);
    }

    async function fetchUrbanEntries(term, parsedTerm) {
      const queryTerm = parsedTerm?.term || term;
      const response = await fetch(
        `https://api.urbandictionary.com/v0/define?term=${encodeURIComponent(queryTerm)}`
      );

      if (!response.ok) {
        throw new Error("Urban Dictionary lookup failed");
      }

      const data = await response.json();
      return normalizeUrbanEntries(data, queryTerm);
    }

    function normalizeLongmanEntries(documentNode, term) {
      if (!documentNode) {
        return [];
      }

      const definitionNodes = Array.from(
        documentNode.querySelectorAll("span.DEF, span.Def, span.definition")
      );

      if (!definitionNodes.length) {
        return [];
      }

      const meaningMap = new Map();
      let fallbackIndex = 1;

      definitionNodes.forEach((node) => {
        const definition = extractNodeText(node);
        if (!definition) {
          return;
        }

        const senseNode =
          node.closest(".Sense") ||
          node.closest(".sense") ||
          node.closest("[data-type='sense']") ||
          null;

        const exampleNode = senseNode
          ? senseNode.querySelector("span.EXAMPLE, span.EXA, span.example, .exa")
          : null;
        const example = extractNodeText(exampleNode);

        let partOfSpeech = "";
        if (senseNode) {
          partOfSpeech = queryTextContent(senseNode, [".POS", ".pos", ".posgram"]);
        }
        if (!partOfSpeech) {
          partOfSpeech = queryTextContent(
            node.closest(".dictentry") || documentNode,
            [".POS", ".pos", ".posgram"]
          );
        }
        if (!partOfSpeech) {
          partOfSpeech = `Sense ${fallbackIndex}`;
          fallbackIndex += 1;
        }

        if (!meaningMap.has(partOfSpeech)) {
          meaningMap.set(partOfSpeech, []);
        }

        meaningMap.get(partOfSpeech).push({ definition, example });
      });

      const meanings = Array.from(meaningMap.entries())
        .map(([partOfSpeech, definitionList]) => {
          const normalized = normalizeDefinitions(definitionList);
          if (!normalized.length) {
            return null;
          }
          return {
            partOfSpeech,
            definitions: normalized,
          };
        })
        .filter(Boolean);

      if (!meanings.length) {
        return [];
      }

      const headword =
        queryTextContent(documentNode, [".HWD", ".Head .HWD", "h1", ".headword"]) || term;
      const phonetic =
        queryTextContent(documentNode, [".PronCodes .PRON", ".PronCodes", ".pronunciation"]) || "";

      return [
        {
          word: headword || term,
          phonetic,
          source: "Longman",
          meanings,
        },
      ];
    }

    async function fetchLongmanEntries(term, parsedTerm) {
      const variants = Array.isArray(parsedTerm?.variants) && parsedTerm.variants.length
        ? parsedTerm.variants
        : [term];

      for (const variant of variants) {
        const tried = new Set();
        for (const slugCandidate of buildDictionarySlugCandidates(variant)) {
          if (tried.has(slugCandidate)) {
            continue;
          }
          tried.add(slugCandidate);

          const url = rewriteDictionaryRequestUrl(
            `https://www.ldoceonline.com/dictionary/${encodeURIComponent(slugCandidate)}`
          );
          const documentNode = await fetchHtmlDocument(url, { label: "Longman lookup failed" });

          if (!documentNode) {
            continue;
          }

          const entries = normalizeLongmanEntries(documentNode, variant);
          if (entries.length) {
            return entries;
          }
        }
      }

      return [];
    }

    function normalizeMerriamEntries(documentNode, term) {
      if (!documentNode) {
        return [];
      }

      const definitionNodes = Array.from(documentNode.querySelectorAll("span.dtText"));
      if (!definitionNodes.length) {
        return [];
      }

      const meaningMap = new Map();
      let fallbackIndex = 1;

      definitionNodes.forEach((node) => {
        let definition = extractNodeText(node);
        if (!definition) {
          return;
        }

        definition = definition.replace(/^[:·\s]+/, "").trim();
        if (!definition) {
          return;
        }

        const container = node.closest("li") || node.closest("div.sense") || node.parentElement;
        const exampleNode = container
          ? container.querySelector("span.ex-sent, span.t.has-snippet, span.ex-sent-first")
          : null;
        const example = extractNodeText(exampleNode);

        let partOfSpeech = "";
        if (container) {
          partOfSpeech = queryTextContent(container, ["span.fl"]);
        }
        if (!partOfSpeech) {
          partOfSpeech = queryTextContent(node.closest(".vg") || documentNode, ["span.fl"]);
        }
        if (!partOfSpeech) {
          partOfSpeech = `Sense ${fallbackIndex}`;
          fallbackIndex += 1;
        }

        if (!meaningMap.has(partOfSpeech)) {
          meaningMap.set(partOfSpeech, []);
        }

        meaningMap.get(partOfSpeech).push({ definition, example });
      });

      const meanings = Array.from(meaningMap.entries())
        .map(([partOfSpeech, definitionList]) => {
          const normalized = normalizeDefinitions(definitionList);
          if (!normalized.length) {
            return null;
          }
          return {
            partOfSpeech,
            definitions: normalized,
          };
        })
        .filter(Boolean);

      if (!meanings.length) {
        return [];
      }

      const headword =
        queryTextContent(documentNode, ["h1.hword", ".entry-header .hword", "h1"]) || term;
      const phonetic = queryTextContent(documentNode, ["span.prs span.pr", "span.pr"]);

      return [
        {
          word: headword || term,
          phonetic: phonetic || "",
          source: "Merriam-Webster",
          meanings,
        },
      ];
    }

    async function fetchMerriamEntries(term, parsedTerm) {
      const variants = Array.isArray(parsedTerm?.variants) && parsedTerm.variants.length
        ? parsedTerm.variants
        : [term];

      for (const variant of variants) {
        const tried = new Set();
        for (const slugCandidate of buildDictionarySlugCandidates(variant)) {
          if (tried.has(slugCandidate)) {
            continue;
          }
          tried.add(slugCandidate);

          const url = rewriteDictionaryRequestUrl(
            `https://www.merriam-webster.com/dictionary/${encodeURIComponent(slugCandidate)}`
          );
          const documentNode = await fetchHtmlDocument(url, {
            label: "Merriam-Webster lookup failed",
          });

          if (!documentNode) {
            continue;
          }

          const entries = normalizeMerriamEntries(documentNode, variant);
          if (entries.length) {
            return entries;
          }
        }
      }

      return [];
    }

    function normalizeCambridgeEntries(documentNode, term) {
      if (!documentNode) {
        return [];
      }

      const entryNodes = Array.from(
        documentNode.querySelectorAll(
          ".entry-body__el, .entry-body .entry-body__el, .dpr-entry-body .entry-body__el"
        )
      );

      if (!entryNodes.length) {
        return [];
      }

      const entries = [];

      entryNodes.forEach((entryNode) => {
        const headword =
          queryTextContent(entryNode, [
            ".pos-header .headword",
            ".pos-header .hw",
            ".di-title .headword",
            ".di-title",
          ]) || term;

        const phonetic =
          queryTextContent(entryNode, [
            ".pos-header .dpron",
            ".pos-header .ipa",
            ".pos-header .pron",
            ".pron .ipa",
          ]) || "";

        const definitionBlocks = Array.from(
          entryNode.querySelectorAll(
            ".ddef_block, .def-block, .sense-body .def-block, .sense-block .def-block"
          )
        );

        if (!definitionBlocks.length) {
          return;
        }

        const meaningMap = new Map();
        let fallbackIndex = 1;

        definitionBlocks.forEach((block) => {
          const headerText = extractNodeText(
            block.querySelector(
              ".ddef_h, .def-head, .def-title, .def, .def-block__header, .def-head__text"
            )
          );
          const bodyText = extractNodeText(
            block.querySelector(".ddef_b, .def-body, .def-block__body, .def-body__content")
          );

          const definition = [headerText, bodyText].filter(Boolean).join(" ").trim();
          if (!definition) {
            return;
          }

          const exampleNode =
            block.querySelector(
              ".examp, .eg, .deg, .example, .ddef_ex, .def-body__example, .example-sentences .eg"
            ) || null;
          const example = extractNodeText(exampleNode);

          let partOfSpeech = queryTextContent(block, [
            ".posgram .pos",
            ".pos",
            ".dpos",
          ]);
          if (!partOfSpeech) {
            partOfSpeech = queryTextContent(entryNode, [
              ".pos-header .dpos",
              ".pos-header .pos",
              ".posgram .pos",
            ]);
          }
          if (!partOfSpeech) {
            partOfSpeech = `Sense ${fallbackIndex}`;
            fallbackIndex += 1;
          }

          if (!meaningMap.has(partOfSpeech)) {
            meaningMap.set(partOfSpeech, []);
          }

          meaningMap.get(partOfSpeech).push({ definition, example });
        });

        const meanings = Array.from(meaningMap.entries())
          .map(([partOfSpeech, definitionList]) => {
            const normalized = normalizeDefinitions(definitionList);
            if (!normalized.length) {
              return null;
            }
            return {
              partOfSpeech,
              definitions: normalized,
            };
          })
          .filter(Boolean);

        if (!meanings.length) {
          return;
        }

        entries.push({
          word: headword || term,
          phonetic,
          source: "Cambridge",
          meanings,
        });
      });

      return entries;
    }

    async function fetchCambridgeEntries(term, parsedTerm) {
      const variants = Array.isArray(parsedTerm?.variants) && parsedTerm.variants.length
        ? parsedTerm.variants
        : [term];

      for (const variant of variants) {
        const tried = new Set();
        for (const slugCandidate of buildDictionarySlugCandidates(variant)) {
          if (tried.has(slugCandidate)) {
            continue;
          }
          tried.add(slugCandidate);

          const url = rewriteDictionaryRequestUrl(
            `https://dictionary.cambridge.org/dictionary/english/${encodeURIComponent(slugCandidate)}`
          );
          const documentNode = await fetchHtmlDocument(url, { label: "Cambridge lookup failed" });

          if (!documentNode) {
            continue;
          }

          const entries = normalizeCambridgeEntries(documentNode, variant);
          if (entries.length) {
            return entries;
          }
        }
      }

      return [];
    }

    async function fetchSynonymEntries(term, parsedTerm) {
      const queryTerm = parsedTerm?.term || term;
      const response = await fetch(
        `https://api.datamuse.com/words?rel_syn=${encodeURIComponent(queryTerm)}&max=30`
      );

      if (!response.ok) {
        throw new Error("Synonym lookup failed");
      }

      const data = await response.json();
      const synonyms = Array.isArray(data)
        ? data
            .map((item) => (typeof item === "string" ? item : item?.word))
            .filter(Boolean)
        : [];

      if (!synonyms.length) {
        return [];
      }

      return [
        {
          word: queryTerm,
          source: "Synonyms",
          isSynonymList: true,
          synonyms,
        },
      ];
    }

    async function fetchSpellingSuggestions(term) {
      if (!term) {
        return [];
      }

      try {
        const response = await fetch(
          `https://api.datamuse.com/sug?s=${encodeURIComponent(term)}&max=6`
        );
        if (!response.ok) {
          return [];
        }
        const data = await response.json();
        return Array.isArray(data)
          ? data
              .map((item) => (typeof item === "string" ? item : item?.word))
              .filter(Boolean)
          : [];
      } catch (error) {
        console.warn("Spelling suggestion lookup failed", error);
        return [];
      }
    }

    const dictionaryProviders = {
      longman: {
        id: "longman",
        label: "Longman",
        fetchEntries: fetchLongmanEntries,
        supportsEmbeddedSearch: true,
        defaultEnabled: true,
        type: "definition",
      },
      merriam: {
        id: "merriam",
        label: "Merriam-Webster",
        fetchEntries: fetchMerriamEntries,
        supportsEmbeddedSearch: false,
        defaultEnabled: true,
        type: "definition",
      },
      cambridge: {
        id: "cambridge",
        label: "Cambridge",
        fetchEntries: fetchCambridgeEntries,
        supportsEmbeddedSearch: true,
        defaultEnabled: true,
        type: "definition",
      },
      urban: {
        id: "urban",
        label: "Urban Dictionary",
        fetchEntries: fetchUrbanEntries,
        supportsEmbeddedSearch: false,
        defaultEnabled: false,
        type: "definition",
      },
      synonyms: {
        id: "synonyms",
        label: "Synonyms",
        fetchEntries: fetchSynonymEntries,
        supportsEmbeddedSearch: false,
        defaultEnabled: true,
        type: "synonym",
      },
    };

    initializeSidebarToggle();
    initializeScopeButtons();
    initializeDictionaryProviderOptions();

    async function searchWithinEntries(parsedTerm, providerId, credentials = {}) {
      const provider = dictionaryProviders[providerId];
      if (!provider || !provider.supportsEmbeddedSearch) {
        return [];
      }

      const tokens = Array.isArray(parsedTerm?.tokens) && parsedTerm.tokens.length
        ? parsedTerm.tokens
        : (parsedTerm?.term || "")
            .split(/\s+/)
            .map((token) => token.trim())
            .filter(Boolean);

      const seenTokens = new Set();
      const aggregated = [];

      for (const token of tokens) {
        const normalizedToken = token.toLowerCase();
        if (!normalizedToken || seenTokens.has(normalizedToken)) {
          continue;
        }
        seenTokens.add(normalizedToken);

        try {
          const tokenParsed = parseLookupTerm(token);
          const entries = await provider.fetchEntries(tokenParsed.term, tokenParsed, {
            credentials,
          });
          entries
            .filter((entry) => Array.isArray(entry?.meanings))
            .forEach((entry) => {
              const filteredMeanings = entry.meanings
                .map((meaning) => {
                  const filteredDefinitions = (meaning.definitions || []).filter(
                    (definition) =>
                      textContainsTerm(definition.definition, parsedTerm.term) ||
                      textContainsTerm(definition.example, parsedTerm.term)
                  );
                  if (!filteredDefinitions.length) {
                    return null;
                  }

                  return {
                    partOfSpeech: meaning.partOfSpeech,
                    definitions: filteredDefinitions,
                  };
                })
                .filter(Boolean);

              if (filteredMeanings.length) {
                aggregated.push({
                  ...entry,
                  meanings: filteredMeanings,
                  note: `Matches found inside entry for "${token}"`,
                });
              }
            });
        } catch (error) {
          console.warn(`Embedded search failed for token "${token}"`, error);
        }
      }

      return aggregated;
    }

    function escapeRegExp(value) {
      if (value === null || value === undefined) {
        return "";
      }

      return String(value).replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }

    function escapeDeckNameForQuery(deckName) {
      if (!deckName) {
        return "";
      }

      return deckName.replace(/\\/g, "\\\\").replace(/"/g, '\\"');
    }

    function escapeSearchTerm(term) {
      if (!term) {
        return "";
      }

      return term.replace(/"/g, '\\"').trim();
    }

    function stripHtml(value) {
      if (!value) {
        return "";
      }

      htmlParser.innerHTML = value;
      const text = htmlParser.textContent || htmlParser.innerText || "";
      htmlParser.textContent = "";
      return text.trim();
    }

    function normalizeFieldIdentifier(value) {
      return (value || "").replace(/\s+/g, "").toLowerCase();
    }

    function createFieldEditorId(fieldName) {
      const slug = (fieldName || "")
        .toString()
        .trim()
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, "-")
        .replace(/^-+|-+$/g, "");
      const fallback = Math.random().toString(36).slice(2, 10);
      return `additional-${slug || fallback}`;
    }

    function computeFieldRoleMap(fieldNames = []) {
      const normalizedEntries = fieldNames
        .filter((name) => typeof name === "string" && name.trim())
        .map((name, index) => ({
          name,
          index,
          lower: name.toLowerCase(),
          compact: normalizeFieldIdentifier(name),
        }));

      const used = new Set();
      const roleMap = {
        word: null,
        definition: null,
        example: null,
        masked: null,
      };

      const findByAliases = (aliases = [], { allowPartial = true } = {}) => {
        for (const alias of aliases) {
          const aliasLower = alias.toLowerCase();
          const aliasCompact = normalizeFieldIdentifier(alias);
          for (const entry of normalizedEntries) {
            if (used.has(entry.name)) {
              continue;
            }
            if (entry.lower === aliasLower || entry.compact === aliasCompact) {
              used.add(entry.name);
              return entry.name;
            }
          }
        }

        if (!allowPartial) {
          return null;
        }

        for (const alias of aliases) {
          const aliasLower = alias.toLowerCase();
          const aliasCompact = normalizeFieldIdentifier(alias);
          for (const entry of normalizedEntries) {
            if (used.has(entry.name)) {
              continue;
            }
            if (
              entry.lower.includes(aliasLower) ||
              entry.compact.includes(aliasCompact)
            ) {
              used.add(entry.name);
              return entry.name;
            }
          }
        }

        return null;
      };

      const maskedField = findByAliases(MASK_FIELD_ALIASES);
      if (maskedField) {
        roleMap.masked = maskedField;
      }

      const wordField = findByAliases(FIELD_ROLE_ALIASES.word);
      if (wordField) {
        roleMap.word = wordField;
      }

      const definitionField = findByAliases(FIELD_ROLE_ALIASES.definition);
      if (definitionField) {
        roleMap.definition = definitionField;
      }

      const exampleField = findByAliases(FIELD_ROLE_ALIASES.example);
      if (exampleField) {
        roleMap.example = exampleField;
      }

      if (!roleMap.word && normalizedEntries.length) {
        const fallback = normalizedEntries.find((entry) => !used.has(entry.name));
        if (fallback) {
          roleMap.word = fallback.name;
          used.add(fallback.name);
        }
      }

      if (!roleMap.definition && normalizedEntries.length) {
        const fallback = normalizedEntries.find((entry) => !used.has(entry.name));
        if (fallback) {
          roleMap.definition = fallback.name;
          used.add(fallback.name);
        }
      }

      if (!roleMap.example && normalizedEntries.length > 2) {
        const fallback = normalizedEntries
          .slice()
          .reverse()
          .find((entry) => !used.has(entry.name));
        if (fallback) {
          roleMap.example = fallback.name;
          used.add(fallback.name);
        }
      }

      return roleMap;
    }

    function deriveMaskedWordValue(wordValue) {
      const plain = stripHtml(wordValue || "");
      if (!plain) {
        return "";
      }
      return maskTargetInText(plain, plain);
    }

    function updateNoteDetailsDisplay(noteDetails) {
      if (!noteDetails) {
        return;
      }

      const orderedFieldNames = Array.isArray(noteDetails.orderedFields)
        ? noteDetails.orderedFields.map((field) => field.name)
        : [];
      const fields = noteDetails.fields || {};
      const roleMap = noteDetails.roleMap || {};

      const wordFieldName =
        roleMap.word || orderedFieldNames[0] || Object.keys(fields)[0] || null;
      const definitionFieldName =
        roleMap.definition ||
        orderedFieldNames.find((name) => name && name !== wordFieldName) ||
        null;
      const exampleFieldName = roleMap.example || null;

      const frontValue = wordFieldName ? fields[wordFieldName] || "" : "";
      const backValue = definitionFieldName ? fields[definitionFieldName] || "" : "";
      const exampleValue = exampleFieldName ? fields[exampleFieldName] || "" : "";

      noteDetails.display = {
        frontText: stripHtml(frontValue),
        backText: stripHtml(backValue),
        exampleText: stripHtml(exampleValue),
      };
    }

    function getActiveWordFieldName(metadata = activeModelFieldMetadata) {
      if (!metadata) {
        return null;
      }
      return (
        metadata.roleMap?.word ||
        (Array.isArray(metadata.orderedFieldNames)
          ? metadata.orderedFieldNames[0]
          : null)
      );
    }

    function refreshMaskedWordField() {
      const maskedFieldName = activeModelFieldMetadata.roleMap?.masked;
      const wordFieldName = getActiveWordFieldName();
      if (!maskedFieldName || !wordFieldName) {
        return;
      }

      const wordEditor = fieldEditors.get(wordFieldName);
      const maskedEditor = fieldEditors.get(maskedFieldName);
      if (!wordEditor || !maskedEditor) {
        return;
      }

      maskedEditor.value = deriveMaskedWordValue(wordEditor.value);
      adjustTextareaHeight(maskedEditor);
    }

    function applyModelFieldMetadata(
      modelName,
      orderedFieldNames = [],
      roleMapOverride = null
    ) {
      const normalizedFieldNames = Array.isArray(orderedFieldNames)
        ? orderedFieldNames.filter((name) => typeof name === "string" && name.trim())
        : [];
      const roleMap = roleMapOverride || computeFieldRoleMap(normalizedFieldNames);

      const preservedValues = new Map();
      fieldEditors.forEach((element, fieldName) => {
        if (fieldName && element) {
          preservedValues.set(fieldName, element.value);
        }
      });

      fieldEditors.clear();
      additionalFieldEditors.clear();

      if (additionalFieldsContainer) {
        additionalFieldsContainer.innerHTML = "";
        additionalFieldsContainer.hidden = true;
      }

      if (maskedFieldContainer) {
        maskedFieldContainer.innerHTML = "";
        maskedFieldContainer.hidden = true;
      }

      const assignedFields = new Set();

      const assignPrimaryEditor = (element, labelElement, defaultLabel, fieldName) => {
        if (!element) {
          return;
        }

        const previousValue =
          fieldName && preservedValues.has(fieldName) ? preservedValues.get(fieldName) : "";
        element.dataset.fieldName = fieldName || "";
        element.value = fieldName ? previousValue : "";
        if (element.tagName === "TEXTAREA") {
          adjustTextareaHeight(element);
        }

        if (labelElement) {
          labelElement.textContent = fieldName || defaultLabel;
        }

        if (fieldName) {
          fieldEditors.set(fieldName, element);
          assignedFields.add(fieldName);
        }
      };

      const wordFieldName = roleMap.word || normalizedFieldNames[0] || null;
      const definitionFieldName =
        roleMap.definition ||
        normalizedFieldNames.find((name) => name && name !== wordFieldName) ||
        null;
      const exampleFieldName = roleMap.example || null;
      const maskedFieldName = roleMap.masked || null;

      assignPrimaryEditor(frontField, frontFieldLabel, DEFAULT_FIELD_LABELS.front, wordFieldName);
      assignPrimaryEditor(backField, backFieldLabel, DEFAULT_FIELD_LABELS.back, definitionFieldName);

      if (exampleFieldWrapper) {
        exampleFieldWrapper.hidden = !exampleFieldName;
      }
      assignPrimaryEditor(
        exampleField,
        exampleFieldLabel,
        DEFAULT_FIELD_LABELS.example,
        exampleFieldName
      );
      if (!exampleFieldName && exampleField) {
        exampleField.value = "";
        adjustTextareaHeight(exampleField);
      }

      if (maskedFieldName && maskedFieldContainer) {
        const previousValue = preservedValues.has(maskedFieldName)
          ? preservedValues.get(maskedFieldName)
          : "";
        const label = document.createElement("label");
        const editorId = createFieldEditorId(maskedFieldName);
        label.htmlFor = editorId;
        label.textContent = maskedFieldName;

        const textarea = document.createElement("textarea");
        textarea.id = editorId;
        textarea.dataset.fieldName = maskedFieldName;
        textarea.readOnly = true;
        textarea.value = previousValue;
        textarea.addEventListener("input", () => adjustTextareaHeight(textarea));

        maskedFieldContainer.appendChild(label);
        maskedFieldContainer.appendChild(textarea);
        maskedFieldContainer.hidden = false;
        adjustTextareaHeight(textarea);

        fieldEditors.set(maskedFieldName, textarea);
        assignedFields.add(maskedFieldName);
      }

      if (additionalFieldsContainer) {
        normalizedFieldNames.forEach((fieldName) => {
          if (!fieldName || assignedFields.has(fieldName)) {
            return;
          }

          const wrapper = document.createElement("div");
          wrapper.className = "additional-field";

          const label = document.createElement("label");
          const editorId = createFieldEditorId(fieldName);
          label.htmlFor = editorId;
          label.textContent = fieldName;

          const textarea = document.createElement("textarea");
          textarea.id = editorId;
          textarea.dataset.fieldName = fieldName;
          textarea.value = preservedValues.get(fieldName) ?? "";
          if (fieldName === maskedFieldName) {
            textarea.readOnly = true;
          }
          textarea.addEventListener("input", () => adjustTextareaHeight(textarea));

          wrapper.appendChild(label);
          wrapper.appendChild(textarea);
          additionalFieldsContainer.appendChild(wrapper);
          adjustTextareaHeight(textarea);

          fieldEditors.set(fieldName, textarea);
          additionalFieldEditors.set(fieldName, { element: textarea, label, wrapper });
        });

        additionalFieldsContainer.hidden = additionalFieldEditors.size === 0;
      }

      if (maskedFieldName) {
        const maskedEditor = fieldEditors.get(maskedFieldName);
        if (maskedEditor) {
          maskedEditor.readOnly = true;
        }
      }

      activeModelFieldMetadata = {
        modelName,
        orderedFieldNames: normalizedFieldNames,
        roleMap: {
          word: wordFieldName,
          definition: definitionFieldName,
          example: exampleFieldName,
          masked: maskedFieldName,
        },
      };

      if (modelName && normalizedFieldNames.length) {
        modelFieldCache.set(modelName, {
          orderedFieldNames: normalizedFieldNames,
          roleMap: activeModelFieldMetadata.roleMap,
        });
      }

      updatePreview();
      refreshMaskedWordField();
      fieldEditors.forEach((editor) => adjustTextareaHeight(editor));
    }

    async function ensureModelFieldMetadata(modelName) {
      if (!modelName) {
        return { orderedFieldNames: [], roleMap: {} };
      }

      const cached = modelFieldCache.get(modelName);
      if (cached && Array.isArray(cached.orderedFieldNames) && cached.orderedFieldNames.length) {
        return cached;
      }

      if (pendingModelFieldRequests.has(modelName)) {
        return pendingModelFieldRequests.get(modelName);
      }

      const requestPromise = (async () => {
        let orderedFieldNames = [];

        try {
          const fieldConfig = await callAnkiConnect("modelFieldNamesAndConfig", { modelName });
          if (fieldConfig && Array.isArray(fieldConfig.fields)) {
            orderedFieldNames = fieldConfig.fields
              .slice()
              .sort((a, b) => (a?.ord ?? 0) - (b?.ord ?? 0))
              .map((field) => field.name)
              .filter(Boolean);
          }
        } catch (error) {
          console.warn(`modelFieldNamesAndConfig failed for "${modelName}"`, error);
        }

        if (!orderedFieldNames.length) {
          const fallbackNames = await callAnkiConnect("modelFieldNames", { modelName });
          if (Array.isArray(fallbackNames)) {
            orderedFieldNames = fallbackNames.filter(Boolean);
          }
        }

        if (!orderedFieldNames.length) {
          throw new Error(`No fields available for "${modelName}".`);
        }

        const metadata = {
          orderedFieldNames,
          roleMap: computeFieldRoleMap(orderedFieldNames),
        };

        modelFieldCache.set(modelName, metadata);
        return metadata;
      })();

      pendingModelFieldRequests.set(modelName, requestPromise);

      try {
        return await requestPromise;
      } finally {
        pendingModelFieldRequests.delete(modelName);
      }
    }

    async function refreshModelFieldsForCurrentModel({ modelName } = {}) {
      const resolvedModelName = modelName || modelNameInput.value.trim() || DEFAULT_MODEL_NAME;
      const requestId = ++modelFieldLoadToken;

      try {
        const metadata = await ensureModelFieldMetadata(resolvedModelName);
        if (requestId !== modelFieldLoadToken) {
          return metadata;
        }

        applyModelFieldMetadata(
          resolvedModelName,
          metadata.orderedFieldNames,
          metadata.roleMap
        );

        return metadata;
      } catch (error) {
        if (requestId !== modelFieldLoadToken) {
          return null;
        }

        console.warn(`Failed to load field metadata for "${resolvedModelName}"`, error);
        applyModelFieldMetadata(resolvedModelName, [], null);
        return null;
      }
    }

    function createNoteDetails(note, deckName) {
      if (!note || !note.noteId || !note.fields) {
        return null;
      }

      const fieldEntries = Object.entries(note.fields)
        .map(([name, payload], index) => ({
          name,
          value:
            payload && typeof payload.value === "string" ? payload.value : "",
          order: typeof payload?.order === "number" ? payload.order : index,
        }))
        .filter((entry) => entry.name);

      if (!fieldEntries.length) {
        return null;
      }

      fieldEntries.sort((a, b) => (a.order ?? 0) - (b.order ?? 0));

      const orderedFields = fieldEntries.map((entry) => ({ ...entry }));
      const fields = {};
      orderedFields.forEach((entry) => {
        fields[entry.name] = entry.value;
      });

      const fieldNames = orderedFields.map((entry) => entry.name);
      const roleMap = computeFieldRoleMap(fieldNames);

      const noteDetails = {
        id: note.noteId,
        deckName,
        modelName: note.modelName || "",
        tags: Array.isArray(note.tags) ? note.tags : [],
        orderedFields,
        fields,
        roleMap,
        display: {
          frontText: "",
          backText: "",
          exampleText: "",
        },
      };

      updateNoteDetailsDisplay(noteDetails);

      return noteDetails;
    }

    function mapDeckNotesToEntries(notesInfo, deckName, term) {
      if (!Array.isArray(notesInfo)) {
        return [];
      }

      return notesInfo
        .map((note) => {
          const noteDetails = createNoteDetails(note, deckName);
          if (!noteDetails) {
            return null;
          }

          const definitionText = noteDetails.display.backText || "(Back field is empty)";

          return {
            uniqueKey: `note-${noteDetails.id}`,
            word: noteDetails.display.frontText || term,
            source: deckName,
            deckName,
            isExistingNote: true,
            noteDetails,
            meanings: [
              {
                partOfSpeech: noteDetails.modelName || "Card content",
                definitions: [
                  {
                    definition: definitionText,
                    example: noteDetails.display.exampleText || "",
                  },
                ],
              },
            ],
            note: `Saved note #${noteDetails.id} in "${deckName}"`,
          };
        })
        .filter(Boolean);
    }

    async function findDeckEntries(term, deckName) {
      if (!deckName) {
        return {
          deckName: "",
          entries: [],
          totalCount: 0,
          shownCount: 0,
          truncated: false,
          error: "",
        };
      }

      const sanitizedDeckName = escapeDeckNameForQuery(deckName);
      const sanitizedTerm = escapeSearchTerm(term);
      const queryParts = [`deck:"${sanitizedDeckName}"`];
      if (sanitizedTerm) {
        queryParts.push(`"${sanitizedTerm}"`);
      }

      const query = queryParts.join(" ");

      try {
        const noteIds = await callAnkiConnect("findNotes", { query });
        if (!Array.isArray(noteIds) || !noteIds.length) {
          return {
            deckName,
            entries: [],
            totalCount: 0,
            shownCount: 0,
            truncated: false,
            error: "",
          };
        }

        const limitedNoteIds = noteIds.slice(0, NOTE_SEARCH_LIMIT);
        const notesInfo = await callAnkiConnect("notesInfo", { notes: limitedNoteIds });
        const entries = mapDeckNotesToEntries(notesInfo, deckName, sanitizedTerm || term);

        return {
          deckName,
          entries,
          totalCount: noteIds.length,
          shownCount: entries.length,
          truncated: noteIds.length > limitedNoteIds.length,
          error: "",
        };
      } catch (error) {
        console.warn(`Deck lookup failed for "${deckName}"`, error);
        return {
          deckName,
          entries: [],
          totalCount: 0,
          shownCount: 0,
          truncated: false,
          error: error?.message || "Deck lookup failed.",
        };
      }
    }

    function applyNoteToEditor(noteDetails) {
      if (!noteDetails) {
        return;
      }

      const modelName =
        noteDetails.modelName || modelNameInput.value.trim() || DEFAULT_MODEL_NAME;

      if (modelName) {
        modelNameInput.value = modelName;
        userModifiedNoteType = false;
      }

      const fieldNames = Array.isArray(noteDetails.orderedFields)
        ? noteDetails.orderedFields.map((field) => field.name)
        : Object.keys(noteDetails.fields || {});

      applyModelFieldMetadata(modelName, fieldNames, noteDetails.roleMap);

      const fields = noteDetails.fields || {};
      fieldEditors.forEach((editor, fieldName) => {
        if (!editor) {
          return;
        }
        editor.value = fields[fieldName] || "";
        adjustTextareaHeight(editor);
      });

      noteDetails.modelName = modelName;
      noteDetails.roleMap = activeModelFieldMetadata.roleMap;

      if (Array.isArray(noteDetails.orderedFields)) {
        noteDetails.orderedFields.forEach((entry) => {
          if (!entry || !entry.name) {
            return;
          }
          const editor = fieldEditors.get(entry.name);
          if (editor) {
            entry.value = editor.value;
            fields[entry.name] = editor.value;
          }
        });
      }

      refreshMaskedWordField();

      const maskedFieldName = activeModelFieldMetadata.roleMap?.masked;
      if (maskedFieldName) {
        const maskedEditor = fieldEditors.get(maskedFieldName);
        if (maskedEditor) {
          fields[maskedFieldName] = maskedEditor.value;
        }
      }

      noteDetails.fields = fields;

      updateNoteDetailsDisplay(noteDetails);

      if (Array.isArray(noteDetails.tags)) {
        tagsInput.value = noteDetails.tags.join(", ");
      } else {
        tagsInput.value = "";
      }

      updatePreview();
    }

    async function updateExistingNoteFromEditor(noteDetails) {
      if (!noteDetails || !noteDetails.id) {
        throw new Error("This note cannot be updated.");
      }

      const updateFields = {};
      const processed = new Set();

      const collectFieldValue = (fieldName) => {
        if (!fieldName || processed.has(fieldName)) {
          return;
        }
        const editor = fieldEditors.get(fieldName);
        if (!editor) {
          return;
        }
        updateFields[fieldName] = editor.value.trim();
        processed.add(fieldName);
      };

      if (Array.isArray(noteDetails.orderedFields)) {
        noteDetails.orderedFields.forEach((entry) => collectFieldValue(entry.name));
      }

      fieldEditors.forEach((_, fieldName) => collectFieldValue(fieldName));

      const roleMap = noteDetails.roleMap || activeModelFieldMetadata.roleMap || {};
      const wordFieldName =
        roleMap.word ||
        (Array.isArray(noteDetails.orderedFields) && noteDetails.orderedFields.length
          ? noteDetails.orderedFields[0].name
          : getActiveWordFieldName());
      const maskedFieldName = roleMap.masked || activeModelFieldMetadata.roleMap?.masked;

      if (wordFieldName) {
        const wordEditor = fieldEditors.get(wordFieldName);
        const existingWordValue =
          typeof (noteDetails.fields || {})[wordFieldName] === "string"
            ? noteDetails.fields[wordFieldName].trim()
            : "";
        const wordValue = wordEditor ? wordEditor.value.trim() : existingWordValue;
        updateFields[wordFieldName] = wordValue;

        if (maskedFieldName) {
          const maskedValue = deriveMaskedWordValue(wordValue);
          updateFields[maskedFieldName] = maskedValue;
          const maskedEditor = fieldEditors.get(maskedFieldName);
          if (maskedEditor) {
            maskedEditor.value = maskedValue;
            adjustTextareaHeight(maskedEditor);
          }
        }
      }

      const fieldNames = Object.keys(updateFields);
      if (!fieldNames.length) {
        throw new Error("No mapped fields available for update.");
      }

      await callAnkiConnect("updateNoteFields", {
        note: {
          id: noteDetails.id,
          fields: updateFields,
        },
      });

      const fields = noteDetails.fields || {};
      fieldNames.forEach((fieldName) => {
        fields[fieldName] = updateFields[fieldName];
      });
      noteDetails.fields = fields;
      noteDetails.roleMap = roleMap;

      if (Array.isArray(noteDetails.orderedFields)) {
        fieldNames.forEach((fieldName) => {
          const existing = noteDetails.orderedFields.find((entry) => entry && entry.name === fieldName);
          if (existing) {
            existing.value = updateFields[fieldName];
          } else {
            noteDetails.orderedFields.push({
              name: fieldName,
              value: updateFields[fieldName],
              order: noteDetails.orderedFields.length,
            });
          }
        });
      }

      updateNoteDetailsDisplay(noteDetails);
      refreshMaskedWordField();
    }

    function createMaskFromMatch(match) {
      if (!match) {
        return match;
      }

      const characters = Array.from(match);
      const masked = [];
      let preservedCount = 0;
      const maskableCharacters = characters.filter((char) => !/\s/.test(char));
      const keep = maskableCharacters.length >= 6 ? 2 : 1;

      characters.forEach((char) => {
        if (/\s/.test(char)) {
          masked.push(char);
        } else if (preservedCount < keep) {
          masked.push(char);
          preservedCount += 1;
        } else {
          masked.push("•");
        }
      });

      return masked.join("");
    }

    function maskTargetInText(text, target) {
      if (!text || !target) {
        return text;
      }

      const escaped = escapeRegExp(target.trim());
      if (!escaped) {
        return text;
      }

      const pattern = new RegExp(escaped, "gi");
      return text.replace(pattern, (match) => createMaskFromMatch(match));
    }

    async function loadNoteTypesForDeck(deckName) {
      if (!deckName) {
        pendingNoteTypeDeck = "";
        updateModelSuggestions([]);
        return;
      }

      pendingNoteTypeDeck = deckName;

      try {
        const sanitizedDeckName = escapeDeckNameForQuery(deckName);
        const noteIds = await callAnkiConnect("findNotes", {
          query: `deck:"${sanitizedDeckName}"`,
        });

        if (pendingNoteTypeDeck !== deckName) {
          return;
        }

        const noteTypeSet = new Set();

        if (Array.isArray(noteIds) && noteIds.length) {
          const batchLimit = Math.max(1, NOTE_SAMPLE_BATCH_LIMIT);
          for (
            let index = 0;
            index < noteIds.length && index / NOTE_SAMPLE_BATCH_SIZE < batchLimit;
            index += NOTE_SAMPLE_BATCH_SIZE
          ) {
            const batch = noteIds.slice(index, index + NOTE_SAMPLE_BATCH_SIZE);
            if (!batch.length) {
              continue;
            }

            const notesInfo = await callAnkiConnect("notesInfo", { notes: batch });

            if (pendingNoteTypeDeck !== deckName) {
              return;
            }

            if (Array.isArray(notesInfo)) {
              notesInfo.forEach((note) => {
                if (note && note.modelName) {
                  noteTypeSet.add(note.modelName);
                }
              });
            }

            if (batch.length < NOTE_SAMPLE_BATCH_SIZE) {
              break;
            }
          }
        }

        if (pendingNoteTypeDeck !== deckName) {
          return;
        }

        let noteTypes = Array.from(noteTypeSet).sort((a, b) => a.localeCompare(b));
        let statusMessage = "";

        if (!noteTypes.length) {
          const allModelNames = await callAnkiConnect("modelNames");

          if (pendingNoteTypeDeck !== deckName) {
            return;
          }

          if (Array.isArray(allModelNames)) {
            allModelNames.forEach((name) => {
              if (name) {
                noteTypeSet.add(name);
              }
            });
          }

          noteTypes = Array.from(noteTypeSet).sort((a, b) => a.localeCompare(b));

          if (!noteTypes.length) {
            throw new Error("No note types available.");
          }

          statusMessage = `No existing notes found in "${deckName}". Showing all note types.`;
        } else {
          statusMessage = `Loaded ${noteTypes.length} note type${
            noteTypes.length === 1 ? "" : "s"
          } from "${deckName}".`;
        }

        if (pendingNoteTypeDeck !== deckName) {
          return;
        }

        updateModelSuggestions(noteTypes);

        const currentModelName = modelNameInput.value.trim();
        if (!userModifiedNoteType || !noteTypes.includes(currentModelName)) {
          const preferredModelName = noteTypes.includes(DEFAULT_MODEL_NAME)
            ? DEFAULT_MODEL_NAME
            : noteTypes[0] || currentModelName;

          if (preferredModelName && preferredModelName !== currentModelName) {
            modelNameInput.value = preferredModelName;
            updatePreview();
          }

          userModifiedNoteType = false;
        }

        await refreshModelFieldsForCurrentModel({
          modelName: modelNameInput.value.trim() || DEFAULT_MODEL_NAME,
        });

        setStatus(statusMessage, "success");
      } catch (error) {
        if (pendingNoteTypeDeck !== deckName) {
          return;
        }

        console.error(error);
        updateModelSuggestions([]);
        setStatus(error.message || "Failed to load note types", "error");
      }
    }

    async function loadDecks() {
      setStatus("Loading decks…");
      loadDecksBtn.disabled = true;
      try {
        const deckNames = await callAnkiConnect("deckNames");
        deckSelect.innerHTML = "";
        if (!deckNames.length) {
          const option = document.createElement("option");
          option.textContent = "No decks found";
          option.disabled = true;
          option.selected = true;
          deckSelect.appendChild(option);
        } else {
          const placeholder = document.createElement("option");
          placeholder.textContent = "Choose a deck";
          placeholder.disabled = true;
          placeholder.selected = true;
          placeholder.value = "";
          deckSelect.appendChild(placeholder);
          for (const deck of deckNames) {
            const option = document.createElement("option");
            option.value = deck;
            option.textContent = deck;
            deckSelect.appendChild(option);
          }
          const savedDeck = getSessionItem(SESSION_KEYS.deck);
          if (savedDeck && deckNames.includes(savedDeck)) {
            deckSelect.value = savedDeck;
            persistDeckSelection();
            await loadNoteTypesForDeck(savedDeck);
            updatePreview();
            return;
          }
        }
        updateModelSuggestions([]);
        await refreshModelFieldsForCurrentModel();
        setStatus("Decks loaded", "success");
        updatePreview();
      } catch (error) {
        console.error(error);
        setStatus(error.message || "Failed to load decks", "error");
      } finally {
        loadDecksBtn.disabled = false;
      }
    }

    function applyMaskedContent(element, text, lookupTerm) {
      if (!element) {
        return;
      }

      if (!text) {
        element.textContent = "";
        return;
      }

      const masked = maskTargetInText(text, lookupTerm);
      if (masked && masked !== text) {
        element.innerHTML = masked;
      } else {
        element.textContent = text;
      }
    }

    function createBadge(text, variant = "") {
      const badge = document.createElement("span");
      badge.className = "badge" + (variant ? " " + variant : "");
      badge.textContent = text;
      return badge;
    }

    function buildDefinitionEntry(entry, lookupTerm) {
      const details = document.createElement("details");
      details.className = "definition-entry";

      const summary = document.createElement("summary");
      const summaryText = document.createElement("div");
      summaryText.className = "entry-summary-text";

      const headword = document.createElement("span");
      headword.className = "entry-headword";
      headword.textContent = entry.word || lookupTerm;
      summaryText.appendChild(headword);

      const badgeRow = document.createElement("div");
      badgeRow.className = "badge-row";
      if (entry.isExistingNote) {
        badgeRow.appendChild(createBadge("Existing card"));
      }
      if (entry.source) {
        badgeRow.appendChild(createBadge(entry.source, "secondary"));
      }
      const partLabels = new Set();
      (entry.meanings || []).forEach((meaning) => {
        if (meaning?.partOfSpeech) {
          partLabels.add(meaning.partOfSpeech);
        }
      });
      if (!partLabels.size) {
        partLabels.add("Definition");
      }
      partLabels.forEach((label) => badgeRow.appendChild(createBadge(label)));
      summaryText.appendChild(badgeRow);

      summary.appendChild(summaryText);
      details.appendChild(summary);

      const content = document.createElement("div");
      content.className = "entry-content";

      if (entry.note) {
        const noteParagraph = document.createElement("p");
        noteParagraph.style.margin = "0";
        noteParagraph.textContent = entry.note;
        content.appendChild(noteParagraph);
      }

      if (entry.phonetic) {
        const phonetic = document.createElement("p");
        phonetic.style.margin = "0";
        phonetic.innerHTML = `<strong>Phonetic:</strong> ${entry.phonetic}`;
        content.appendChild(phonetic);
      }

      if (entry.isExistingNote && entry.noteDetails) {
        const actions = document.createElement("div");
        actions.className = "entry-actions";

        const loadButton = document.createElement("button");
        loadButton.textContent = "Load this card";
        loadButton.addEventListener("click", () => {
          applyNoteToEditor(entry.noteDetails);
          const deckLabel = entry.noteDetails.deckName
            ? ` from "${entry.noteDetails.deckName}"`
            : "";
          setStatus(`Existing card loaded${deckLabel}.`, "success");
        });
        actions.appendChild(loadButton);

        const updateButton = document.createElement("button");
        updateButton.textContent = "Update card";
        updateButton.addEventListener("click", async () => {
          try {
            setStatus("Updating existing card…");
            updateButton.disabled = true;
            await updateExistingNoteFromEditor(entry.noteDetails);
            if (entry.noteDetails.display?.frontText) {
              entry.word = entry.noteDetails.display.frontText;
              headword.textContent = entry.word;
            }
            setStatus("Existing card updated.", "success");
          } catch (error) {
            console.error(error);
            setStatus(error.message || "Failed to update note", "error");
          } finally {
            updateButton.disabled = false;
          }
        });
        actions.appendChild(updateButton);

        content.appendChild(actions);
      }

      (entry.meanings || []).forEach((meaning) => {
        const meaningBlock = document.createElement("div");
        meaningBlock.className = "meaning-block";

        const meaningTitle = document.createElement("div");
        meaningTitle.className = "meaning-title";
        meaningTitle.appendChild(createBadge(meaning.partOfSpeech || "Definition"));
        const definitionCount = Array.isArray(meaning.definitions)
          ? meaning.definitions.length
          : 0;
        if (definitionCount > 1) {
          meaningTitle.appendChild(createBadge(`${definitionCount} defs`, "secondary"));
        }
        meaningBlock.appendChild(meaningTitle);

        const definitionList = document.createElement("ol");
        definitionList.className = "definition-list";

        (meaning.definitions || []).forEach((definition) => {
          const listItem = document.createElement("li");
          listItem.className = "definition-item";

          const definitionText = document.createElement("p");
          definitionText.className = "definition-text";
          applyMaskedContent(definitionText, definition.definition, lookupTerm);
          listItem.appendChild(definitionText);

          if (definition.example) {
            const exampleText = document.createElement("p");
            exampleText.className = "example-text";
            applyMaskedContent(exampleText, definition.example, lookupTerm);

            if (entry.isExistingNote) {
              listItem.appendChild(exampleText);
            } else {
            const exampleButton = document.createElement("button");
            exampleButton.textContent = "Use this example";
            exampleButton.addEventListener("click", () => {
              exampleField.value = maskTargetInText(
                definition.example,
                lookupTerm
              );
              adjustTextareaHeight(exampleField);
              updatePreview();
              setStatus("Example added to the card", "success");
            });

            const definitionButton = document.createElement("button");
            definitionButton.textContent = "Use this definition";
            definitionButton.addEventListener("click", () => {
              backField.value = maskTargetInText(
                definition.definition,
                lookupTerm
              );
              adjustTextareaHeight(backField);
              if (!frontField.value.trim()) {
                frontField.value = entry.word || lookupTerm;
                adjustTextareaHeight(frontField);
              }
              refreshMaskedWordField();
              updatePreview();
              setStatus("Definition added to the card", "success");
            });

            const exampleWrapper = document.createElement("div");
            exampleWrapper.style.display = "grid";
            exampleWrapper.style.gap = "0.4rem";
            exampleWrapper.appendChild(exampleText);
            exampleWrapper.appendChild(exampleButton);
            exampleWrapper.appendChild(definitionButton);
            listItem.appendChild(exampleWrapper);
          }
        }

          definitionList.appendChild(listItem);
        });

        meaningBlock.appendChild(definitionList);
        content.appendChild(meaningBlock);
      });

      details.appendChild(content);
      return details;
    }

    function buildSynonymEntry(entry, lookupTerm) {
      if (!Array.isArray(entry.synonyms) || !entry.synonyms.length) {
        return null;
      }

      const details = document.createElement("details");
      details.className = "definition-entry";

      const summary = document.createElement("summary");
      const summaryText = document.createElement("div");
      summaryText.className = "entry-summary-text";

      const headword = document.createElement("span");
      headword.className = "entry-headword";
      headword.textContent = `Synonyms for ${entry.word || lookupTerm}`;
      summaryText.appendChild(headword);

      const badgeRow = document.createElement("div");
      badgeRow.className = "badge-row";
      badgeRow.appendChild(createBadge(entry.source || "Synonyms", "secondary"));
      summaryText.appendChild(badgeRow);

      summary.appendChild(summaryText);
      details.appendChild(summary);

      const content = document.createElement("div");
      content.className = "entry-content";

      const intro = document.createElement("p");
      intro.style.margin = "0";
      intro.textContent = "Click a synonym to search it.";
      content.appendChild(intro);

      const cloud = document.createElement("div");
      cloud.className = "synonym-cloud";
      entry.synonyms.slice(0, 40).forEach((synonym) => {
        const button = document.createElement("button");
        button.type = "button";
        button.textContent = synonym;
        button.addEventListener("click", () => {
          lookupTermInput.value = synonym;
          searchDictionary();
        });
        cloud.appendChild(button);
      });

      content.appendChild(cloud);
      details.appendChild(content);
      return details;
    }

    function renderSpellingSuggestionsList(suggestions, parsedTerm) {
      if (!spellingSuggestions) {
        return;
      }

      const filtered = Array.isArray(suggestions)
        ? suggestions.filter(
            (suggestion) =>
              suggestion &&
              suggestion.toLowerCase() !== (parsedTerm?.term || "").toLowerCase()
          )
        : [];

      if (!filtered.length) {
        spellingSuggestions.hidden = true;
        spellingSuggestions.innerHTML = "";
        return;
      }

      spellingSuggestions.hidden = false;
      spellingSuggestions.innerHTML = "";

      const label = document.createElement("span");
      label.textContent = "Possible spellings:";
      spellingSuggestions.appendChild(label);

      filtered.forEach((suggestion) => {
        const suggestionButton = document.createElement("button");
        suggestionButton.type = "button";
        suggestionButton.textContent = suggestion;
        suggestionButton.addEventListener("click", () => {
          lookupTermInput.value = suggestion;
          searchDictionary();
        });
        spellingSuggestions.appendChild(suggestionButton);
      });
    }

    function renderDictionaryResults(entries, parsedTerm) {
      dictionaryResults.innerHTML = "";
      if (!entries || !entries.length) {
        dictionaryResults.textContent = "No results found.";
        return;
      }

      entries.forEach((entry, index) => {
        let element = null;
        if (entry.isSynonymList) {
          element = buildSynonymEntry(entry, parsedTerm.term);
        } else {
          element = buildDefinitionEntry(entry, parsedTerm.term);
          if (element && index === 0) {
            element.open = true;
          }
        }

        if (element) {
          dictionaryResults.appendChild(element);
        }
      });
    }

    async function searchDictionary() {
      const rawInput = lookupTermInput.value.trim();
      if (!rawInput) {
        setStatus("Type a term to search", "error");
        return;
      }

      const parsedTerm = parseLookupTerm(rawInput);
      if (!parsedTerm.term) {
        setStatus("Type a term to search", "error");
        return;
      }

      lastPartOfSpeechFilter = parsedTerm.partOfSpeech;
      updateDictionaryScopeLabel(parsedTerm.partOfSpeech);

      const shouldSearchOnline = activeSearchScope !== SEARCH_SCOPES.decksOnly;
      const shouldSearchDecks = activeSearchScope !== SEARCH_SCOPES.onlineOnly;

      const scopeLabel = shouldSearchOnline && shouldSearchDecks
        ? "online dictionaries and decks"
        : shouldSearchOnline
        ? "online dictionaries"
        : "your decks";

      setStatus(`Searching ${scopeLabel} for "${parsedTerm.term}"…`);
      searchButton.disabled = true;
      dictionaryResults.textContent = "Searching…";
      renderSpellingSuggestionsList([], parsedTerm);

      const providerIds = shouldSearchOnline ? getActiveDictionaryProviderIds() : [];
      const uniqueEntryKeys = new Set();
      const collectedEntries = [];
      const contributingProviders = new Set();
      const missingCredentials = [];
      const providerErrors = [];
      let embeddedMatchCount = 0;

      const addEntries = (entries, providerLabel = "", options = {}) => {
        const { prepend = false, trackProvider = true } = options;
        if (!Array.isArray(entries)) {
          return;
        }

        const iterable = prepend ? [...entries].reverse() : entries;

        iterable.forEach((entry) => {
          if (!entry) {
            return;
          }

          if (entry.isSynonymList) {
            if (!Array.isArray(entry.synonyms) || !entry.synonyms.length) {
              return;
            }
          } else if (!Array.isArray(entry.meanings) || !entry.meanings.length) {
            return;
          }

          const key = entry.uniqueKey
            ? entry.uniqueKey
            : entry.isSynonymList
            ? `syn-${(entry.source || providerLabel || "").toLowerCase()}-${(entry.word || "").toLowerCase()}-${entry.synonyms.join("|")}`
            : JSON.stringify({
                source: entry.source || providerLabel || "",
                word: entry.word || "",
                meanings: (entry.meanings || []).map((meaning) => ({
                  partOfSpeech: meaning.partOfSpeech || "",
                  definitions: (meaning.definitions || []).map((definition) => ({
                    definition: definition.definition || "",
                    example: definition.example || "",
                  })),
                })),
              });

          if (uniqueEntryKeys.has(key)) {
            return;
          }
          uniqueEntryKeys.add(key);

          if (prepend) {
            collectedEntries.unshift(entry);
          } else {
            collectedEntries.push(entry);
          }

          if (trackProvider) {
            const contributor = entry.source || providerLabel;
            if (contributor) {
              contributingProviders.add(contributor);
            }
          }
        });
      };

      try {
        const suggestionsPromise = shouldSearchOnline
          ? fetchSpellingSuggestions(parsedTerm.term)
          : Promise.resolve([]);

        suggestionsPromise
          .then((suggestions) => {
            renderSpellingSuggestionsList(suggestions, parsedTerm);
          })
          .catch(() => {
            renderSpellingSuggestionsList([], parsedTerm);
          });

        const defaultDeckSummary = {
          deckName: deckSelect.value || "",
          entries: [],
          totalCount: 0,
          shownCount: 0,
          truncated: false,
          error: "",
        };

        let deckLookupSummary = defaultDeckSummary;

        let deckLookupPromise = (shouldSearchDecks
          ? findDeckEntries(parsedTerm.term, deckSelect.value)
          : Promise.resolve(defaultDeckSummary))
          .then((summary) => {
            deckLookupSummary = summary;
            if (Array.isArray(summary.entries) && summary.entries.length) {
              addEntries(summary.entries, summary.deckName || "Existing cards", {
                prepend: true,
                trackProvider: false,
              });
            }
            renderDictionaryResults(collectedEntries, parsedTerm);
            return summary;
          })
          .catch((error) => {
            console.warn("Deck lookup failed", error);
            deckLookupSummary = {
              deckName: deckSelect.value || "",
              entries: [],
              totalCount: 0,
              shownCount: 0,
              truncated: false,
              error: error?.message || "Deck lookup failed.",
            };
            renderDictionaryResults(collectedEntries, parsedTerm);
            return deckLookupSummary;
          });

        const providerTasks = providerIds.map((providerId) => {
          const lookupPromise = (async () => {
            const provider = dictionaryProviders[providerId];
            if (!provider) {
              return { providerId, entries: [], embeddedCount: 0 };
            }

            const credentials = getProviderCredentials(provider.id);
            if (provider.requiresCredentials) {
              const requiredKeys = Array.isArray(provider.credentialKeys)
                ? provider.credentialKeys
                : [];
              const missingKeys = requiredKeys.filter((key) => !credentials[key]);
              if (missingKeys.length) {
                missingCredentials.push(provider.label || providerId);
                return { providerId, entries: [], embeddedCount: 0 };
              }
            }

            const providerEntries = [];
            let providerEmbeddedCount = 0;

            try {
              const directEntries = await provider.fetchEntries(parsedTerm.term, parsedTerm, {
                credentials,
              });
              if (Array.isArray(directEntries)) {
                providerEntries.push(...directEntries);
              }
            } catch (error) {
              console.warn(`Lookup failed for ${provider.label || providerId}`, error);
              if (error?.message) {
                providerErrors.push(`${provider.label || providerId}: ${error.message}`);
              }
            }

            if (provider.supportsEmbeddedSearch && parsedTerm.tokens.length > 1) {
              try {
                const embeddedEntries = await searchWithinEntries(parsedTerm, providerId, credentials);
                providerEmbeddedCount += embeddedEntries.length;
                if (Array.isArray(embeddedEntries)) {
                  providerEntries.push(...embeddedEntries);
                }
              } catch (embeddedError) {
                console.warn(`Embedded search failed for ${provider.label || providerId}`, embeddedError);
              }
            }

            const filteredEntries = providerEntries
              .map((entry) =>
                entry && !entry.isSynonymList
                  ? filterEntryByPartOfSpeech(entry, parsedTerm.partOfSpeech)
                  : entry
              )
              .filter(Boolean);

            return { providerId, entries: filteredEntries, embeddedCount: providerEmbeddedCount };
          })();

          return lookupPromise
            .then((result) => {
              embeddedMatchCount += result.embeddedCount;
              const providerLabel = dictionaryProviders[result.providerId]?.label || result.providerId;
              addEntries(result.entries, providerLabel);
              renderDictionaryResults(collectedEntries, parsedTerm);
              return result;
            })
            .catch((error) => {
              console.error(`Lookup failed for ${providerId}`, error);
              providerErrors.push(
                `${dictionaryProviders[providerId]?.label || providerId}: ${error?.message || "Unknown error"}`
              );
              renderDictionaryResults(collectedEntries, parsedTerm);
              return { providerId, entries: [], embeddedCount: 0 };
            });
        });

        const finalizeSearch = () => {
          if (!collectedEntries.length) {
            renderDictionaryResults([], parsedTerm);
            let emptyMessage = "No entries available.";
            if (deckLookupSummary.deckName && deckLookupSummary.error) {
              emptyMessage += ` Deck lookup failed for "${deckLookupSummary.deckName}": ${deckLookupSummary.error}`;
            }
            if (missingCredentials.length) {
              emptyMessage += ` Skipped ${missingCredentials.join(", ")} (missing credentials).`;
            }
            setStatus(emptyMessage, "error");
            return;
          }

          renderDictionaryResults(collectedEntries, parsedTerm);

          const statusParts = [];

          if (shouldSearchOnline) {
            const providerList = Array.from(contributingProviders);
            let providerSummary;
            if (!providerIds.length) {
              providerSummary = "no online dictionaries";
            } else if (!providerList.length) {
              providerSummary =
                providerIds.length === 1
                  ? dictionaryProviders[providerIds[0]]?.label || providerIds[0]
                  : "selected dictionaries";
            } else if (providerList.length === 1) {
              providerSummary = providerList[0];
            } else {
              providerSummary = `${providerList.length} dictionaries (${providerList.join(", ")})`;
            }
            const embeddedNote = embeddedMatchCount
              ? ` including ${embeddedMatchCount} embedded match${embeddedMatchCount === 1 ? "" : "es"}`
              : "";
            statusParts.push(`Dictionary results loaded from ${providerSummary}${embeddedNote}.`);
          }

          if (shouldSearchDecks && deckLookupSummary.deckName) {
            if (deckLookupSummary.error) {
              statusParts.push(
                `Deck lookup failed for "${deckLookupSummary.deckName}": ${deckLookupSummary.error}`
              );
            } else if (deckLookupSummary.totalCount > 0) {
              let deckMessage = `Found ${deckLookupSummary.totalCount} existing card${
                deckLookupSummary.totalCount === 1 ? "" : "s"
              } in "${deckLookupSummary.deckName}"`;
              if (deckLookupSummary.truncated && deckLookupSummary.shownCount) {
                deckMessage += ` (showing first ${deckLookupSummary.shownCount})`;
              }
              deckMessage += ".";
              statusParts.push(deckMessage);
            } else {
              statusParts.push(`No existing cards matched in "${deckLookupSummary.deckName}".`);
            }
          }

          if (missingCredentials.length) {
            statusParts.push(`Skipped ${missingCredentials.join(", ")} (missing credentials).`);
          }

          if (providerErrors.length) {
            statusParts.push(`Dictionary errors: ${providerErrors.join("; ")}.`);
          }

          const statusType = deckLookupSummary.error || providerErrors.length ? "error" : "success";
          setStatus(statusParts.join(" "), statusType);
        };

        const streamingCompletion = Promise.allSettled([...providerTasks, deckLookupPromise]);
        await streamingCompletion;

        finalizeSearch();
      } catch (error) {
        console.error(error);
        dictionaryResults.textContent = "No entries available.";
        setStatus(error.message || "Failed to fetch dictionary results", "error");
      } finally {
        searchButton.disabled = false;
      }
    }
    async function addCard() {
      const deckName = deckSelect.value;
      const modelName = modelNameInput.value.trim() || DEFAULT_MODEL_NAME;

      if (!deckName) {
        setStatus("Please choose a deck", "error");
        return;
      }

      setStatus("Adding card to deck…");
      addCardBtn.disabled = true;

      refreshMaskedWordField();

      const tags = tagsInput.value
        .split(",")
        .map((tag) => tag.trim())
        .filter(Boolean);

      let metadata = modelFieldCache.get(modelName);
      try {
        if (!metadata || !metadata.orderedFieldNames?.length) {
          metadata = await ensureModelFieldMetadata(modelName);
        }
      } catch (metadataError) {
        console.error(metadataError);
        setStatus(
          metadataError.message || `Failed to load fields for "${modelName}"`,
          "error"
        );
        addCardBtn.disabled = false;
        return;
      }

      const orderedFieldNames = Array.isArray(metadata?.orderedFieldNames)
        ? metadata.orderedFieldNames
        : [];

      if (!orderedFieldNames.length) {
        setStatus(`The note type "${modelName}" has no fields.`, "error");
        addCardBtn.disabled = false;
        return;
      }

      const fields = {};
      orderedFieldNames.forEach((fieldName) => {
        const editor = fieldEditors.get(fieldName);
        fields[fieldName] = editor ? editor.value.trim() : "";
      });

      fieldEditors.forEach((editor, fieldName) => {
        if (!(fieldName in fields)) {
          fields[fieldName] = editor ? editor.value.trim() : "";
        }
      });

      const roleMap = metadata?.roleMap || activeModelFieldMetadata.roleMap || {};
      const wordFieldName =
        roleMap.word ||
        (orderedFieldNames.length ? orderedFieldNames[0] : getActiveWordFieldName());
      const definitionFieldName =
        roleMap.definition ||
        orderedFieldNames.find((name) => name && name !== wordFieldName) ||
        null;

      const wordValue = wordFieldName ? (fields[wordFieldName] || "").trim() : "";
      const definitionValue = definitionFieldName
        ? (fields[definitionFieldName] || "").trim()
        : "";

      if (!wordValue) {
        setStatus("Primary fields cannot be empty for this note type.", "error");
        addCardBtn.disabled = false;
        return;
      }

      if (definitionFieldName && !definitionValue) {
        setStatus("Primary fields cannot be empty for this note type.", "error");
        addCardBtn.disabled = false;
        return;
      }

      if (wordFieldName) {
        fields[wordFieldName] = wordValue;
      }
      if (definitionFieldName) {
        fields[definitionFieldName] = definitionValue;
      }

      const maskedFieldName = roleMap.masked || activeModelFieldMetadata.roleMap?.masked;
      if (maskedFieldName && wordFieldName) {
        const maskedValue = deriveMaskedWordValue(wordValue);
        fields[maskedFieldName] = maskedValue;
        const maskedEditor = fieldEditors.get(maskedFieldName);
        if (maskedEditor) {
          maskedEditor.value = maskedValue;
          adjustTextareaHeight(maskedEditor);
        }
      }

      try {
        await callAnkiConnect("addNote", {
          note: {
            deckName,
            modelName,
            fields,
            tags,
          },
        });

        try {
          await callAnkiConnect("sync");
          setStatus(
            "Card added and sync requested using Anki's saved session.",
            "success"
          );
        } catch (syncError) {
          console.warn("Sync failed", syncError);
          setStatus(
            `Card added but sync failed via saved session: ${syncError.message}`,
            "error"
          );
        }
      } catch (error) {
        console.error(error);
        setStatus(error.message || "Failed to add card", "error");
      } finally {
        addCardBtn.disabled = false;
      }
    }

    const initialDeckSelection = getSessionItem(SESSION_KEYS.deck);
    if (initialDeckSelection) {
      loadDecks();
    }

    loadDecksBtn.addEventListener("click", loadDecks);
    searchButton.addEventListener("click", searchDictionary);
    lookupTermInput.addEventListener("keydown", (event) => {
      if (event.key === "Enter") {
        event.preventDefault();
        searchDictionary();
      }
    });
    addCardBtn.addEventListener("click", addCard);

    updatePreview();
  </script>
</body>
</html>

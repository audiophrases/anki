<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Anki Card Creator</title>
  <style>
    :root {
      color-scheme: light dark;
      font-family: "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      line-height: 1.5;
      font-size: 16px;
    }

    body {
      margin: 0;
      padding: 0;
      background: radial-gradient(circle at top left, #f7f8ff, #eaeefd 40%, #e0e0f5);
      min-height: 100vh;
      color: #1e2a44;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      padding: 2rem;
      box-sizing: border-box;
    }

    .app {
      background: rgba(255, 255, 255, 0.92);
      box-shadow: 0 20px 60px rgba(58, 75, 115, 0.25);
      border-radius: 20px;
      max-width: 1100px;
      width: 100%;
      display: grid;
      grid-template-columns: 340px 1fr;
      overflow: hidden;
    }

    .sidebar {
      padding: 2rem;
      background: linear-gradient(180deg, #3f64c7, #4650ac);
      color: white;
    }

    .sidebar h1 {
      margin-top: 0;
      margin-bottom: 1.5rem;
      font-size: 1.9rem;
      letter-spacing: 0.02em;
    }

    .sidebar section + section {
      margin-top: 2.5rem;
    }

    label {
      font-weight: 600;
      display: block;
      margin-bottom: 0.5rem;
    }

    input[type="text"],
    input[type="password"],
    textarea,
    select {
      width: 100%;
      border: 1px solid rgba(30, 42, 68, 0.2);
      border-radius: 10px;
      padding: 0.7rem 0.85rem;
      font-size: 1rem;
      font-family: inherit;
      box-sizing: border-box;
      background: rgba(255, 255, 255, 0.95);
      color: #1e2a44;
    }

    textarea {
      min-height: 120px;
      resize: vertical;
    }

    button {
      background: #3f64c7;
      border: none;
      border-radius: 999px;
      padding: 0.65rem 1.35rem;
      font-size: 0.95rem;
      font-weight: 600;
      color: white;
      cursor: pointer;
      transition: transform 0.15s ease, box-shadow 0.15s ease;
      box-shadow: 0 10px 30px rgba(63, 100, 199, 0.3);
    }

    button:hover {
      transform: translateY(-1px);
      box-shadow: 0 12px 32px rgba(63, 100, 199, 0.4);
    }

    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      box-shadow: none;
      transform: none;
    }

    .main {
      padding: 2rem 2.5rem;
      background: rgba(249, 250, 255, 0.9);
      display: flex;
      flex-direction: column;
      gap: 2rem;
    }

    .panel {
      background: white;
      border-radius: 16px;
      padding: 1.5rem;
      box-shadow: 0 10px 30px rgba(43, 58, 92, 0.1);
    }

    .setup-notice {
      border: 1px solid rgba(63, 100, 199, 0.18);
      background: linear-gradient(
        135deg,
        rgba(63, 100, 199, 0.14),
        rgba(70, 80, 172, 0.04)
      );
      display: grid;
      gap: 0.75rem;
    }

    .setup-notice.is-hidden {
      display: none;
    }

    .setup-steps {
      margin: 0;
      padding-left: 1.2rem;
      color: #2f4075;
    }

    .setup-steps li + li {
      margin-top: 0.4rem;
    }

    .setup-snippet {
      background: rgba(63, 100, 199, 0.12);
      border-radius: 12px;
      padding: 0.9rem 1rem;
      font-family: "Fira Code", "SFMono-Regular", Menlo, Monaco, Consolas,
        "Liberation Mono", "Courier New", monospace;
      font-size: 0.9rem;
      color: #1f2b4a;
      overflow-x: auto;
    }

    .setup-snippet pre {
      margin: 0;
      white-space: pre;
    }

    .setup-footnote {
      margin: 0;
      font-size: 0.85rem;
      color: #3f4d7a;
    }

    .panel h2 {
      margin-top: 0;
      font-size: 1.35rem;
      color: #2f4075;
    }

    .dictionary-controls {
      display: grid;
      grid-template-columns: minmax(0, 1fr) auto auto;
      gap: 0.75rem;
      align-items: center;
    }

    .dictionary-scope {
      background: rgba(63, 100, 199, 0.12);
      color: #2a3d82;
      border-radius: 999px;
      padding: 0.45rem 1rem;
      font-weight: 600;
      white-space: nowrap;
    }

    .dictionary-settings {
      margin-top: 1rem;
      display: grid;
      gap: 1rem;
    }

    .scope-toggle {
      display: inline-flex;
      background: rgba(63, 100, 199, 0.1);
      border-radius: 999px;
      padding: 0.2rem;
      gap: 0.2rem;
      flex-wrap: wrap;
    }

    .scope-toggle button {
      background: transparent;
      border-radius: 999px;
      padding: 0.45rem 0.95rem;
      border: none;
      color: #2a3d82;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.15s ease, color 0.15s ease;
    }

    .scope-toggle button.is-active {
      background: #3f64c7;
      color: white;
    }

    .dictionary-provider-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 0.5rem;
    }

    .provider-option {
      background: rgba(63, 100, 199, 0.08);
      border: 1px solid rgba(63, 100, 199, 0.14);
      border-radius: 12px;
      padding: 0.55rem 0.75rem;
      display: flex;
      align-items: center;
      gap: 0.6rem;
      font-weight: 500;
      color: #2a3d82;
    }

    .provider-option input[type="checkbox"] {
      width: 1rem;
      height: 1rem;
      margin: 0;
    }

    .dictionary-results {
      display: grid;
      gap: 1rem;
      margin-top: 1rem;
    }

    .suggestions {
      margin-top: 0.5rem;
      font-size: 0.95rem;
      color: #2f4075;
      display: flex;
      gap: 0.4rem;
      flex-wrap: wrap;
      align-items: center;
    }

    .suggestions button {
      background: rgba(63, 100, 199, 0.15);
      color: #2a3d82;
      border-radius: 999px;
      border: none;
      padding: 0.3rem 0.75rem;
      cursor: pointer;
      font-weight: 600;
    }

    .definition-entry {
      border: 1px solid rgba(63, 100, 199, 0.18);
      border-radius: 16px;
      background: rgba(242, 245, 255, 0.6);
      padding: 0.3rem 0.6rem;
    }

    .definition-entry > summary {
      list-style: none;
      display: flex;
      justify-content: space-between;
      gap: 0.75rem;
      align-items: center;
      cursor: pointer;
      padding: 0.55rem 0.35rem;
    }

    .definition-entry > summary::-webkit-details-marker {
      display: none;
    }

    .entry-summary-text {
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
    }

    .entry-headword {
      font-size: 1.05rem;
      font-weight: 700;
      color: #1e2a44;
    }

    .badge-row {
      display: flex;
      gap: 0.35rem;
      flex-wrap: wrap;
      align-items: center;
    }

    .badge {
      background: rgba(63, 100, 199, 0.15);
      color: #2a3d82;
      border-radius: 999px;
      padding: 0.3rem 0.75rem;
      font-size: 0.75rem;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.02em;
    }

    .badge.secondary {
      background: rgba(42, 61, 130, 0.1);
      color: #3f64c7;
    }

    .entry-content {
      padding: 0 0.9rem 0.9rem 0.9rem;
      display: grid;
      gap: 0.9rem;
    }

    .entry-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 0.6rem;
    }

    .meaning-block {
      background: rgba(255, 255, 255, 0.8);
      border-radius: 12px;
      border: 1px solid rgba(63, 100, 199, 0.12);
      padding: 0.75rem 0.85rem;
      display: grid;
      gap: 0.75rem;
    }

    .meaning-title {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.6rem;
    }

    .definition-list {
      list-style: decimal inside;
      margin: 0;
      padding: 0;
      display: grid;
      gap: 0.65rem;
    }

    .definition-item {
      display: grid;
      gap: 0.45rem;
    }

    .definition-text {
      font-size: 1rem;
      color: #1e2a44;
    }

    .example-text {
      font-style: italic;
      color: #42507b;
    }

    .synonym-cloud {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
    }

    .synonym-cloud button {
      background: rgba(63, 100, 199, 0.15);
      border: none;
      border-radius: 999px;
      padding: 0.35rem 0.8rem;
      font-weight: 600;
      color: #2a3d82;
      cursor: pointer;
    }

    .status {
      font-size: 0.95rem;
      min-height: 1.5rem;
    }

    .status.success {
      color: #1a8f5b;
    }

    .status.error {
      color: #cc2b3d;
    }

    .split {
      display: grid;
      gap: 1rem;
    }

    @media (max-width: 980px) {
      body {
        padding: 1rem;
      }

      .app {
        grid-template-columns: 1fr;
      }

      .sidebar {
        border-bottom-left-radius: 0;
        border-bottom-right-radius: 0;
      }

      .main {
        padding: 1.5rem;
      }
    }
  </style>
</head>
<body>
  <div class="app">
    <aside class="sidebar">
      <h1>Anki Card Creator</h1>
      <section>
        <label for="anki-username">AnkiWeb Username</label>
        <input type="text" id="anki-username" placeholder="name@example.com" autocomplete="username" />
        <label for="anki-password" style="margin-top: 1rem;">AnkiWeb Password</label>
        <input type="password" id="anki-password" placeholder="••••••••" autocomplete="current-password" />
      </section>

      <section>
        <label for="deck-select">Deck</label>
        <div class="split">
          <select id="deck-select">
            <option value="" disabled selected>Load decks via AnkiConnect</option>
          </select>
          <button id="load-decks">Load Decks</button>
        </div>
      </section>

      <section>
        <label for="model-name">Note Type</label>
        <input type="text" id="model-name" value="Basic" list="model-suggestions" />
        <datalist id="model-suggestions"></datalist>
        <label for="tags" style="margin-top: 1rem;">Tags (comma separated)</label>
        <input type="text" id="tags" placeholder="vocab, dictionary" />
      </section>

      <section>
        <p style="margin-top: 0; font-weight: 600;">Dictionary API keys (optional)</p>
        <label for="longman-app-id">Longman App ID</label>
        <input type="text" id="longman-app-id" placeholder="Your Longman ID" autocomplete="off" />
        <label for="longman-app-key" style="margin-top: 0.75rem;">Longman App Key</label>
        <input type="password" id="longman-app-key" placeholder="Longman key" autocomplete="off" />
        <label for="merriam-key" style="margin-top: 0.75rem;">Merriam-Webster Key</label>
        <input type="password" id="merriam-key" placeholder="Merriam-Webster key" autocomplete="off" />
        <label for="oxford-app-id" style="margin-top: 0.75rem;">Oxford App ID</label>
        <input type="text" id="oxford-app-id" placeholder="Oxford ID" autocomplete="off" />
        <label for="oxford-app-key" style="margin-top: 0.75rem;">Oxford App Key</label>
        <input type="password" id="oxford-app-key" placeholder="Oxford key" autocomplete="off" />
        <p style="font-size: 0.8rem; line-height: 1.4; color: rgba(255, 255, 255, 0.85);">
          Keys are stored locally in your browser and used only for dictionary requests.
        </p>
      </section>
    </aside>

    <main class="main">
      <section
        class="panel setup-notice"
        id="setup-notice"
        aria-live="polite"
      >
        <h2>Set up AnkiConnect for GitHub Pages</h2>
        <p style="margin: 0;">
          Allow this page to talk to AnkiConnect so decks and cards can be
          managed from the browser.
        </p>
        <ol class="setup-steps">
          <li>
            In Anki, open <strong>Tools → Add-ons → AnkiConnect → Config</strong>.
          </li>
          <li>
            Add your GitHub Pages URL to the <code>webCorsOriginList</code>
            setting.
          </li>
          <li>Save the configuration and restart Anki if prompted.</li>
        </ol>
        <div class="setup-snippet" role="region" aria-label="Sample AnkiConnect configuration">
          <pre><code>{
  "webCorsOriginList": [
    "https://&lt;your-username&gt;.github.io",
    "https://&lt;your-username&gt;.github.io/anki/"
  ]
}</code></pre>
        </div>
        <p class="setup-footnote">
          This notice hides automatically after AnkiConnect responds
          successfully.
        </p>
        <p class="setup-footnote">
          Ensure your AnkiConnect configuration allows the
          <code>findNotes</code>, <code>notesInfo</code>, and
          <code>updateNoteFields</code> actions so this tool can surface and
          refresh existing cards within your decks.
        </p>
      </section>

      <section class="panel" id="dictionary-panel">
        <h2>Dictionary Lookup</h2>
        <div class="dictionary-controls">
          <input type="text" id="lookup-term" placeholder="Search term" />
          <div class="dictionary-scope" aria-live="polite">All dictionaries</div>
          <button id="search-dictionary">Search</button>
        </div>
        <div class="dictionary-settings">
          <div>
            <p style="margin: 0 0 0.5rem 0; font-weight: 600; color: #2f4075;">Search scope</p>
            <div class="scope-toggle" role="group" aria-label="Search scope">
              <button type="button" class="is-active" data-scope="online-decks">Online + decks</button>
              <button type="button" data-scope="online-only">Online only</button>
              <button type="button" data-scope="decks-only">Decks only</button>
            </div>
          </div>
          <div>
            <p style="margin: 0 0 0.5rem 0; font-weight: 600; color: #2f4075;">Dictionaries</p>
            <div class="dictionary-provider-grid" id="dictionary-provider-grid"></div>
          </div>
        </div>
        <div class="suggestions" id="spelling-suggestions" hidden></div>
        <div class="dictionary-results" id="dictionary-results"></div>
      </section>

      <section class="panel" id="note-panel">
        <h2>Customize Card</h2>
        <div class="split" style="grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));">
          <div>
            <label for="front-field">Front</label>
            <textarea id="front-field" placeholder="Front of the card"></textarea>
          </div>
          <div>
            <label for="back-field">Back</label>
            <textarea id="back-field" placeholder="Back of the card"></textarea>
          </div>
        </div>
        <div class="split" style="margin-top: 1.5rem;">
          <label for="example-field">Example Sentence (optional)</label>
          <textarea id="example-field" placeholder="Add your own or pick one from the dictionary results"></textarea>
        </div>
        <div style="margin-top: 1.5rem; display: flex; gap: 1rem; align-items: center;">
          <button id="add-card">Add Card to Deck</button>
          <span class="status" id="status"></span>
        </div>
      </section>

      <section class="panel" id="preview-panel">
        <h2>Preview</h2>
        <p><strong>Deck:</strong> <span id="preview-deck">—</span></p>
        <p><strong>Note Type:</strong> <span id="preview-model">Basic</span></p>
        <p><strong>Tags:</strong> <span id="preview-tags">—</span></p>
        <article style="margin-top: 1rem; padding: 1rem; border-radius: 12px; background: rgba(63, 100, 199, 0.08);">
          <h3 style="margin-top: 0;">Front</h3>
          <p id="preview-front" style="white-space: pre-wrap;"></p>
          <h3>Back</h3>
          <p id="preview-back" style="white-space: pre-wrap;"></p>
          <h3>Example</h3>
          <p id="preview-example" style="white-space: pre-wrap;"></p>
        </article>
      </section>
    </main>
  </div>

  <script>
    const deckSelect = document.getElementById("deck-select");
    const loadDecksBtn = document.getElementById("load-decks");
    const lookupTermInput = document.getElementById("lookup-term");
    const searchButton = document.getElementById("search-dictionary");
    const dictionaryScopeDisplay = document.querySelector(".dictionary-scope");
    const dictionaryProviderGrid = document.getElementById("dictionary-provider-grid");
    const dictionaryResults = document.getElementById("dictionary-results");
    const spellingSuggestions = document.getElementById("spelling-suggestions");
    const frontField = document.getElementById("front-field");
    const backField = document.getElementById("back-field");
    const exampleField = document.getElementById("example-field");
    const addCardBtn = document.getElementById("add-card");
    const statusEl = document.getElementById("status");
    const usernameInput = document.getElementById("anki-username");
    const passwordInput = document.getElementById("anki-password");
    const modelNameInput = document.getElementById("model-name");
    const modelSuggestions = document.getElementById("model-suggestions");
    const tagsInput = document.getElementById("tags");
    const setupNotice = document.getElementById("setup-notice");
    const scopeToggleButtons = document.querySelectorAll(".scope-toggle button");
    const longmanAppIdInput = document.getElementById("longman-app-id");
    const longmanAppKeyInput = document.getElementById("longman-app-key");
    const merriamKeyInput = document.getElementById("merriam-key");
    const oxfordAppIdInput = document.getElementById("oxford-app-id");
    const oxfordAppKeyInput = document.getElementById("oxford-app-key");

    const previewDeck = document.getElementById("preview-deck");
    const previewModel = document.getElementById("preview-model");
    const previewTags = document.getElementById("preview-tags");
    const previewFront = document.getElementById("preview-front");
    const previewBack = document.getElementById("preview-back");
    const previewExample = document.getElementById("preview-example");

    const SESSION_KEYS = {
      credentials: "anki.session.credentials",
      deck: "anki.session.deck",
      setupNoticeDismissed: "anki.session.setupDismissed",
    };

    const LOCAL_STORAGE_KEYS = {
      dictionaryApi: "anki.dictionary.apiKeys",
      providerSelection: "anki.dictionary.providers",
      searchScope: "anki.dictionary.scope",
    };

    const DEFAULT_MODEL_NAME = "Basic";
    const NOTE_SAMPLE_BATCH_SIZE = 200;
    const NOTE_SAMPLE_BATCH_LIMIT = 5;
    const NOTE_SEARCH_LIMIT = 25;
    const SEARCH_SCOPES = {
      onlineDecks: "online-decks",
      onlineOnly: "online-only",
      decksOnly: "decks-only",
    };
    const PART_OF_SPEECH_ALIASES = {
      noun: ["noun", "n", "n.", "countable noun", "uncountable noun", "plural noun"],
      verb: ["verb", "v", "v.", "transitive verb", "intransitive verb", "phrasal verb"],
      adjective: ["adjective", "adj", "adj.", "adjectival"],
      adverb: ["adverb", "adv", "adv."],
      pronoun: ["pronoun", "prn", "prn."],
      preposition: ["preposition", "prep", "prep."],
      conjunction: ["conjunction", "conj", "conj."],
      interjection: ["interjection", "int", "int."],
      determiner: ["determiner", "det", "det.", "article"],
      idiom: ["idiom", "phrase", "set phrase", "expression", "idiomatic"],
    };

    const htmlParser = document.createElement("div");

    let userModifiedNoteType = false;
    let pendingNoteTypeDeck = "";
    let dictionaryApiConfig =
      safeParseJSON(getLocalStorageItem(LOCAL_STORAGE_KEYS.dictionaryApi), {}) || {};
    const providerSelectionRaw = safeParseJSON(
      getLocalStorageItem(LOCAL_STORAGE_KEYS.providerSelection),
      []
    );
    let activeSearchScope =
      getLocalStorageItem(LOCAL_STORAGE_KEYS.searchScope) || "online-decks";

    const activeProviderSelection = new Set(
      Array.isArray(providerSelectionRaw) ? providerSelectionRaw : []
    );

    if (!Object.values(SEARCH_SCOPES).includes(activeSearchScope)) {
      activeSearchScope = SEARCH_SCOPES.onlineDecks;
    }

    let lastPartOfSpeechFilter = "";

    function safeParseJSON(value, fallback = null) {
      if (!value) {
        return fallback;
      }
      try {
        return JSON.parse(value);
      } catch (error) {
        console.warn("Failed to parse session JSON", error);
        return fallback;
      }
    }

    function getSessionItem(key) {
      try {
        return sessionStorage.getItem(key);
      } catch (error) {
        console.warn("Session storage unavailable", error);
        return null;
      }
    }

    function setSessionItem(key, value) {
      try {
        if (value === null || value === undefined) {
          sessionStorage.removeItem(key);
        } else {
          sessionStorage.setItem(key, value);
        }
      } catch (error) {
        console.warn("Failed to persist session value", error);
      }
    }

    function getLocalStorageItem(key) {
      try {
        return localStorage.getItem(key);
      } catch (error) {
        console.warn("Local storage unavailable", error);
        return null;
      }
    }

    function setLocalStorageItem(key, value) {
      try {
        if (value === null || value === undefined) {
          localStorage.removeItem(key);
        } else {
          localStorage.setItem(key, value);
        }
      } catch (error) {
        console.warn("Failed to persist local value", error);
      }
    }

    function canonicalizePartOfSpeech(label) {
      if (!label) {
        return "";
      }

      const cleaned = label
        .toString()
        .toLowerCase()
        .replace(/<[^>]*>/g, "")
        .replace(/[^a-z\s]/g, " ")
        .replace(/\s+/g, " ")
        .trim();

      if (!cleaned) {
        return "";
      }

      for (const [canonical, aliases] of Object.entries(PART_OF_SPEECH_ALIASES)) {
        if (aliases.some((alias) => cleaned === alias || cleaned.includes(alias))) {
          return canonical;
        }
      }

      return cleaned;
    }

    function generateSearchVariants(term) {
      const variants = new Set();
      const trimmed = (term || "").trim();
      if (!trimmed) {
        return [];
      }

      variants.add(trimmed);
      variants.add(trimmed.replace(/\s+/g, "-"));
      variants.add(trimmed.replace(/\s+/g, ""));
      variants.add(trimmed.replace(/-/g, " "));
      variants.add(trimmed.replace(/-/g, ""));
      variants.add(trimmed.replace(/[’']/g, ""));

      return Array.from(variants).filter(Boolean);
    }

    function parseLookupTerm(rawTerm) {
      const original = rawTerm;
      let working = rawTerm.trim();
      let posHint = "";

      const asMatch = working.match(/^(.*?)[\s,:-]*as\s+an?\s+([a-z-]+)/i);
      if (asMatch) {
        working = asMatch[1].trim();
        posHint = posHint || asMatch[2].trim();
      }

      const parenMatch = working.match(/^(.*?)[\s]*\(([^)]+)\)\s*$/);
      if (parenMatch) {
        working = parenMatch[1].trim();
        posHint = posHint || parenMatch[2].trim();
      }

      const commaMatch = working.match(/^(.*?)[\s,;-]+(noun|verb|adjective|adverb|pronoun|preposition|conjunction|interjection|idiom|phrase)$/i);
      if (commaMatch) {
        working = commaMatch[1].trim();
        posHint = posHint || commaMatch[2].trim();
      }

      const partOfSpeech = canonicalizePartOfSpeech(posHint);
      const normalizedTerm = working.replace(/\s+/g, " ").trim();
      const variants = generateSearchVariants(normalizedTerm);
      const tokens = normalizedTerm.split(/\s+/).filter(Boolean);

      return {
        originalTerm: original,
        term: normalizedTerm,
        partOfSpeech,
        variants,
        tokens,
      };
    }

    function filterEntryByPartOfSpeech(entry, partOfSpeech) {
      if (!partOfSpeech || !entry || !Array.isArray(entry.meanings)) {
        return entry;
      }

      const filteredMeanings = entry.meanings
        .map((meaning) => {
          if (!meaning || !Array.isArray(meaning.definitions) || !meaning.definitions.length) {
            return null;
          }

          const meaningPos = canonicalizePartOfSpeech(meaning.partOfSpeech || "");

          if (meaningPos) {
            if (meaningPos !== partOfSpeech && !meaningPos.includes(partOfSpeech)) {
              return null;
            }
          } else {
            const rawPos = (meaning.partOfSpeech || "").toString().toLowerCase();
            if (rawPos && !rawPos.includes(partOfSpeech)) {
              return null;
            }
          }

          return {
            ...meaning,
            partOfSpeech: meaning.partOfSpeech,
            definitions: meaning.definitions,
          };
        })
        .filter(Boolean);

      if (!filteredMeanings.length) {
        return null;
      }

      return {
        ...entry,
        meanings: filteredMeanings,
      };
    }

    function serializeApiConfig() {
      const keys = Object.keys(dictionaryApiConfig || {});
      if (!keys.length) {
        setLocalStorageItem(LOCAL_STORAGE_KEYS.dictionaryApi, null);
        return;
      }
      setLocalStorageItem(
        LOCAL_STORAGE_KEYS.dictionaryApi,
        JSON.stringify(dictionaryApiConfig)
      );
    }

    function updateApiConfigValue(providerId, keyName, value) {
      if (!providerId || !keyName) {
        return;
      }

      if (!dictionaryApiConfig || typeof dictionaryApiConfig !== "object") {
        dictionaryApiConfig = {};
      }

      if (!dictionaryApiConfig[providerId]) {
        dictionaryApiConfig[providerId] = {};
      }

      if (!value) {
        delete dictionaryApiConfig[providerId][keyName];
      } else {
        dictionaryApiConfig[providerId][keyName] = value;
      }

      if (dictionaryApiConfig[providerId] && !Object.keys(dictionaryApiConfig[providerId]).length) {
        delete dictionaryApiConfig[providerId];
      }

      serializeApiConfig();
    }

    function registerApiInput(input, providerId, keyName) {
      if (!input) {
        return;
      }

      const storedValue = dictionaryApiConfig?.[providerId]?.[keyName];
      if (storedValue) {
        input.value = storedValue;
      }

      const persist = () => {
        updateApiConfigValue(providerId, keyName, input.value.trim());
      };

      input.addEventListener("change", persist);
      input.addEventListener("blur", persist);
      input.addEventListener("input", () => {
        // Avoid excessive writes while typing by batching through requestAnimationFrame
        if (input._persistTimer) {
          cancelAnimationFrame(input._persistTimer);
        }
        input._persistTimer = requestAnimationFrame(persist);
      });
    }

    function getProviderCredentials(providerId) {
      if (!providerId) {
        return {};
      }
      const credentials = dictionaryApiConfig?.[providerId];
      if (!credentials || typeof credentials !== "object") {
        return {};
      }
      return credentials;
    }

    function persistProviderSelection() {
      const ids = Array.from(activeProviderSelection);
      if (!ids.length) {
        setLocalStorageItem(LOCAL_STORAGE_KEYS.providerSelection, null);
        return;
      }
      setLocalStorageItem(LOCAL_STORAGE_KEYS.providerSelection, JSON.stringify(ids));
    }

    function getActiveDictionaryProviderIds() {
      if (activeProviderSelection.size) {
        return Array.from(activeProviderSelection).filter(
          (id) => !!dictionaryProviders[id]
        );
      }

      return Object.values(dictionaryProviders)
        .filter((provider) => provider?.defaultEnabled !== false)
        .map((provider) => provider.id);
    }

    function updateDictionaryScopeLabel(partOfSpeechLabel = lastPartOfSpeechFilter) {
      if (!dictionaryScopeDisplay) {
        return;
      }

      const providerIds = activeSearchScope === SEARCH_SCOPES.decksOnly
        ? []
        : getActiveDictionaryProviderIds();

      const providerLabels = providerIds
        .map((id) => dictionaryProviders[id]?.label || id)
        .filter(Boolean);

      let providerSummary = "No online dictionaries";
      if (providerLabels.length === 1) {
        providerSummary = providerLabels[0];
      } else if (providerLabels.length > 1) {
        if (providerLabels.length <= 3) {
          providerSummary = providerLabels.join(", ");
        } else {
          providerSummary = `${providerLabels.slice(0, 2).join(", ")}, +${
            providerLabels.length - 2
          } more`;
        }
      }

      const scopeLabelMap = {
        [SEARCH_SCOPES.onlineDecks]: "Online + decks",
        [SEARCH_SCOPES.onlineOnly]: "Online only",
        [SEARCH_SCOPES.decksOnly]: "Decks only",
      };

      const scopeText = scopeLabelMap[activeSearchScope] || "Custom scope";

      const parts = [scopeText];
      if (activeSearchScope !== SEARCH_SCOPES.decksOnly) {
        parts.push(providerSummary);
      }
      if (partOfSpeechLabel) {
        parts.push(`POS: ${partOfSpeechLabel}`);
      }

      dictionaryScopeDisplay.textContent = parts.join(" • ");
    }

    function setSearchScope(scope) {
      if (!scope || activeSearchScope === scope) {
        updateDictionaryScopeLabel();
        return;
      }

      activeSearchScope = scope;
      setLocalStorageItem(LOCAL_STORAGE_KEYS.searchScope, scope);

      scopeToggleButtons.forEach((button) => {
        button.classList.toggle("is-active", button.dataset.scope === scope);
      });

      updateDictionaryScopeLabel();
    }

    function initializeScopeButtons() {
      scopeToggleButtons.forEach((button) => {
        const scope = button.dataset.scope;
        button.classList.toggle("is-active", scope === activeSearchScope);
        button.addEventListener("click", () => {
          setSearchScope(scope);
        });
      });
    }

    function initializeDictionaryProviderOptions() {
      if (!dictionaryProviderGrid) {
        return;
      }

      dictionaryProviderGrid.innerHTML = "";

      const defaultsAdded = new Set();

      Object.values(dictionaryProviders).forEach((provider) => {
        if (!provider || provider.hidden) {
          return;
        }

        const option = document.createElement("label");
        option.className = "provider-option";

        const checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkbox.value = provider.id;

        let isSelected = activeProviderSelection.has(provider.id);
        if (!activeProviderSelection.size && provider.defaultEnabled !== false) {
          isSelected = true;
          defaultsAdded.add(provider.id);
        }

        checkbox.checked = isSelected;
        if (isSelected) {
          activeProviderSelection.add(provider.id);
        }

        checkbox.addEventListener("change", () => {
          if (checkbox.checked) {
            activeProviderSelection.add(provider.id);
          } else {
            activeProviderSelection.delete(provider.id);
          }
          persistProviderSelection();
          updateDictionaryScopeLabel();
        });

        option.appendChild(checkbox);

        const labelText = document.createElement("span");
        labelText.textContent = provider.label || provider.id;
        option.appendChild(labelText);

        dictionaryProviderGrid.appendChild(option);
      });

      if (defaultsAdded.size) {
        persistProviderSelection();
      }

      updateDictionaryScopeLabel();
    }

    function persistCredentials() {
      const username = usernameInput.value.trim();
      const password = passwordInput.value;
      if (!username && !password) {
        setSessionItem(SESSION_KEYS.credentials, null);
        return;
      }

      setSessionItem(
        SESSION_KEYS.credentials,
        JSON.stringify({ username, password })
      );
    }

    function persistDeckSelection() {
      const deck = deckSelect.value;
      if (deck) {
        setSessionItem(SESSION_KEYS.deck, deck);
      } else {
        setSessionItem(SESSION_KEYS.deck, null);
      }
    }

    function setStatus(message, type = "") {
      statusEl.textContent = message;
      statusEl.className = "status" + (type ? " " + type : "");
    }

    function hideSetupNotice() {
      if (setupNotice) {
        setupNotice.classList.add("is-hidden");
      }
    }

    function showSetupNotice() {
      if (setupNotice) {
        setupNotice.classList.remove("is-hidden");
      }
    }

    let hasSuccessfulAnkiConnect =
      getSessionItem(SESSION_KEYS.setupNoticeDismissed) === "true";

    if (hasSuccessfulAnkiConnect) {
      hideSetupNotice();
    } else {
      showSetupNotice();
    }

    function markAnkiConnectSuccess() {
      if (hasSuccessfulAnkiConnect) {
        return;
      }
      hasSuccessfulAnkiConnect = true;
      hideSetupNotice();
      setSessionItem(SESSION_KEYS.setupNoticeDismissed, "true");
    }

    const savedCredentials = safeParseJSON(getSessionItem(SESSION_KEYS.credentials), {});
    if (savedCredentials?.username) {
      usernameInput.value = savedCredentials.username;
    }
    if (savedCredentials?.password) {
      passwordInput.value = savedCredentials.password;
    }

    function updatePreview() {
      const deckName = deckSelect.value ? deckSelect.value : "—";
      previewDeck.textContent = deckName;
      previewModel.textContent = modelNameInput.value.trim() || DEFAULT_MODEL_NAME;
      const tags = tagsInput.value.trim();
      previewTags.textContent = tags || "—";
      previewFront.textContent = frontField.value;
      previewBack.textContent = backField.value;
      previewExample.textContent = exampleField.value;
    }

    [frontField, backField, exampleField, tagsInput].forEach((element) => {
      element.addEventListener("input", updatePreview);
      element.addEventListener("change", updatePreview);
    });

    function handleModelNameInput() {
      userModifiedNoteType = true;
      updatePreview();
    }

    modelNameInput.addEventListener("input", handleModelNameInput);
    modelNameInput.addEventListener("change", handleModelNameInput);

    function updateModelSuggestions(noteTypes) {
      if (!modelSuggestions) {
        return;
      }

      modelSuggestions.innerHTML = "";
      noteTypes.forEach((noteType) => {
        if (!noteType) {
          return;
        }
        const option = document.createElement("option");
        option.value = noteType;
        modelSuggestions.appendChild(option);
      });
    }

    deckSelect.addEventListener("change", () => {
      persistDeckSelection();
      userModifiedNoteType = false;
      updatePreview();
      const deckName = deckSelect.value;
      if (deckName) {
        loadNoteTypesForDeck(deckName);
      } else {
        updateModelSuggestions([]);
      }
    });

    usernameInput.addEventListener("input", persistCredentials);
    passwordInput.addEventListener("input", persistCredentials);
    async function callAnkiConnect(action, params = {}) {
      let response;
      try {
        response = await fetch("http://127.0.0.1:8765", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ action, version: 6, params }),
        });
      } catch (networkError) {
        console.error(networkError);
        throw new Error(
          "Unable to reach AnkiConnect. Please ensure Anki is running and the AnkiConnect add-on is installed."
        );
      }

      if (!response.ok) {
        throw new Error(`AnkiConnect request failed: ${response.status}`);
      }

      const data = await response.json();
      if (data.error) {
        throw new Error(data.error);
      }

      markAnkiConnectSuccess();

      return data.result;
    }

    function textContainsTerm(text, term) {
      return text && term && text.toLowerCase().includes(term.toLowerCase());
    }

    function cleanExample(example) {
      if (!example) {
        return "";
      }
      const cleaned = stripHtml(example)
        .replace(/\s+/g, " ")
        .replace(/[\[\]]/g, "")
        .trim();
      return cleaned;
    }

    function normalizeDefinitions(definitions = []) {
      return definitions
        .map((item) => {
          if (!item) {
            return null;
          }
          const definition = stripHtml(
            (item.definition || item.meaning || item.text || "").toString()
          ).trim();
          if (!definition) {
            return null;
          }
          let example = "";
          if (typeof item.example === "string") {
            example = cleanExample(item.example);
          } else if (Array.isArray(item.examples) && item.examples.length) {
            example = cleanExample(item.examples[0]);
          }
          return { definition, example };
        })
        .filter(Boolean);
    }

    function normalizeFreeDictionaryEntries(data, term) {
      if (!Array.isArray(data)) {
        return [];
      }

      return data
        .map((entry) => {
          const phonetic =
            entry.phonetic ||
            (Array.isArray(entry.phonetics)
              ? entry.phonetics.find((p) => p && p.text)?.text || ""
              : "");

          const meanings = Array.isArray(entry.meanings)
            ? entry.meanings
                .map((meaning) => {
                  const definitions = normalizeDefinitions(meaning.definitions);
                  if (!definitions.length) {
                    return null;
                  }
                  return {
                    partOfSpeech: meaning.partOfSpeech || "Definition",
                    definitions,
                  };
                })
                .filter(Boolean)
            : [];

          if (!meanings.length) {
            return null;
          }

          return {
            word: entry.word || term,
            phonetic: phonetic || "",
            source: "Free Dictionary",
            meanings,
          };
        })
        .filter(Boolean);
    }

    async function fetchFreeDictionaryEntries(term, parsedTerm) {
      const variants = Array.isArray(parsedTerm?.variants) && parsedTerm.variants.length
        ? parsedTerm.variants
        : [term];

      for (const variant of variants) {
        const response = await fetch(
          `https://api.dictionaryapi.dev/api/v2/entries/en/${encodeURIComponent(variant)}`
        );

        if (response.status === 404) {
          continue;
        }

        if (!response.ok) {
          throw new Error("Dictionary lookup failed");
        }

        const data = await response.json();
        const entries = normalizeFreeDictionaryEntries(data, variant);
        if (entries.length) {
          return entries;
        }
      }

      return [];
    }

    function normalizeWiktionaryEntries(data, term) {
      if (!data || typeof data !== "object") {
        return [];
      }

      const englishEntries = Array.isArray(data.en) ? data.en : [];
      return englishEntries
        .map((entry) => {
          const definitions = normalizeDefinitions(entry.definitions || entry.senses);
          if (!definitions.length) {
            return null;
          }

          return {
            word: entry.word || term,
            phonetic: "",
            source: "Wiktionary",
            meanings: [
              {
                partOfSpeech: entry.partOfSpeech || entry.part_of_speech || "Definition",
                definitions,
              },
            ],
          };
        })
        .filter(Boolean);
    }

    async function fetchWiktionaryEntries(term, parsedTerm) {
      const variants = Array.isArray(parsedTerm?.variants) && parsedTerm.variants.length
        ? parsedTerm.variants
        : [term];

      for (const variant of variants) {
        const response = await fetch(
          `https://en.wiktionary.org/api/rest_v1/page/definition/${encodeURIComponent(variant)}`,
          {
            headers: {
              "Api-User-Agent": "anki-card-creator/1.0 (https://ankiweb.net)",
            },
          }
        );

        if (response.status === 404) {
          continue;
        }

        if (!response.ok) {
          throw new Error("Wiktionary lookup failed");
        }

        const data = await response.json();
        const entries = normalizeWiktionaryEntries(data, variant);
        if (entries.length) {
          return entries;
        }
      }

      return [];
    }

    function normalizeUrbanEntries(data, term) {
      const list = Array.isArray(data?.list) ? data.list.slice(0, 10) : [];
      return list
        .map((item, index) => {
          const definitions = normalizeDefinitions([
            {
              definition: item.definition,
              example: item.example,
            },
          ]);

          if (!definitions.length) {
            return null;
          }

          return {
            word: item.word || term,
            phonetic: "",
            source: "Urban Dictionary",
            meanings: [
              {
                partOfSpeech: item.word_type || item.tag || `Entry ${index + 1}`,
                definitions,
              },
            ],
          };
        })
        .filter(Boolean);
    }

    async function fetchUrbanEntries(term, parsedTerm) {
      const queryTerm = parsedTerm?.term || term;
      const response = await fetch(
        `https://api.urbandictionary.com/v0/define?term=${encodeURIComponent(queryTerm)}`
      );

      if (!response.ok) {
        throw new Error("Urban Dictionary lookup failed");
      }

      const data = await response.json();
      return normalizeUrbanEntries(data, queryTerm);
    }

    function normalizeLongmanEntries(data, term) {
      const items = Array.isArray(data?.results)
        ? data.results
        : Array.isArray(data?.entries)
        ? data.entries
        : Array.isArray(data)
        ? data
        : [];

      return items
        .map((item) => {
          const headword = item?.headword || item?.word || term;
          const pronunciations = Array.isArray(item?.pronunciations)
            ? item.pronunciations
                .map((pron) => pron?.ipa || pron?.phonetic || pron?.pronunciation)
                .filter(Boolean)
            : [];
          const phonetic = pronunciations[0] || item?.pronunciation || "";

          const senses = Array.isArray(item?.senses)
            ? item.senses
            : Array.isArray(item?.sense)
            ? item.sense
            : [];

          const meanings = senses
            .map((sense, index) => {
              const definitionSources = Array.isArray(sense?.definition)
                ? sense.definition
                : Array.isArray(sense?.definitions)
                ? sense.definitions
                : sense?.definition
                ? [sense.definition]
                : [];

              const exampleText = Array.isArray(sense?.examples)
                ? sense.examples
                    .map((example) =>
                      typeof example === "string"
                        ? example
                        : example?.text || example?.example || ""
                    )
                    .find((value) => value && value.trim()) || ""
                : "";

              const definitions = normalizeDefinitions(
                definitionSources.map((definition) => ({
                  definition,
                  example: exampleText,
                }))
              );

              if (!definitions.length) {
                return null;
              }

              return {
                partOfSpeech:
                  sense?.part_of_speech ||
                  sense?.partOfSpeech ||
                  item?.part_of_speech ||
                  item?.partOfSpeech ||
                  `Sense ${index + 1}`,
                definitions,
              };
            })
            .filter(Boolean);

          if (!meanings.length) {
            return null;
          }

          return {
            word: headword || term,
            phonetic: phonetic || "",
            source: "Longman",
            meanings,
          };
        })
        .filter(Boolean);
    }

    async function fetchLongmanEntries(term, parsedTerm, options = {}) {
      const credentials = options.credentials || {};
      const appId = credentials.appId || credentials.app_id;
      const appKey = credentials.appKey || credentials.app_key;

      if (!appId || !appKey) {
        throw new Error("Longman API credentials are missing.");
      }

      const variants = Array.isArray(parsedTerm?.variants) && parsedTerm.variants.length
        ? parsedTerm.variants
        : [term];

      for (const variant of variants) {
        const response = await fetch(
          `https://api.ldoceonline.com/v2/dictionaries/entries?headword=${encodeURIComponent(variant)}`,
          {
            headers: {
              Accept: "application/json",
              "Content-Type": "application/json",
              app_id: appId,
              app_key: appKey,
            },
          }
        );

        if (!response.ok) {
          if (response.status === 404) {
            continue;
          }
          throw new Error("Longman lookup failed");
        }

        const data = await response.json();
        const entries = normalizeLongmanEntries(data, variant);
        if (entries.length) {
          return entries;
        }
      }

      return [];
    }

    function normalizeMerriamEntries(data, term) {
      if (!Array.isArray(data)) {
        return [];
      }

      return data
        .map((entry) => {
          if (!entry || !Array.isArray(entry.shortdef) || !entry.shortdef.length) {
            return null;
          }

          const definitions = normalizeDefinitions(
            entry.shortdef.map((definition) => ({ definition }))
          );

          if (!definitions.length) {
            return null;
          }

          const headword = entry.hwi?.hw ? entry.hwi.hw.replace(/\*/g, "") : term;
          const phonetic = Array.isArray(entry.hwi?.prs)
            ? entry.hwi.prs
                .map((pron) => pron?.ipa || pron?.mw)
                .find((value) => value && value.trim()) || ""
            : "";

          return {
            word: headword || term,
            phonetic,
            source: "Merriam-Webster",
            meanings: [
              {
                partOfSpeech: entry.fl || "Definition",
                definitions,
              },
            ],
          };
        })
        .filter(Boolean);
    }

    async function fetchMerriamEntries(term, parsedTerm, options = {}) {
      const apiKey = options.credentials?.key;
      if (!apiKey) {
        throw new Error("Merriam-Webster API key is missing.");
      }

      const variants = Array.isArray(parsedTerm?.variants) && parsedTerm.variants.length
        ? parsedTerm.variants
        : [term];

      for (const variant of variants) {
        const response = await fetch(
          `https://www.dictionaryapi.com/api/v3/references/learners/json/${encodeURIComponent(variant)}?key=${apiKey}`
        );

        if (!response.ok) {
          if (response.status === 404) {
            continue;
          }
          throw new Error("Merriam-Webster lookup failed");
        }

        const data = await response.json();
        const entries = normalizeMerriamEntries(data, variant);
        if (entries.length) {
          return entries;
        }
      }

      return [];
    }

    function normalizeOxfordEntries(data, term) {
      const results = Array.isArray(data?.results) ? data.results : [];
      const aggregated = [];

      results.forEach((result) => {
        const baseWord = result?.word || term;
        const lexicalEntries = Array.isArray(result?.lexicalEntries)
          ? result.lexicalEntries
          : [];

        lexicalEntries.forEach((lexicalEntry) => {
          const pronunciations = Array.isArray(lexicalEntry?.pronunciations)
            ? lexicalEntry.pronunciations
                .map((pron) => pron?.phoneticSpelling || pron?.phoneticNotation)
                .filter(Boolean)
            : [];
          const phonetic = pronunciations[0] || result?.pronunciations?.[0]?.phoneticSpelling || "";

          const entryNodes = Array.isArray(lexicalEntry?.entries)
            ? lexicalEntry.entries
            : [];

          const definitionPayloads = [];

          entryNodes.forEach((entryNode) => {
            const senses = Array.isArray(entryNode?.senses) ? entryNode.senses : [];
            senses.forEach((sense) => {
              const senseDefinitions = Array.isArray(sense?.definitions)
                ? sense.definitions
                : sense?.definition
                ? [sense.definition]
                : [];
              const examples = Array.isArray(sense?.examples)
                ? sense.examples
                    .map((example) => example?.text || example)
                    .filter(Boolean)
                : [];

              senseDefinitions.forEach((definition) => {
                definitionPayloads.push({
                  definition,
                  example: examples[0] || "",
                });
              });

              const subsenses = Array.isArray(sense?.subsenses) ? sense.subsenses : [];
              subsenses.forEach((sub) => {
                const subDefinitions = Array.isArray(sub?.definitions)
                  ? sub.definitions
                  : sub?.definition
                  ? [sub.definition]
                  : [];
                const subExamples = Array.isArray(sub?.examples)
                  ? sub.examples
                      .map((example) => example?.text || example)
                      .filter(Boolean)
                  : [];

                subDefinitions.forEach((definition) => {
                  definitionPayloads.push({
                    definition,
                    example: subExamples[0] || examples[0] || "",
                  });
                });
              });
            });
          });

          const definitions = normalizeDefinitions(definitionPayloads);
          if (!definitions.length) {
            return;
          }

          aggregated.push({
            word: baseWord,
            phonetic: phonetic || "",
            source: "Oxford", 
            meanings: [
              {
                partOfSpeech:
                  lexicalEntry?.lexicalCategory?.text ||
                  lexicalEntry?.lexicalCategory ||
                  "Definition",
                definitions,
              },
            ],
          });
        });
      });

      return aggregated;
    }

    async function fetchOxfordEntries(term, parsedTerm, options = {}) {
      const credentials = options.credentials || {};
      const appId = credentials.appId || credentials.app_id;
      const appKey = credentials.appKey || credentials.app_key;

      if (!appId || !appKey) {
        throw new Error("Oxford API credentials are missing.");
      }

      const variants = Array.isArray(parsedTerm?.variants) && parsedTerm.variants.length
        ? parsedTerm.variants
        : [term];

      for (const variant of variants) {
        const response = await fetch(
          `https://od-api.oxforddictionaries.com/api/v2/entries/en/${encodeURIComponent(variant)}`,
          {
            headers: {
              Accept: "application/json",
              app_id: appId,
              app_key: appKey,
            },
          }
        );

        if (!response.ok) {
          if (response.status === 404) {
            continue;
          }
          throw new Error("Oxford lookup failed");
        }

        const data = await response.json();
        const entries = normalizeOxfordEntries(data, variant);
        if (entries.length) {
          return entries;
        }
      }

      return [];
    }

    async function fetchSynonymEntries(term, parsedTerm) {
      const queryTerm = parsedTerm?.term || term;
      const response = await fetch(
        `https://api.datamuse.com/words?rel_syn=${encodeURIComponent(queryTerm)}&max=30`
      );

      if (!response.ok) {
        throw new Error("Synonym lookup failed");
      }

      const data = await response.json();
      const synonyms = Array.isArray(data)
        ? data
            .map((item) => (typeof item === "string" ? item : item?.word))
            .filter(Boolean)
        : [];

      if (!synonyms.length) {
        return [];
      }

      return [
        {
          word: queryTerm,
          source: "Synonyms",
          isSynonymList: true,
          synonyms,
        },
      ];
    }

    async function fetchSpellingSuggestions(term) {
      if (!term) {
        return [];
      }

      try {
        const response = await fetch(
          `https://api.datamuse.com/sug?s=${encodeURIComponent(term)}&max=6`
        );
        if (!response.ok) {
          return [];
        }
        const data = await response.json();
        return Array.isArray(data)
          ? data
              .map((item) => (typeof item === "string" ? item : item?.word))
              .filter(Boolean)
          : [];
      } catch (error) {
        console.warn("Spelling suggestion lookup failed", error);
        return [];
      }
    }

    const dictionaryProviders = {
      freeDictionary: {
        id: "freeDictionary",
        label: "Free Dictionary",
        fetchEntries: fetchFreeDictionaryEntries,
        supportsEmbeddedSearch: true,
        defaultEnabled: true,
        type: "definition",
      },
      wiktionary: {
        id: "wiktionary",
        label: "Wiktionary",
        fetchEntries: fetchWiktionaryEntries,
        supportsEmbeddedSearch: true,
        defaultEnabled: true,
        type: "definition",
      },
      longman: {
        id: "longman",
        label: "Longman",
        fetchEntries: fetchLongmanEntries,
        supportsEmbeddedSearch: true,
        defaultEnabled: false,
        requiresCredentials: true,
        credentialKeys: ["appId", "appKey"],
        type: "definition",
      },
      merriam: {
        id: "merriam",
        label: "Merriam-Webster",
        fetchEntries: fetchMerriamEntries,
        supportsEmbeddedSearch: false,
        defaultEnabled: false,
        requiresCredentials: true,
        credentialKeys: ["key"],
        type: "definition",
      },
      oxford: {
        id: "oxford",
        label: "Oxford",
        fetchEntries: fetchOxfordEntries,
        supportsEmbeddedSearch: true,
        defaultEnabled: false,
        requiresCredentials: true,
        credentialKeys: ["appId", "appKey"],
        type: "definition",
      },
      urban: {
        id: "urban",
        label: "Urban Dictionary",
        fetchEntries: fetchUrbanEntries,
        supportsEmbeddedSearch: false,
        defaultEnabled: false,
        type: "definition",
      },
      synonyms: {
        id: "synonyms",
        label: "Synonyms",
        fetchEntries: fetchSynonymEntries,
        supportsEmbeddedSearch: false,
        defaultEnabled: true,
        type: "synonym",
      },
    };

    registerApiInput(longmanAppIdInput, "longman", "appId");
    registerApiInput(longmanAppKeyInput, "longman", "appKey");
    registerApiInput(merriamKeyInput, "merriam", "key");
    registerApiInput(oxfordAppIdInput, "oxford", "appId");
    registerApiInput(oxfordAppKeyInput, "oxford", "appKey");

    initializeScopeButtons();
    initializeDictionaryProviderOptions();

    async function searchWithinEntries(parsedTerm, providerId, credentials = {}) {
      const provider = dictionaryProviders[providerId];
      if (!provider || !provider.supportsEmbeddedSearch) {
        return [];
      }

      const tokens = Array.isArray(parsedTerm?.tokens) && parsedTerm.tokens.length
        ? parsedTerm.tokens
        : (parsedTerm?.term || "")
            .split(/\s+/)
            .map((token) => token.trim())
            .filter(Boolean);

      const seenTokens = new Set();
      const aggregated = [];

      for (const token of tokens) {
        const normalizedToken = token.toLowerCase();
        if (!normalizedToken || seenTokens.has(normalizedToken)) {
          continue;
        }
        seenTokens.add(normalizedToken);

        try {
          const tokenParsed = parseLookupTerm(token);
          const entries = await provider.fetchEntries(tokenParsed.term, tokenParsed, {
            credentials,
          });
          entries
            .filter((entry) => Array.isArray(entry?.meanings))
            .forEach((entry) => {
              const filteredMeanings = entry.meanings
                .map((meaning) => {
                  const filteredDefinitions = (meaning.definitions || []).filter(
                    (definition) =>
                      textContainsTerm(definition.definition, parsedTerm.term) ||
                      textContainsTerm(definition.example, parsedTerm.term)
                  );
                  if (!filteredDefinitions.length) {
                    return null;
                  }

                  return {
                    partOfSpeech: meaning.partOfSpeech,
                    definitions: filteredDefinitions,
                  };
                })
                .filter(Boolean);

              if (filteredMeanings.length) {
                aggregated.push({
                  ...entry,
                  meanings: filteredMeanings,
                  note: `Matches found inside entry for "${token}"`,
                });
              }
            });
        } catch (error) {
          console.warn(`Embedded search failed for token "${token}"`, error);
        }
      }

      return aggregated;
    }

    function escapeRegExp(value) {
      if (value === null || value === undefined) {
        return "";
      }

      return String(value).replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }

    function escapeDeckNameForQuery(deckName) {
      if (!deckName) {
        return "";
      }

      return deckName.replace(/\\/g, "\\\\").replace(/"/g, '\\"');
    }

    function escapeSearchTerm(term) {
      if (!term) {
        return "";
      }

      return term.replace(/"/g, '\\"').trim();
    }

    function stripHtml(value) {
      if (!value) {
        return "";
      }

      htmlParser.innerHTML = value;
      const text = htmlParser.textContent || htmlParser.innerText || "";
      htmlParser.textContent = "";
      return text.trim();
    }

    function selectFieldEntry(fieldEntries, preferredNames = [], fallbackIndex = 0) {
      const normalizedPreferences = preferredNames.map((name) => name.toLowerCase());
      for (const [fieldName, payload] of fieldEntries) {
        if (normalizedPreferences.includes(fieldName.toLowerCase())) {
          return [fieldName, payload];
        }
      }

      return fieldEntries[fallbackIndex] || null;
    }

    function createNoteDetails(note, deckName) {
      if (!note || !note.noteId || !note.fields) {
        return null;
      }

      const fieldEntries = Object.entries(note.fields);
      if (!fieldEntries.length) {
        return null;
      }

      const frontEntry =
        selectFieldEntry(fieldEntries, ["front"]) || selectFieldEntry(fieldEntries, [], 0);
      const backEntry =
        selectFieldEntry(fieldEntries, ["back"], 1) || selectFieldEntry(fieldEntries, [], 0);
      const exampleEntry = selectFieldEntry(fieldEntries, ["example"]);

      const getValue = (entry) =>
        entry && entry[1] && typeof entry[1].value === "string" ? entry[1].value : "";

      const frontHtml = getValue(frontEntry);
      const backHtml = getValue(backEntry);
      const exampleHtml = getValue(exampleEntry);

      return {
        id: note.noteId,
        deckName,
        modelName: note.modelName || "",
        tags: Array.isArray(note.tags) ? note.tags : [],
        fieldMap: {
          front: frontEntry ? frontEntry[0] : null,
          back: backEntry ? backEntry[0] : null,
          example: exampleEntry ? exampleEntry[0] : null,
        },
        fields: {
          frontHtml,
          backHtml,
          exampleHtml,
        },
        display: {
          frontText: stripHtml(frontHtml),
          backText: stripHtml(backHtml),
          exampleText: stripHtml(exampleHtml),
        },
      };
    }

    function mapDeckNotesToEntries(notesInfo, deckName, term) {
      if (!Array.isArray(notesInfo)) {
        return [];
      }

      return notesInfo
        .map((note) => {
          const noteDetails = createNoteDetails(note, deckName);
          if (!noteDetails) {
            return null;
          }

          const definitionText = noteDetails.display.backText || "(Back field is empty)";

          return {
            uniqueKey: `note-${noteDetails.id}`,
            word: noteDetails.display.frontText || term,
            source: deckName,
            deckName,
            isExistingNote: true,
            noteDetails,
            meanings: [
              {
                partOfSpeech: noteDetails.modelName || "Card content",
                definitions: [
                  {
                    definition: definitionText,
                    example: noteDetails.display.exampleText || "",
                  },
                ],
              },
            ],
            note: `Saved note #${noteDetails.id} in "${deckName}"`,
          };
        })
        .filter(Boolean);
    }

    async function findDeckEntries(term, deckName) {
      if (!deckName) {
        return {
          deckName: "",
          entries: [],
          totalCount: 0,
          shownCount: 0,
          truncated: false,
          error: "",
        };
      }

      const sanitizedDeckName = escapeDeckNameForQuery(deckName);
      const sanitizedTerm = escapeSearchTerm(term);
      const queryParts = [`deck:"${sanitizedDeckName}"`];
      if (sanitizedTerm) {
        queryParts.push(`"${sanitizedTerm}"`);
      }

      const query = queryParts.join(" ");

      try {
        const noteIds = await callAnkiConnect("findNotes", { query });
        if (!Array.isArray(noteIds) || !noteIds.length) {
          return {
            deckName,
            entries: [],
            totalCount: 0,
            shownCount: 0,
            truncated: false,
            error: "",
          };
        }

        const limitedNoteIds = noteIds.slice(0, NOTE_SEARCH_LIMIT);
        const notesInfo = await callAnkiConnect("notesInfo", { notes: limitedNoteIds });
        const entries = mapDeckNotesToEntries(notesInfo, deckName, sanitizedTerm || term);

        return {
          deckName,
          entries,
          totalCount: noteIds.length,
          shownCount: entries.length,
          truncated: noteIds.length > limitedNoteIds.length,
          error: "",
        };
      } catch (error) {
        console.warn(`Deck lookup failed for "${deckName}"`, error);
        return {
          deckName,
          entries: [],
          totalCount: 0,
          shownCount: 0,
          truncated: false,
          error: error?.message || "Deck lookup failed.",
        };
      }
    }

    function applyNoteToEditor(noteDetails) {
      if (!noteDetails) {
        return;
      }

      frontField.value = noteDetails.fields.frontHtml || "";
      backField.value = noteDetails.fields.backHtml || "";
      exampleField.value = noteDetails.fields.exampleHtml || "";

      if (Array.isArray(noteDetails.tags)) {
        tagsInput.value = noteDetails.tags.join(", ");
      } else {
        tagsInput.value = "";
      }

      updatePreview();
    }

    async function updateExistingNoteFromEditor(noteDetails) {
      if (!noteDetails || !noteDetails.id) {
        throw new Error("This note cannot be updated.");
      }

      const updateFields = {};

      if (noteDetails.fieldMap.front) {
        updateFields[noteDetails.fieldMap.front] = frontField.value.trim();
      }

      if (noteDetails.fieldMap.back) {
        updateFields[noteDetails.fieldMap.back] = backField.value.trim();
      }

      if (noteDetails.fieldMap.example) {
        updateFields[noteDetails.fieldMap.example] = exampleField.value.trim();
      }

      const fieldNames = Object.keys(updateFields);
      if (!fieldNames.length) {
        throw new Error("No mapped fields available for update.");
      }

      await callAnkiConnect("updateNoteFields", {
        note: {
          id: noteDetails.id,
          fields: updateFields,
        },
      });
    }

    function createMaskFromMatch(match) {
      if (!match) {
        return match;
      }

      const characters = Array.from(match);
      const masked = [];
      let preservedCount = 0;
      const maskableCharacters = characters.filter((char) => !/\s/.test(char));
      const keep = maskableCharacters.length >= 6 ? 2 : 1;

      characters.forEach((char) => {
        if (/\s/.test(char)) {
          masked.push(char);
        } else if (preservedCount < keep) {
          masked.push(char);
          preservedCount += 1;
        } else {
          masked.push("•");
        }
      });

      return masked.join("");
    }

    function maskTargetInText(text, target) {
      if (!text || !target) {
        return text;
      }

      const escaped = escapeRegExp(target.trim());
      if (!escaped) {
        return text;
      }

      const pattern = new RegExp(escaped, "gi");
      return text.replace(pattern, (match) => createMaskFromMatch(match));
    }

    async function loadNoteTypesForDeck(deckName) {
      if (!deckName) {
        pendingNoteTypeDeck = "";
        updateModelSuggestions([]);
        return;
      }

      pendingNoteTypeDeck = deckName;

      try {
        const sanitizedDeckName = escapeDeckNameForQuery(deckName);
        const noteIds = await callAnkiConnect("findNotes", {
          query: `deck:"${sanitizedDeckName}"`,
        });

        if (pendingNoteTypeDeck !== deckName) {
          return;
        }

        const noteTypeSet = new Set();

        if (Array.isArray(noteIds) && noteIds.length) {
          const batchLimit = Math.max(1, NOTE_SAMPLE_BATCH_LIMIT);
          for (
            let index = 0;
            index < noteIds.length && index / NOTE_SAMPLE_BATCH_SIZE < batchLimit;
            index += NOTE_SAMPLE_BATCH_SIZE
          ) {
            const batch = noteIds.slice(index, index + NOTE_SAMPLE_BATCH_SIZE);
            if (!batch.length) {
              continue;
            }

            const notesInfo = await callAnkiConnect("notesInfo", { notes: batch });

            if (pendingNoteTypeDeck !== deckName) {
              return;
            }

            if (Array.isArray(notesInfo)) {
              notesInfo.forEach((note) => {
                if (note && note.modelName) {
                  noteTypeSet.add(note.modelName);
                }
              });
            }

            if (batch.length < NOTE_SAMPLE_BATCH_SIZE) {
              break;
            }
          }
        }

        if (pendingNoteTypeDeck !== deckName) {
          return;
        }

        let noteTypes = Array.from(noteTypeSet).sort((a, b) => a.localeCompare(b));
        let statusMessage = "";

        if (!noteTypes.length) {
          const allModelNames = await callAnkiConnect("modelNames");

          if (pendingNoteTypeDeck !== deckName) {
            return;
          }

          if (Array.isArray(allModelNames)) {
            allModelNames.forEach((name) => {
              if (name) {
                noteTypeSet.add(name);
              }
            });
          }

          noteTypes = Array.from(noteTypeSet).sort((a, b) => a.localeCompare(b));

          if (!noteTypes.length) {
            throw new Error("No note types available.");
          }

          statusMessage = `No existing notes found in "${deckName}". Showing all note types.`;
        } else {
          statusMessage = `Loaded ${noteTypes.length} note type${
            noteTypes.length === 1 ? "" : "s"
          } from "${deckName}".`;
        }

        if (pendingNoteTypeDeck !== deckName) {
          return;
        }

        updateModelSuggestions(noteTypes);

        const currentModelName = modelNameInput.value.trim();
        if (!userModifiedNoteType || !noteTypes.includes(currentModelName)) {
          const preferredModelName = noteTypes.includes(DEFAULT_MODEL_NAME)
            ? DEFAULT_MODEL_NAME
            : noteTypes[0] || currentModelName;

          if (preferredModelName && preferredModelName !== currentModelName) {
            modelNameInput.value = preferredModelName;
            updatePreview();
          }

          userModifiedNoteType = false;
        }

        setStatus(statusMessage, "success");
      } catch (error) {
        if (pendingNoteTypeDeck !== deckName) {
          return;
        }

        console.error(error);
        updateModelSuggestions([]);
        setStatus(error.message || "Failed to load note types", "error");
      }
    }

    async function loadDecks() {
      setStatus("Loading decks…");
      loadDecksBtn.disabled = true;
      try {
        const deckNames = await callAnkiConnect("deckNames");
        deckSelect.innerHTML = "";
        if (!deckNames.length) {
          const option = document.createElement("option");
          option.textContent = "No decks found";
          option.disabled = true;
          option.selected = true;
          deckSelect.appendChild(option);
        } else {
          const placeholder = document.createElement("option");
          placeholder.textContent = "Choose a deck";
          placeholder.disabled = true;
          placeholder.selected = true;
          placeholder.value = "";
          deckSelect.appendChild(placeholder);
          for (const deck of deckNames) {
            const option = document.createElement("option");
            option.value = deck;
            option.textContent = deck;
            deckSelect.appendChild(option);
          }
          const savedDeck = getSessionItem(SESSION_KEYS.deck);
          if (savedDeck && deckNames.includes(savedDeck)) {
            deckSelect.value = savedDeck;
            persistDeckSelection();
            await loadNoteTypesForDeck(savedDeck);
            updatePreview();
            return;
          }
        }
        updateModelSuggestions([]);
        setStatus("Decks loaded", "success");
        updatePreview();
      } catch (error) {
        console.error(error);
        setStatus(error.message || "Failed to load decks", "error");
      } finally {
        loadDecksBtn.disabled = false;
      }
    }

    function applyMaskedContent(element, text, lookupTerm) {
      if (!element) {
        return;
      }

      if (!text) {
        element.textContent = "";
        return;
      }

      const masked = maskTargetInText(text, lookupTerm);
      if (masked && masked !== text) {
        element.innerHTML = masked;
      } else {
        element.textContent = text;
      }
    }

    function createBadge(text, variant = "") {
      const badge = document.createElement("span");
      badge.className = "badge" + (variant ? " " + variant : "");
      badge.textContent = text;
      return badge;
    }

    function buildDefinitionEntry(entry, lookupTerm) {
      const details = document.createElement("details");
      details.className = "definition-entry";

      const summary = document.createElement("summary");
      const summaryText = document.createElement("div");
      summaryText.className = "entry-summary-text";

      const headword = document.createElement("span");
      headword.className = "entry-headword";
      headword.textContent = entry.word || lookupTerm;
      summaryText.appendChild(headword);

      const badgeRow = document.createElement("div");
      badgeRow.className = "badge-row";
      if (entry.isExistingNote) {
        badgeRow.appendChild(createBadge("Existing card"));
      }
      if (entry.source) {
        badgeRow.appendChild(createBadge(entry.source, "secondary"));
      }
      const partLabels = new Set();
      (entry.meanings || []).forEach((meaning) => {
        if (meaning?.partOfSpeech) {
          partLabels.add(meaning.partOfSpeech);
        }
      });
      if (!partLabels.size) {
        partLabels.add("Definition");
      }
      partLabels.forEach((label) => badgeRow.appendChild(createBadge(label)));
      summaryText.appendChild(badgeRow);

      summary.appendChild(summaryText);
      details.appendChild(summary);

      const content = document.createElement("div");
      content.className = "entry-content";

      if (entry.note) {
        const noteParagraph = document.createElement("p");
        noteParagraph.style.margin = "0";
        noteParagraph.textContent = entry.note;
        content.appendChild(noteParagraph);
      }

      if (entry.phonetic) {
        const phonetic = document.createElement("p");
        phonetic.style.margin = "0";
        phonetic.innerHTML = `<strong>Phonetic:</strong> ${entry.phonetic}`;
        content.appendChild(phonetic);
      }

      if (entry.isExistingNote && entry.noteDetails) {
        const actions = document.createElement("div");
        actions.className = "entry-actions";

        const loadButton = document.createElement("button");
        loadButton.textContent = "Load this card";
        loadButton.addEventListener("click", () => {
          applyNoteToEditor(entry.noteDetails);
          const deckLabel = entry.noteDetails.deckName
            ? ` from "${entry.noteDetails.deckName}"`
            : "";
          setStatus(`Existing card loaded${deckLabel}.`, "success");
        });
        actions.appendChild(loadButton);

        const updateButton = document.createElement("button");
        updateButton.textContent = "Update card";
        updateButton.addEventListener("click", async () => {
          try {
            setStatus("Updating existing card…");
            updateButton.disabled = true;
            await updateExistingNoteFromEditor(entry.noteDetails);
            if (entry.noteDetails.fieldMap.front) {
              entry.noteDetails.fields.frontHtml = frontField.value.trim();
              entry.noteDetails.display.frontText = stripHtml(
                entry.noteDetails.fields.frontHtml
              );
              if (entry.noteDetails.display.frontText) {
                entry.word = entry.noteDetails.display.frontText;
                headword.textContent = entry.word;
              }
            }
            if (entry.noteDetails.fieldMap.back) {
              entry.noteDetails.fields.backHtml = backField.value.trim();
            }
            if (entry.noteDetails.fieldMap.example) {
              entry.noteDetails.fields.exampleHtml = exampleField.value.trim();
            }
            setStatus("Existing card updated.", "success");
          } catch (error) {
            console.error(error);
            setStatus(error.message || "Failed to update note", "error");
          } finally {
            updateButton.disabled = false;
          }
        });
        actions.appendChild(updateButton);

        content.appendChild(actions);
      }

      (entry.meanings || []).forEach((meaning) => {
        const meaningBlock = document.createElement("div");
        meaningBlock.className = "meaning-block";

        const meaningTitle = document.createElement("div");
        meaningTitle.className = "meaning-title";
        meaningTitle.appendChild(createBadge(meaning.partOfSpeech || "Definition"));
        const definitionCount = Array.isArray(meaning.definitions)
          ? meaning.definitions.length
          : 0;
        if (definitionCount > 1) {
          meaningTitle.appendChild(createBadge(`${definitionCount} defs`, "secondary"));
        }
        meaningBlock.appendChild(meaningTitle);

        const definitionList = document.createElement("ol");
        definitionList.className = "definition-list";

        (meaning.definitions || []).forEach((definition) => {
          const listItem = document.createElement("li");
          listItem.className = "definition-item";

          const definitionText = document.createElement("p");
          definitionText.className = "definition-text";
          applyMaskedContent(definitionText, definition.definition, lookupTerm);
          listItem.appendChild(definitionText);

          if (definition.example) {
            const exampleText = document.createElement("p");
            exampleText.className = "example-text";
            applyMaskedContent(exampleText, definition.example, lookupTerm);

            if (entry.isExistingNote) {
              listItem.appendChild(exampleText);
            } else {
              const exampleButton = document.createElement("button");
              exampleButton.textContent = "Use this example";
              exampleButton.addEventListener("click", () => {
                exampleField.value = maskTargetInText(
                  definition.example,
                  lookupTerm
                );
                updatePreview();
                setStatus("Example added to the card", "success");
              });

              const exampleWrapper = document.createElement("div");
              exampleWrapper.style.display = "grid";
              exampleWrapper.style.gap = "0.4rem";
              exampleWrapper.appendChild(exampleText);
              exampleWrapper.appendChild(exampleButton);
              listItem.appendChild(exampleWrapper);
            }
          }

          definitionList.appendChild(listItem);
        });

        meaningBlock.appendChild(definitionList);
        content.appendChild(meaningBlock);
      });

      details.appendChild(content);
      return details;
    }

    function buildSynonymEntry(entry, lookupTerm) {
      if (!Array.isArray(entry.synonyms) || !entry.synonyms.length) {
        return null;
      }

      const details = document.createElement("details");
      details.className = "definition-entry";

      const summary = document.createElement("summary");
      const summaryText = document.createElement("div");
      summaryText.className = "entry-summary-text";

      const headword = document.createElement("span");
      headword.className = "entry-headword";
      headword.textContent = `Synonyms for ${entry.word || lookupTerm}`;
      summaryText.appendChild(headword);

      const badgeRow = document.createElement("div");
      badgeRow.className = "badge-row";
      badgeRow.appendChild(createBadge(entry.source || "Synonyms", "secondary"));
      summaryText.appendChild(badgeRow);

      summary.appendChild(summaryText);
      details.appendChild(summary);

      const content = document.createElement("div");
      content.className = "entry-content";

      const intro = document.createElement("p");
      intro.style.margin = "0";
      intro.textContent = "Click a synonym to search it.";
      content.appendChild(intro);

      const cloud = document.createElement("div");
      cloud.className = "synonym-cloud";
      entry.synonyms.slice(0, 40).forEach((synonym) => {
        const button = document.createElement("button");
        button.type = "button";
        button.textContent = synonym;
        button.addEventListener("click", () => {
          lookupTermInput.value = synonym;
          searchDictionary();
        });
        cloud.appendChild(button);
      });

      content.appendChild(cloud);
      details.appendChild(content);
      return details;
    }

    function renderSpellingSuggestionsList(suggestions, parsedTerm) {
      if (!spellingSuggestions) {
        return;
      }

      const filtered = Array.isArray(suggestions)
        ? suggestions.filter(
            (suggestion) =>
              suggestion &&
              suggestion.toLowerCase() !== (parsedTerm?.term || "").toLowerCase()
          )
        : [];

      if (!filtered.length) {
        spellingSuggestions.hidden = true;
        spellingSuggestions.innerHTML = "";
        return;
      }

      spellingSuggestions.hidden = false;
      spellingSuggestions.innerHTML = "";

      const label = document.createElement("span");
      label.textContent = "Possible spellings:";
      spellingSuggestions.appendChild(label);

      filtered.forEach((suggestion) => {
        const suggestionButton = document.createElement("button");
        suggestionButton.type = "button";
        suggestionButton.textContent = suggestion;
        suggestionButton.addEventListener("click", () => {
          lookupTermInput.value = suggestion;
          searchDictionary();
        });
        spellingSuggestions.appendChild(suggestionButton);
      });
    }

    function renderDictionaryResults(entries, parsedTerm) {
      dictionaryResults.innerHTML = "";
      if (!entries || !entries.length) {
        dictionaryResults.textContent = "No results found.";
        return;
      }

      entries.forEach((entry, index) => {
        let element = null;
        if (entry.isSynonymList) {
          element = buildSynonymEntry(entry, parsedTerm.term);
        } else {
          element = buildDefinitionEntry(entry, parsedTerm.term);
          if (element && index === 0) {
            element.open = true;
          }
        }

        if (element) {
          dictionaryResults.appendChild(element);
        }
      });
    }

    async function searchDictionary() {
      const rawInput = lookupTermInput.value.trim();
      if (!rawInput) {
        setStatus("Type a term to search", "error");
        return;
      }

      const parsedTerm = parseLookupTerm(rawInput);
      if (!parsedTerm.term) {
        setStatus("Type a term to search", "error");
        return;
      }

      lastPartOfSpeechFilter = parsedTerm.partOfSpeech;
      updateDictionaryScopeLabel(parsedTerm.partOfSpeech);

      const shouldSearchOnline = activeSearchScope !== SEARCH_SCOPES.decksOnly;
      const shouldSearchDecks = activeSearchScope !== SEARCH_SCOPES.onlineOnly;

      const scopeLabel = shouldSearchOnline && shouldSearchDecks
        ? "online dictionaries and decks"
        : shouldSearchOnline
        ? "online dictionaries"
        : "your decks";

      setStatus(`Searching ${scopeLabel} for "${parsedTerm.term}"…`);
      searchButton.disabled = true;
      dictionaryResults.textContent = "Searching…";
      renderSpellingSuggestionsList([], parsedTerm);

      const providerIds = shouldSearchOnline ? getActiveDictionaryProviderIds() : [];
      const uniqueEntryKeys = new Set();
      const collectedEntries = [];
      const contributingProviders = new Set();
      const missingCredentials = [];
      const providerErrors = [];
      let embeddedMatchCount = 0;

      const addEntries = (entries, providerLabel = "", options = {}) => {
        const { prepend = false, trackProvider = true } = options;
        if (!Array.isArray(entries)) {
          return;
        }

        const iterable = prepend ? [...entries].reverse() : entries;

        iterable.forEach((entry) => {
          if (!entry) {
            return;
          }

          if (entry.isSynonymList) {
            if (!Array.isArray(entry.synonyms) || !entry.synonyms.length) {
              return;
            }
          } else if (!Array.isArray(entry.meanings) || !entry.meanings.length) {
            return;
          }

          const key = entry.uniqueKey
            ? entry.uniqueKey
            : entry.isSynonymList
            ? `syn-${(entry.source || providerLabel || "").toLowerCase()}-${(entry.word || "").toLowerCase()}-${entry.synonyms.join("|")}`
            : JSON.stringify({
                source: entry.source || providerLabel || "",
                word: entry.word || "",
                meanings: (entry.meanings || []).map((meaning) => ({
                  partOfSpeech: meaning.partOfSpeech || "",
                  definitions: (meaning.definitions || []).map((definition) => ({
                    definition: definition.definition || "",
                    example: definition.example || "",
                  })),
                })),
              });

          if (uniqueEntryKeys.has(key)) {
            return;
          }
          uniqueEntryKeys.add(key);

          if (prepend) {
            collectedEntries.unshift(entry);
          } else {
            collectedEntries.push(entry);
          }

          if (trackProvider) {
            const contributor = entry.source || providerLabel;
            if (contributor) {
              contributingProviders.add(contributor);
            }
          }
        });
      };

      try {
        const suggestionsPromise = shouldSearchOnline
          ? fetchSpellingSuggestions(parsedTerm.term)
          : Promise.resolve([]);

        const deckLookupPromise = shouldSearchDecks
          ? findDeckEntries(parsedTerm.term, deckSelect.value)
          : Promise.resolve({
              deckName: deckSelect.value || "",
              entries: [],
              totalCount: 0,
              shownCount: 0,
              truncated: false,
              error: "",
            });

        const providerResponses = await Promise.all(
          providerIds.map(async (providerId) => {
            const provider = dictionaryProviders[providerId];
            if (!provider) {
              return { providerId, entries: [], embeddedCount: 0, skipped: false };
            }

            const credentials = getProviderCredentials(provider.id);
            if (provider.requiresCredentials) {
              const requiredKeys = Array.isArray(provider.credentialKeys)
                ? provider.credentialKeys
                : [];
              const missingKeys = requiredKeys.filter((key) => !credentials[key]);
              if (missingKeys.length) {
                missingCredentials.push(provider.label || providerId);
                return { providerId, entries: [], embeddedCount: 0, skipped: true };
              }
            }

            const providerEntries = [];
            let providerEmbeddedCount = 0;

            try {
              const directEntries = await provider.fetchEntries(parsedTerm.term, parsedTerm, {
                credentials,
              });
              if (Array.isArray(directEntries)) {
                providerEntries.push(...directEntries);
              }
            } catch (error) {
              console.warn(`Lookup failed for ${provider.label || providerId}`, error);
              if (error?.message) {
                providerErrors.push(`${provider.label || providerId}: ${error.message}`);
              }
            }

            if (provider.supportsEmbeddedSearch && parsedTerm.tokens.length > 1) {
              try {
                const embeddedEntries = await searchWithinEntries(parsedTerm, providerId, credentials);
                providerEmbeddedCount += embeddedEntries.length;
                if (Array.isArray(embeddedEntries)) {
                  providerEntries.push(...embeddedEntries);
                }
              } catch (embeddedError) {
                console.warn(`Embedded search failed for ${provider.label || providerId}`, embeddedError);
              }
            }

            const filteredEntries = providerEntries
              .map((entry) =>
                entry && !entry.isSynonymList
                  ? filterEntryByPartOfSpeech(entry, parsedTerm.partOfSpeech)
                  : entry
              )
              .filter(Boolean);

            return { providerId, entries: filteredEntries, embeddedCount: providerEmbeddedCount };
          })
        );

        const deckLookupSummary = await deckLookupPromise;
        const suggestions = await suggestionsPromise.catch(() => []);
        renderSpellingSuggestionsList(suggestions, parsedTerm);

        providerResponses.forEach(({ providerId, entries, embeddedCount }) => {
          embeddedMatchCount += embeddedCount;
          const providerLabel = dictionaryProviders[providerId]?.label || providerId;
          addEntries(entries, providerLabel);
        });

        if (deckLookupSummary.entries.length) {
          addEntries(deckLookupSummary.entries, deckLookupSummary.deckName || "Existing cards", {
            prepend: true,
            trackProvider: false,
          });
        }

        if (!collectedEntries.length) {
          renderDictionaryResults([], parsedTerm);
          let emptyMessage = "No entries available.";
          if (deckLookupSummary.deckName && deckLookupSummary.error) {
            emptyMessage += ` Deck lookup failed for "${deckLookupSummary.deckName}": ${deckLookupSummary.error}`;
          }
          if (missingCredentials.length) {
            emptyMessage += ` Skipped ${missingCredentials.join(", ")} (missing credentials).`;
          }
          setStatus(emptyMessage, "error");
          return;
        }

        renderDictionaryResults(collectedEntries, parsedTerm);

        const statusParts = [];

        if (shouldSearchOnline) {
          const providerList = Array.from(contributingProviders);
          let providerSummary;
          if (!providerIds.length) {
            providerSummary = "no online dictionaries";
          } else if (!providerList.length) {
            providerSummary = providerIds.length === 1
              ? dictionaryProviders[providerIds[0]]?.label || providerIds[0]
              : "selected dictionaries";
          } else if (providerList.length === 1) {
            providerSummary = providerList[0];
          } else {
            providerSummary = `${providerList.length} dictionaries (${providerList.join(", ")})`;
          }
          const embeddedNote = embeddedMatchCount
            ? ` including ${embeddedMatchCount} embedded match${embeddedMatchCount === 1 ? "" : "es"}`
            : "";
          statusParts.push(`Dictionary results loaded from ${providerSummary}${embeddedNote}.`);
        }

        if (shouldSearchDecks && deckLookupSummary.deckName) {
          if (deckLookupSummary.error) {
            statusParts.push(
              `Deck lookup failed for "${deckLookupSummary.deckName}": ${deckLookupSummary.error}`
            );
          } else if (deckLookupSummary.totalCount > 0) {
            let deckMessage = `Found ${deckLookupSummary.totalCount} existing card${
              deckLookupSummary.totalCount === 1 ? "" : "s"
            } in "${deckLookupSummary.deckName}"`;
            if (deckLookupSummary.truncated && deckLookupSummary.shownCount) {
              deckMessage += ` (showing first ${deckLookupSummary.shownCount})`;
            }
            deckMessage += ".";
            statusParts.push(deckMessage);
          } else {
            statusParts.push(`No existing cards matched in "${deckLookupSummary.deckName}".`);
          }
        }

        if (missingCredentials.length) {
          statusParts.push(`Skipped ${missingCredentials.join(", ")} (missing credentials).`);
        }

        if (providerErrors.length) {
          statusParts.push(`Dictionary errors: ${providerErrors.join("; ")}.`);
        }

        const statusType = deckLookupSummary.error || providerErrors.length ? "error" : "success";
        setStatus(statusParts.join(" "), statusType);
      } catch (error) {
        console.error(error);
        dictionaryResults.textContent = "No entries available.";
        setStatus(error.message || "Failed to fetch dictionary results", "error");
      } finally {
        searchButton.disabled = false;
      }
    }
    async function addCard() {
      const deckName = deckSelect.value;
      const modelName = modelNameInput.value.trim() || DEFAULT_MODEL_NAME;
      const front = frontField.value.trim();
      const back = backField.value.trim();

      if (!deckName) {
        setStatus("Please choose a deck", "error");
        return;
      }

      if (!front || !back) {
        setStatus("Front and back cannot be empty", "error");
        return;
      }

      setStatus("Adding card to deck…");
      addCardBtn.disabled = true;

      const example = exampleField.value.trim();
      const tags = tagsInput.value
        .split(",")
        .map((tag) => tag.trim())
        .filter(Boolean);

      const fields = {
        Front: front,
        Back: example ? `${back}\n\n<em>${example}</em>` : back,
      };

      try {
        await callAnkiConnect("addNote", {
          note: {
            deckName,
            modelName,
            fields,
            tags,
          },
        });

        try {
          await callAnkiConnect("sync");
          setStatus(
            "Card added and sync requested using Anki's saved session.",
            "success"
          );
        } catch (syncError) {
          console.warn("Sync failed", syncError);
          setStatus(
            `Card added but sync failed via saved session: ${syncError.message}`,
            "error"
          );
        }
      } catch (error) {
        console.error(error);
        setStatus(error.message || "Failed to add card", "error");
      } finally {
        addCardBtn.disabled = false;
      }
    }

    const initialDeckSelection = getSessionItem(SESSION_KEYS.deck);
    if (initialDeckSelection) {
      loadDecks();
    }

    loadDecksBtn.addEventListener("click", loadDecks);
    searchButton.addEventListener("click", searchDictionary);
    lookupTermInput.addEventListener("keydown", (event) => {
      if (event.key === "Enter") {
        event.preventDefault();
        searchDictionary();
      }
    });
    addCardBtn.addEventListener("click", addCard);

    updatePreview();
  </script>
</body>
</html>
